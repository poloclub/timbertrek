{"version":3,"file":"lib_index_js.ff5d7e8ac5c9e6555253.js","mappings":";;;;;;;;;;;;;;;;;;AAAqD;AACG;AACd;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,mDAAU;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,kEAAkB;AACrC;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7CmD;AACI;AACV;AACL;AACI;AACV;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,OAAO;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B,6DAAM;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAuB;AACrD;AACA;AACA;AACA;AACA;AACA,+BAA+B,qEAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qDAAc,CAAC,sDAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,wDAAoB;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,sDAAkB;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,sDAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAA0C;AAClD,QAAQ,kFAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAA4B,GAAG,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAA2B;AACnC,QAAQ,gFAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+FAA6C;AACrD,QAAQ,qFAAmC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9bsC;AACM;AACR;AAC7B;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAAqC;AAC3E;AACA;AACA;AACA,sCAAsC,oEAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAA4B;AAClE;AACA;AACA;AACA;AACA;AACA,sCAAsC,uEAAgC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAQ;AACtC;AACA;;;;;;;;;;;;;;;;;;;ACxIiD;AACT;AACN;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2DAAY;AAC/D;AACA,kCAAkC,0DAAoB;AACtD;AACA;AACA;AACA,kCAAkC,sDAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAgB;AACrC,+DAA+D,sDAAgB;AAC/E;AACA,qBAAqB,0DAAoB;AACzC,+DAA+D,0DAAoB;AACnF;AACA,qBAAqB,0DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAuB,GAAG,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAkC;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC,0DAAoB,EAAE;AACxE,cAAc,oBAAoB,sDAAgB,EAAE;AACpD,cAAc,wBAAwB,0DAAoB;AAC1D;AACA;AACA;AACA,2BAA2B,iDAAW;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnJwC;AACN;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,MAAM,WAAW;AACpD,oBAAoB,WAAW,IAAI,YAAY;AAC/C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B,WAAW,MAAM,WAAW;AACtD,sBAAsB,WAAW,IAAI,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAA0B,GAAG,wBAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C,yCAAyC,KAAK;AAC9C;AACA;AACA,kDAAkD,6CAA6C;AAC/F;AACA;AACA,mDAAmD,8CAA8C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C,iCAAiC,OAAO;AACxC,sCAAsC,gDAAgD;AACtF,uCAAuC,gDAAgD;AACvF;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAgB;AACzC,2CAA2C,UAAU;AACrD;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAwB,GAAG,kBAAkB;AACrD;AACA;AACA;AACA;AACA,QAAQ,8DAA0B,GAAG,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sCAAsC;AAC7E;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC7W6H;AAC7E;AACU;AACJ;AACJ;AACI;AACA;AACE;AACN;AACQ;AACnD;AACP;AACA,kBAAkB,8DAAO;AACzB,mBAAmB,+DAAQ;AAC3B,uBAAuB,mEAAY;AACnC,oBAAoB,gEAAS;AAC7B,6BAA6B,yEAAkB;AAC/C,mBAAmB,8DAAO;AAC1B,sBAAsB,8DAAO;AAC7B;AACA,YAAY,+DAAO;AACnB,CAAC;AACD,2BAA2B,8DAAO;AAClC;AACA,YAAY,oEAAY;AACxB,CAAC;AACD,yBAAyB,8DAAO;AAChC;AACA,YAAY,kEAAU;AACtB,CAAC;AACD,uBAAuB,8DAAO;AAC9B;AACA,YAAY,gEAAQ;AACpB,CAAC;AACD,yBAAyB,8DAAO;AAChC;AACA,YAAY,kEAAU;AACtB,CAAC;AACD,yBAAyB,8DAAO;AAChC;AACA,YAAY,kEAAU;AACtB,CAAC;AACD,0BAA0B,8DAAO;AACjC;AACA,YAAY,mEAAW;AACvB,CAAC;AACD,uBAAuB,8DAAO;AAC9B;AACA,YAAY,gEAAQ;AACpB,CAAC;AACD,2BAA2B,8DAAO;AAClC;AACA,YAAY,oEAAY;AACxB,CAAC;;;;;;;;;;;;;;;;;;ACrDsD;AACZ;AAC3C;AACA;AACA;AACA,eAAe,iEAAe;AAC9B;AACA;AACA,2DAA2D,oDAAe;AAC1E;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;ACXiC;AACX;AACJ;AACN;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,OAAO;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qDAAc,CAAC,0DAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,oDAAgB;AACtC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,sDAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAA2B;AACnC,QAAQ,gFAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7QkC;AACA;AAClC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAwB,GAAG,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2CAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/NuD;AACb;AACE;AACR;AACI;AACN;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAA4B,GAAG,oBAAoB;AAC/D;AACA;AACA;AACA,mCAAmC,mDAAa;AAChD;AACA;AACA,0BAA0B,0DAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAoB;AACtD,0CAA0C,6CAAU;AACpD,kCAAkC,sDAAgB;AAClD;AACA,+CAA+C,qDAAc;AAC7D,kCAAkC,0DAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,6BAA6B,sDAAgB;AAC7C,yDAAyD,aAAa;AACtE,iFAAiF,aAAa;AAC9F;AACA;AACA,6BAA6B,0DAAoB;AACjD,6DAA6D,aAAa;AAC1E,qFAAqF,aAAa;AAClG;AACA;AACA,6BAA6B,0DAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+FAA6C;AACzD,YAAY,qFAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAwB,GAAG,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAA0C;AAClD,QAAQ,kFAAgC;AACxC;AACA;;;;;;;;;;;;;;;AC5RA,iEAAe,0QAA0Q;;;;;;;;;;;;;;ACAzR,iEAAe,+OAA+O;;;;;;;;;;;;;;ACA9P,iEAAe,4XAA4X;;;;;;;;;;;;;;ACA3Y,iEAAe,mWAAmW,kEAAkE,kBAAkB,mBAAmB,07BAA07B;;;;;;;;;;;;;;ACAn5C,iEAAe,mNAAmN;;;;;;;;;;;;;;ACAlO,iEAAe,yXAAyX,kBAAkB,sBAAsB,oBAAoB,kmCAAkmC;;;;;;;;;;;;;;ACAtiD,iEAAe,gPAAgP;;;;;;;;;;;;;;ACA/P,iEAAe,6YAA6Y;;;;;;;;;;;;;;ACA5Z,iEAAe,icAAic","sources":["webpack://jupyterlab-stickyland/./lib/button.js","webpack://jupyterlab-stickyland/./lib/code.js","webpack://jupyterlab-stickyland/./lib/content.js","webpack://jupyterlab-stickyland/./lib/dropzone.js","webpack://jupyterlab-stickyland/./lib/floating.js","webpack://jupyterlab-stickyland/./lib/icons.js","webpack://jupyterlab-stickyland/./lib/index.js","webpack://jupyterlab-stickyland/./lib/markdown.js","webpack://jupyterlab-stickyland/./lib/stickyland.js","webpack://jupyterlab-stickyland/./lib/tab.js","webpack://jupyterlab-stickyland/./style/img/icon-add.svg","webpack://jupyterlab-stickyland/./style/img/icon-chevron.svg","webpack://jupyterlab-stickyland/./style/img/icon-close2.svg","webpack://jupyterlab-stickyland/./style/img/icon-collapse.svg","webpack://jupyterlab-stickyland/./style/img/icon-drag.svg","webpack://jupyterlab-stickyland/./style/img/icon-expand.svg","webpack://jupyterlab-stickyland/./style/img/icon-land.svg","webpack://jupyterlab-stickyland/./style/img/icon-launch.svg","webpack://jupyterlab-stickyland/./style/img/icon-tabclose.svg"],"sourcesContent":["import { ToolbarButton } from '@jupyterlab/apputils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { StickyLand } from './stickyland';\nexport class ButtonExtension {\n    constructor() {\n        this.stickyLandMap = new Map();\n    }\n    createNew(panel, context) {\n        /**\n         * Handler for the click event.\n         */\n        const onClickHandler = () => {\n            var _a, _b, _c;\n            // Check if we have already created stickyland\n            const curPath = context.path;\n            // Create it if we don't have it yet\n            if (!((_a = this.stickyLandMap) === null || _a === void 0 ? void 0 : _a.has(curPath))) {\n                (_b = this.stickyLandMap) === null || _b === void 0 ? void 0 : _b.set(curPath, new StickyLand(panel));\n            }\n            const curStickyLand = (_c = this.stickyLandMap) === null || _c === void 0 ? void 0 : _c.get(curPath);\n            // Check if we should show or hide this container\n            if (curStickyLand === null || curStickyLand === void 0 ? void 0 : curStickyLand.isHidden()) {\n                curStickyLand === null || curStickyLand === void 0 ? void 0 : curStickyLand.show();\n            }\n            else {\n                curStickyLand === null || curStickyLand === void 0 ? void 0 : curStickyLand.hide();\n            }\n            // Alternative way to insert StickyLand to the notebook widget (boxLayout)\n            // const stickyLand = new StickyLand();\n            // const panelLayout = panel.layout as BoxLayout;\n            // panelLayout.addWidget(stickyLand);\n        };\n        const button = new ToolbarButton({\n            className: 'sticky-button',\n            iconClass: 'far fa-sticky-note',\n            onClick: onClickHandler,\n            tooltip: 'Show/Hide StickyLand'\n        });\n        // const numItems = toArray(panel.toolbar.children()).length;\n        const insertIndex = 10;\n        panel.toolbar.insertItem(insertIndex, 'stickyLand', button);\n        return new DisposableDelegate(() => {\n            button.dispose();\n        });\n    }\n}\n","import { Switch } from '@jupyterlab/ui-components';\nimport { NotebookActions } from '@jupyterlab/notebook';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { ContentType } from './content';\nimport { FloatingWindow } from './floating';\nimport { MyIcons } from './icons';\n/**\n * Class that implements the Code cell in StickyLand.\n */\nexport class StickyCode {\n    constructor() {\n        this.autoRun = false;\n        this.autoRunScheduled = false;\n        this.runScheduled = false;\n        this.isDisposed = false;\n        this.isFloating = false;\n        this.floatingWindow = null;\n        /**\n         * We use a mutation observer to detect if the output area is redrawn.\n         * Remember to disconnect the observer in the dispose() method.\n         * @param mutationList Array of mutation records\n         * @param observer The observer itself\n         */\n        this.codeOutputMutationHandler = (mutationList, observer) => {\n            mutationList.forEach(d => {\n                var _a, _b;\n                // Remove the prompt area when the output node is updated\n                if (d.addedNodes !== null) {\n                    (_b = (_a = this.outputNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.jp-OutputPrompt')) === null || _b === void 0 ? void 0 : _b.forEach(d => d.remove());\n                }\n            });\n        };\n        /**\n         * We use a mutation observer to detect if user focuses on the code cell in\n         * StickyLand. Remember to disconnect the observer in the dispose() method.\n         * @param mutationList Array of mutation records\n         * @param observer The observer itself\n         */\n        this.codeClassMutationHandler = (mutationList, observer) => {\n            mutationList.forEach(d => {\n                var _a;\n                if (d.attributeName === 'class') {\n                    if ((_a = this.editorNode) === null || _a === void 0 ? void 0 : _a.classList.contains('jp-mod-focused')) {\n                        this.executionCounter.classList.add('mod-focused');\n                    }\n                    else {\n                        this.executionCounter.classList.remove('mod-focused');\n                    }\n                }\n            });\n        };\n        /**\n         * We listen to the execution state of this notebook. We use it to change the\n         * execution counter to star if the cell is scheduled to run.\n         * @param _ any\n         * @param args Notebook and cell\n         */\n        this.handleExecutionScheduled = (_, args) => {\n            // Change the execution counter\n            if (args.cell.node === this.originalCell.node) {\n                this.runScheduled = true;\n                this.executionCount = null;\n                this.executionCounter.innerText = '[*]';\n            }\n        };\n        /**\n         * We listen to the execution state of this notebook. We use it to change the\n         * execution counter to star if the cell is scheduled to run.\n         * @param _ any\n         * @param args Notebook and cell\n         */\n        this.handleExecuted = (_, args) => {\n            // Change the execution counter\n            if (args.cell.node === this.originalCell.node) {\n                this.runScheduled = false;\n                if (this.executionCount === null) {\n                    this.executionCounter.innerText = '[ ]';\n                }\n            }\n        };\n        /**\n         * Helper function to handle code model state changes. The state change signal\n         * is emitted with anything (input, output, etc.). This function follows the\n         * signal pattern from lumino\n         * (https://github.com/jupyterlab/extension-examples/tree/master/signals)\n         * @param model CodeCellModel\n         * @param args Arguments emitted from the model emitter, an example of the\n         * signal structure is listed\n         * [here](https://github.com/jupyterlab/jupyterlab/blob/5755ea86fef3fdbba10cd05b23703b9d60b53226/packages/cells/src/model.ts#L774)\n         * The args is {name: str, oldValue: any, newValue: any}\n         */\n        this.handleStateChange = (model, args) => {\n            const codeModel = model;\n            switch (args.name) {\n                case 'executionCount':\n                    // Update the execution count\n                    this.executionCount = codeModel.executionCount;\n                    // JupyterLab redraws the output area when code is executed, so we need\n                    // to hide the original output every time here\n                    // https://github.com/jupyterlab/jupyterlab/blob/e4e323992d24f6c5e48d181381e23c547b665b15/packages/notebook/src/actions.tsx#L1156\n                    if (this.originalCell.inputHidden) {\n                        this.originalCell.outputHidden = true;\n                    }\n                    break;\n                case 'isDirty':\n                    // Color the execution based on the dirty state\n                    if (args.newValue) {\n                        this.executionCounter.classList.add('dirty');\n                    }\n                    else {\n                        this.executionCounter.classList.remove('dirty');\n                    }\n                    break;\n                default:\n                    break;\n            }\n        };\n        /**\n         * Strip unnecessary elements from the nodes before appending it to stickyland\n         */\n        this.cleanCellClone = () => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            // Remove the left region (prompt and collapser), header and footer\n            (_a = this.cellNode.querySelector('.jp-Cell-inputCollapser')) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = this.cellNode.querySelector('.jp-OutputCollapser')) === null || _b === void 0 ? void 0 : _b.remove();\n            (_c = this.cellNode.querySelector('.jp-InputArea-prompt')) === null || _c === void 0 ? void 0 : _c.remove();\n            (_d = this.cellNode\n                .querySelectorAll('.jp-OutputPrompt')) === null || _d === void 0 ? void 0 : _d.forEach(d => d.remove());\n            (_e = this.cellNode.querySelector('.jp-CellHeader')) === null || _e === void 0 ? void 0 : _e.remove();\n            (_f = this.cellNode.querySelector('.jp-CellFooter')) === null || _f === void 0 ? void 0 : _f.remove();\n            // Add class name to the rendered region\n            (_g = this.cellNode\n                .querySelector('.jp-OutputArea')) === null || _g === void 0 ? void 0 : _g.classList.add('sticky-code-output');\n            this.cellNode.classList.add('sticky-code-cell');\n            this.cellNode.classList.remove('hidden');\n        };\n        /**\n         * Create a toolbar element\n         * @param items List of toolbar item names and onclick handlers\n         */\n        this.createToolbar = (items) => {\n            var _a, _b;\n            const toolbar = document.createElement('div');\n            toolbar.classList.add('sticky-toolbar', 'jp-Toolbar', 'sticky-code-toolbar');\n            const buttonGroup = document.createElement('div');\n            buttonGroup.classList.add('toolbar-buttons');\n            const statusGroup = document.createElement('div');\n            statusGroup.classList.add('toolbar-status');\n            toolbar.appendChild(buttonGroup);\n            toolbar.appendChild(statusGroup);\n            // Add buttons into the toolbar\n            items.forEach(d => {\n                const item = document.createElement('div');\n                item.classList.add('jp-ToolbarButton', 'jp-Toolbar-item');\n                buttonGroup.appendChild(item);\n                const itemElem = document.createElement('button');\n                itemElem.classList.add('jp-ToolbarButtonComponent', 'button', 'jp-Button', 'toolbar-button', 'bp3-button', 'bp3-minimal', `button-${d.name}`);\n                itemElem.setAttribute('title', d.title);\n                itemElem.addEventListener('click', d.onClick);\n                item.appendChild(itemElem);\n                // Add icon to the button\n                const iconSpan = document.createElement('span');\n                iconSpan.classList.add('jp-ToolbarButtonComponent-icon');\n                itemElem.appendChild(iconSpan);\n                d.icon.element({\n                    container: iconSpan\n                });\n            });\n            // Hide the expand button at first\n            (_b = (_a = buttonGroup\n                .querySelector('.button-expand')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add('no-display');\n            // Add a toggle switch into the toolbar\n            this.toggle = new Switch();\n            this.toggle.valueChanged.connect((_, args) => {\n                this.autoRun = args.newValue;\n            });\n            this.toggle.value = this.autoRun;\n            this.toggle.label = 'auto-run';\n            // Add a tooltip title\n            this.toggle.node.setAttribute('title', 'Automatically run this cell after any other cell is executed');\n            // Here we are not correctly attach the widget to a layout, so we need to\n            // manually trigger the event binding\n            const toggleSwitchNode = this.toggle.node.querySelector('.jp-switch');\n            toggleSwitchNode === null || toggleSwitchNode === void 0 ? void 0 : toggleSwitchNode.addEventListener('click', this.toggle);\n            buttonGroup.appendChild(this.toggle.node);\n            // Add an execution counter into the toolbar\n            this.executionCounter = document.createElement('div');\n            this.executionCounter.classList.add('execution-counter');\n            statusGroup.appendChild(this.executionCounter);\n            return toolbar;\n        };\n        /**\n         * Run the code cell. The implementation logic is: (1) change the original cell\n         * as the active cell, (2) use the NotebookActions to run the current active\n         * cell\n         */\n        this.execute = (restoreActiveCell = false) => {\n            const restoreActiveCellIndex = this.notebook.content.activeCellIndex;\n            // Find the cell index of the original cell\n            // Note it can change as users can insert cells above and below the cell\n            // Jupyter lab internally iterates through all widgets to find the index\n            // https://github.com/jupyterlab/jupyterlab/blob/5755ea86fef3fdbba10cd05b23703b9d60b53226/packages/notebook/src/widget.ts#L1803\n            const cellIndex = ArrayExt.findFirstIndex(this.notebook.content.widgets, widget => widget.node === this.originalCell.node);\n            // Change the active cell to the original cell\n            this.notebook.content.activeCellIndex = cellIndex;\n            // Blur the focused editor\n            this.cell.editor.blur();\n            // Run the active cell\n            const runPromise = NotebookActions.run(this.notebook.content, this.notebook.context.sessionContext);\n            // Restore the active cell if needed\n            if (restoreActiveCell) {\n                this.notebook.content.activeCellIndex = restoreActiveCellIndex;\n            }\n            return runPromise;\n        };\n        /**\n         * Float the current code cell.\n         */\n        this.float = () => {\n            // Create the floating window and put content from stickyland to the floating\n            // window\n            this.floatingWindow = new FloatingWindow(ContentType.Code, this);\n            // Finally, toggle the `isFloating` property\n            this.isFloating = true;\n        };\n        this.runClicked = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Run the cell\n            this.execute(true);\n        };\n        this.launchClicked = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            this.float();\n        };\n        this.closeClicked = () => {\n            // Show the original cell\n            this.originalCell.inputHidden = false;\n            this.originalCell.outputHidden = false;\n            // TEMP: replace the current content with the dropzone\n            this.stickyContent.showDropzone();\n            // Remove the code cell\n            this.dispose();\n        };\n        this.collapseClicked = (event) => {\n            var _a, _b, _c, _d;\n            event.preventDefault();\n            event.stopPropagation();\n            // Hide the input region\n            this.cell.inputHidden = true;\n            // Swap the icon in the toolbar\n            (_b = (_a = this.stickyContent.headerNode\n                .querySelector('.button-collapse')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add('no-display');\n            (_d = (_c = this.stickyContent.headerNode\n                .querySelector('.button-expand')) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.classList.remove('no-display');\n            // Show the input placeholder\n            this.placeholder.classList.remove('no-display');\n        };\n        this.expandClicked = (event) => {\n            var _a, _b, _c, _d;\n            event.preventDefault();\n            event.stopPropagation();\n            // Hide the input region\n            this.cell.inputHidden = false;\n            // Swap the icon in the toolbar\n            (_b = (_a = this.stickyContent.headerNode\n                .querySelector('.button-collapse')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.remove('no-display');\n            (_d = (_c = this.stickyContent.headerNode\n                .querySelector('.button-expand')) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.classList.add('no-display');\n            // Hide the input placeholder\n            this.placeholder.classList.add('no-display');\n        };\n        this.toolBarItems = [\n            {\n                name: 'run',\n                title: 'Run the cell',\n                icon: MyIcons.runIcon,\n                onClick: this.runClicked\n            },\n            {\n                name: 'collapse',\n                title: 'Hide the input',\n                icon: MyIcons.collapseIcon,\n                onClick: this.collapseClicked\n            },\n            {\n                name: 'expand',\n                title: 'Show the input',\n                icon: MyIcons.expandIcon,\n                onClick: this.expandClicked\n            },\n            {\n                name: 'launch',\n                title: 'Make the cell float',\n                icon: MyIcons.launchIcon,\n                onClick: this.launchClicked\n            }\n        ];\n        /**\n         * Bind event handlers for sticky code cell.\n         */\n        this.bindEventHandlers = () => {\n            // Bind keyboard shortcuts\n            this.node.addEventListener('keydown', (e) => {\n                if (e.key === 'Enter') {\n                    if (e.shiftKey || e.ctrlKey) {\n                        // [Shift + enter] or [control + enter] runs the code cell\n                        this.execute(true);\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                }\n            });\n        };\n    }\n    /**\n     * Factory function for StickyCode when creating if from an existing cell\n     * through dragging\n     * @param stickyContent The sticky content that contains this markdown cell\n     * @param cell The existing markdown cell\n     * @param notebook The current notebook\n     * @returns A new StickyCode object\n     */\n    static createFromExistingCell(stickyContent, cell, notebook) {\n        const cd = new StickyCode();\n        cd.stickyContent = stickyContent;\n        cd.notebook = notebook;\n        // Clone the cell\n        cd.originalCell = cell;\n        cd.cell = cd.originalCell.clone();\n        // Register the original execution counter node\n        cd.originalExecutionCounter = cd.originalCell.node.querySelector('.jp-InputArea-prompt');\n        // Attach the clone node to stickyland\n        cd.node = document.createElement('div');\n        cd.node.classList.add('sticky-code');\n        // Need to add tabindex so it can receive keyboard events\n        cd.node.setAttribute('tabindex', '0');\n        cd.stickyContent.contentNode.appendChild(cd.node);\n        // Need to append the node to DOM first so we can do the cleaning\n        cd.cellNode = cd.cell.node;\n        cd.cellNode.classList.add('hidden');\n        cd.node.appendChild(cd.cellNode);\n        // Add a toolbar\n        cd.toolbar = cd.createToolbar(cd.toolBarItems);\n        cd.stickyContent.headerNode.appendChild(cd.toolbar);\n        // Bind the Codemirror\n        const codeMirrorNode = cd.cell.node.querySelector('.CodeMirror');\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        cd.codemirror = codeMirrorNode.CodeMirror;\n        // Wow, for some reason the clone somehow has a different codemirror config\n        // from the original cell, need to reset it here\n        // https://codemirror.net/doc/manual.html#setOption\n        cd.codemirror.setOption('lineWrapping', false);\n        cd.executionCount = cd.cell.model.executionCount;\n        // Collapse the original cell (both input and output)\n        cd.originalCell.inputHidden = true;\n        cd.originalCell.outputHidden = true;\n        cd.cell.model.stateChanged.connect(cd.handleStateChange, cd);\n        NotebookActions.executionScheduled.connect(cd.handleExecutionScheduled, cd);\n        NotebookActions.executed.connect(cd.handleExecuted, cd);\n        // Bind events\n        cd.bindEventHandlers();\n        // Clean the unnecessary elements from the node clone\n        cd.cleanCellClone();\n        // Add a mutation observer so we can style the execution counter based on\n        // the code focus\n        cd.codeObserver = new MutationObserver(cd.codeClassMutationHandler);\n        cd.editorNode = cd.cellNode.querySelector('.jp-CodeMirrorEditor');\n        if (cd.editorNode) {\n            cd.codeObserver.observe(cd.editorNode, { attributes: true });\n        }\n        // Add an output area observer because we need to remove the left prompt\n        // area every time the output area is updated\n        cd.outputObserver = new MutationObserver(cd.codeOutputMutationHandler);\n        cd.outputNode = cd.cellNode.querySelector('.jp-OutputArea');\n        if (cd.outputNode) {\n            cd.outputObserver.observe(cd.outputNode, { childList: true });\n        }\n        // Add a hidden placeholder element before the input area. We show it when\n        // users collapse the input\n        cd.placeholder = document.createElement('div');\n        cd.placeholder.classList.add('jp-Placeholder-content', 'no-display');\n        cd.placeholder.addEventListener('click', cd.expandClicked);\n        if (cd.cell.node.firstElementChild !== null) {\n            cd.cell.node.insertBefore(cd.placeholder, cd.cell.node.firstChild);\n        }\n        const placeholderIcon = document.createElement('div');\n        placeholderIcon.classList.add('jp-MoreHorizIcon', 'placeholder-icon');\n        MyIcons.ellipsesIcon.element({ container: placeholderIcon });\n        cd.placeholder.appendChild(placeholderIcon);\n        return cd;\n    }\n    /**\n     * Setter function for the executionCount. It also updates the count element\n     */\n    set executionCount(newCount) {\n        this._executionCount = newCount;\n        // Update the counter element\n        if (newCount !== null) {\n            this.executionCounter.innerText = `[${newCount}]`;\n            this.runScheduled = false;\n        }\n        else {\n            if (!this.runScheduled) {\n                this.executionCounter.innerText = '[ ]';\n            }\n        }\n    }\n    /**\n     * Getter function for the executionCount.\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    /**\n     * Factory function for StickyCode when creating if from a new code cell.\n     * This function would append a new markdown cell to the main notebook.\n     * @param stickyContent The sticky content that contains this markdown cell\n     * @param notebook The current notebook\n     * @returns A new StickyCode object\n     */\n    static createFromNewCell(stickyContent, notebook) {\n        // Append a new code cell to the main notebook\n        NotebookActions.insertBelow(notebook.content);\n        NotebookActions.changeCellType(notebook.content, 'code');\n        const newCell = notebook.content.activeCell;\n        // Activate the original active cell\n        notebook.content.activeCellIndex = notebook.content.activeCellIndex - 1;\n        // Construct StickyCode using the new cell as an existing cell\n        return this.createFromExistingCell(stickyContent, newCell, notebook);\n    }\n    dispose() {\n        // Disconnect signal handlers\n        this.codeObserver.disconnect();\n        this.toggle.dispose();\n        // Disconnect notebook execution signal\n        NotebookActions.executionScheduled.disconnect(this.handleExecutionScheduled, this);\n        NotebookActions.executed.disconnect(this.handleExecuted, this);\n        // Remove nodes\n        this.node.remove();\n        this.toolbar.remove();\n        this.isDisposed = true;\n    }\n}\nStickyCode.numCd = 0;\n","import { Dropzone } from './dropzone';\nimport { StickyMarkdown } from './markdown';\nimport { StickyCode } from './code';\nexport var ContentType;\n(function (ContentType) {\n    ContentType[\"Dropzone\"] = \"Dropzone\";\n    ContentType[\"Code\"] = \"Code\";\n    ContentType[\"Markdown\"] = \"Markdown\";\n})(ContentType || (ContentType = {}));\nexport class StickyContent {\n    constructor(stickyContainer, panel, stickyLand) {\n        this.isDisposed = false;\n        /**\n         * Replace the current content with a dropzone\n         */\n        this.showDropzone = () => {\n            var _a;\n            this.curContent = new Dropzone(this);\n            // It only happens when the user closes the last sticky code/md cell\n            // Dehighlight the tab name\n            (_a = this.stickyLand.stickyTab.activeTab) === null || _a === void 0 ? void 0 : _a.tabNode.classList.remove('new-update');\n        };\n        /**\n         * Replace the dropzone content with a clone of an existing cell\n         * @param cell Existing cell that the users drag over\n         * @param newCellType Cell type of the current cell\n         */\n        this.swapDropzoneWithExistingCell = (cell, newCellType) => {\n            // Remove the dropzone\n            this.curContent.dispose();\n            // Add a new cell\n            switch (newCellType) {\n                case ContentType.Markdown:\n                    // Initialize a markdown cell\n                    this.curContent = StickyMarkdown.createFromExistingCell(this, cell, this.notebook);\n                    break;\n                case ContentType.Code:\n                    // Initialize a code cell\n                    this.curContent = StickyCode.createFromExistingCell(this, cell, this.notebook);\n                    break;\n                default:\n                    break;\n            }\n            // Notify the tab to update tab name\n            this.stickyLand.stickyTab.updateActiveTab();\n        };\n        /**\n         * Replace the dropzone content with a new cell. This operation will append a\n         * new cell to the main notebook.\n         * @param newCellType New cell type\n         */\n        this.swapDropzoneWithNewCell = (newCellType) => {\n            switch (newCellType) {\n                case ContentType.Code:\n                    // Remove the dropzone\n                    this.curContent.dispose();\n                    // Initialize a new code cell\n                    this.curContent = StickyCode.createFromNewCell(this, this.notebook);\n                    break;\n                case ContentType.Markdown:\n                    // Remove the dropzone\n                    this.curContent.dispose();\n                    // Initialize a markdown cell\n                    this.curContent = StickyMarkdown.createFromNewCell(this, this.notebook);\n                    break;\n                default:\n                    break;\n            }\n            // Notify the tab to update tab name\n            this.stickyLand.stickyTab.updateActiveTab();\n        };\n        /**\n         * Handle drag enter according to the current content type\n         * @param event Lumino IDragEvent\n         */\n        this.dragEnterHandler = (event) => {\n            if (this.curContent instanceof Dropzone) {\n                this.curContent.dragEnterHandler(event);\n            }\n        };\n        /**\n         * Handle drag over according to the current content type\n         * @param event Lumino IDragEvent\n         */\n        this.dragOverHandler = (event) => {\n            if (this.curContent instanceof Dropzone) {\n                this.curContent.dragOverHandler(event);\n            }\n        };\n        /**\n         * Handle drop leave according to the current content type\n         * @param event Lumino IDragEvent\n         */\n        this.dragDropHandler = (event) => {\n            if (this.curContent instanceof Dropzone) {\n                this.curContent.dragDropHandler(event);\n            }\n        };\n        /**\n         * Handle drag leave according to the current content type\n         * @param event Lumino IDragEvent\n         */\n        this.dragLeaveHandler = (event) => {\n            if (this.curContent instanceof Dropzone) {\n                this.curContent.dragLeaveHandler(event);\n            }\n        };\n        this.swapToDropzone = () => {\n            // Dispose the current content\n            this.curContent.closeClicked();\n        };\n        this.dispose = () => {\n            // Dispose the current content\n            this.curContent.closeClicked();\n            // Dispose the dropzone\n            this.curContent.dispose();\n            this.wrapperNode.remove();\n            this.isDisposed = true;\n        };\n        this.stickyContainer = stickyContainer;\n        this.notebook = panel;\n        this.stickyLand = stickyLand;\n        // Add the content element\n        this.wrapperNode = document.createElement('div');\n        this.wrapperNode.classList.add('sticky-content');\n        this.stickyContainer.appendChild(this.wrapperNode);\n        // Add a header and a content\n        this.headerNode = document.createElement('div');\n        this.headerNode.classList.add('header');\n        this.wrapperNode.appendChild(this.headerNode);\n        this.contentNode = document.createElement('div');\n        this.contentNode.classList.add('content');\n        this.wrapperNode.appendChild(this.contentNode);\n        // Show a dropzone at first\n        this.curContent = new Dropzone(this);\n    }\n}\n","import { MarkdownCell } from '@jupyterlab/cells';\nimport { ContentType } from './content';\nimport { MyIcons } from './icons';\n/**\n * Class that implements the Dropzone state where the StickyContent is empty\n * and waiting for users to drop some cells.\n */\nexport class Dropzone {\n    constructor(stickyContent) {\n        this.isDisposed = false;\n        /**\n         * Handle drag enter (highlight the border)\n         * @param event Lumino IDragEvent\n         */\n        this.dragEnterHandler = (event) => {\n            // Highlight the border to indicate dragover\n            if (this.doseReceiveDrop) {\n                this.node.classList.add('drag-over');\n            }\n        };\n        /**\n         * Handle drag over (highlight the border)\n         * @param event Lumino IDragEvent\n         */\n        this.dragOverHandler = (event) => {\n            // Highlight the border to indicate dragover\n            if (this.doseReceiveDrop) {\n                this.node.classList.add('drag-over');\n            }\n        };\n        /**\n         * Handle drag drop (highlight the border)\n         * @param event Lumino IDragEvent\n         */\n        this.dragDropHandler = (event) => {\n            // Dehighlight the view\n            this.node.classList.remove('drag-over');\n            this.doseReceiveDrop = false;\n            // Query the notebook information\n            const notebook = event.source.parent;\n            let cell;\n            let cellContentType;\n            if (event.source.activeCell instanceof MarkdownCell) {\n                cell = notebook.content.activeCell;\n                cellContentType = ContentType.Markdown;\n            }\n            else {\n                cell = notebook.content.activeCell;\n                cellContentType = ContentType.Code;\n            }\n            // Create a new tab and populate it with the corresponding cell\n            // Swap the dropzone with the new tab\n            this.stickyContent.swapDropzoneWithExistingCell(cell, cellContentType);\n        };\n        /**\n         * Handle drag leave (dehighlight the border)\n         * @param event Lumino IDragEvent\n         */\n        this.dragLeaveHandler = (event) => {\n            // Dehighlight the border to indicate dragover\n            this.node.classList.remove('drag-over');\n        };\n        /**\n         * Implement this function to be consistent with other cell content\n         */\n        this.closeClicked = () => {\n            // pass\n        };\n        /**\n         * Handle mouse click on the create button\n         * @param event Mouse movement event\n         */\n        this.createClickHandler = (event) => {\n            // Query the current value of the cell type dropdown\n            const curOption = this.select.value;\n            switch (curOption) {\n                case ContentType.Code:\n                    this.stickyContent.swapDropzoneWithNewCell(ContentType.Code);\n                    break;\n                case ContentType.Markdown:\n                    this.stickyContent.swapDropzoneWithNewCell(ContentType.Markdown);\n                    break;\n                case ContentType.Dropzone:\n                    // Noop if users do not select a new cell type\n                    break;\n                default:\n                    break;\n            }\n        };\n        this.stickyContent = stickyContent;\n        this.doseReceiveDrop = true;\n        // Add a dropzone element (providing feedback of drag-and-drop)\n        this.node = document.createElement('div');\n        this.node.classList.add('dropzone');\n        this.stickyContent.contentNode.append(this.node);\n        // Initialize the content\n        // Add an icon\n        const addIconElem = document.createElement('div');\n        addIconElem.classList.add('svg-icon');\n        this.node.append(addIconElem);\n        MyIcons.addIcon.element({ container: addIconElem });\n        // Add a text label\n        const label = document.createElement('span');\n        label.classList.add('dropzone-label');\n        label.innerText = 'Drag a cell here or create a new one';\n        this.node.append(label);\n        // Add bottom container\n        const bottomContainer = document.createElement('div');\n        bottomContainer.classList.add('dropzone-bottom-container');\n        this.node.append(bottomContainer);\n        // Add a select option\n        const selectContainer = document.createElement('div');\n        selectContainer.classList.add('dropzone-select-container');\n        bottomContainer.append(selectContainer);\n        this.select = document.createElement('select');\n        this.select.classList.add('dropzone-select');\n        selectContainer.append(this.select);\n        // Add a small caret down icon (from jp)\n        const selectIcon = document.createElement('span');\n        selectContainer.append(selectIcon);\n        MyIcons.caretDownEmptyIcon.element({\n            container: selectIcon\n        });\n        this.selectButton = document.createElement('button');\n        this.selectButton.classList.add('dropzone-button', 'button');\n        bottomContainer.append(this.selectButton);\n        this.selectButton.type = 'button';\n        this.selectButton.innerText = 'Create';\n        this.selectButton.addEventListener('click', this.createClickHandler);\n        // Add options to the select list\n        const newCellOptions = [\n            { name: 'Select new cell type', type: ContentType.Dropzone },\n            { name: 'Code', type: ContentType.Code },\n            { name: 'Markdown', type: ContentType.Markdown }\n        ];\n        newCellOptions.forEach(o => {\n            const option = document.createElement('option');\n            option.value = ContentType[o.type];\n            option.innerText = o.name;\n            this.select.append(option);\n        });\n    }\n    dispose() {\n        this.node.remove();\n        this.isDisposed = true;\n    }\n}\nDropzone.numDz = 0;\n","import { ContentType } from './content';\nimport { MyIcons } from './icons';\nconst WINDOW_GAP = 5;\n/**\n * Class that implements the Code cell in StickyLand.\n */\nexport class FloatingWindow {\n    constructor(cellType, stickyCell) {\n        var _a, _b;\n        this.isDisposed = false;\n        this.lastMousePos = [0, 0];\n        // Properties for FLIP animation\n        this.startPos = null;\n        this.endPos = null;\n        /**\n         * Compute the initial window position + size\n         */\n        this.registerStartPos = () => {\n            const bbox = this.stickyCell.stickyContent.wrapperNode.getBoundingClientRect();\n            const headerHeight = 28;\n            return {\n                x: bbox.x,\n                y: bbox.y - headerHeight,\n                width: bbox.width,\n                height: bbox.height\n            };\n        };\n        /**\n         * Compute the ending floating window position + size\n         */\n        this.registerEndPos = () => {\n            // pass\n            const bbox = this.node.getBoundingClientRect();\n            return {\n                x: bbox.x,\n                y: bbox.y,\n                width: bbox.width,\n                height: bbox.height\n            };\n        };\n        /**\n         * Animate the launching process of the floating window\n         */\n        this.playLaunchingAnimation = () => {\n            if (this.startPos && this.endPos) {\n                // Compute the transformation from end to the start\n                const widthScale = this.startPos.width / this.endPos.width;\n                const heightScale = this.startPos.height / this.endPos.height;\n                const xTranslate = this.startPos.x - this.endPos.x;\n                const yTranslate = this.startPos.y - this.endPos.y;\n                // Apply the transform\n                this.node.animate([\n                    {\n                        transformOrigin: 'top left',\n                        transform: `\n            translate(${xTranslate}px, ${yTranslate}px)\n            scale(${widthScale}, ${heightScale})\n          `\n                    },\n                    {\n                        transformOrigin: 'top left',\n                        transform: 'none'\n                    }\n                ], {\n                    duration: 200,\n                    easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)'\n                });\n            }\n        };\n        /**\n         * Animate the landing process of the floating window\n         */\n        this.playLandingAnimation = (callback) => {\n            if (this.startPos && this.endPos) {\n                this.registerEndPos();\n                // Compute the transformation from start to the end\n                const widthScale = this.startPos.width / this.endPos.width;\n                const heightScale = this.startPos.height / this.endPos.height;\n                const xTranslate = this.startPos.x - this.endPos.x;\n                const yTranslate = this.startPos.y - this.endPos.y;\n                // Apply the transform\n                const animation = this.node.animate([\n                    {\n                        transformOrigin: 'top left',\n                        transform: 'none',\n                        opacity: 1\n                    },\n                    {\n                        transformOrigin: 'top left',\n                        transform: `\n              translate(${xTranslate}px, ${yTranslate}px)\n              scale(${widthScale}, ${heightScale})\n            `,\n                        opacity: 0\n                    }\n                ], {\n                    duration: 350,\n                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)'\n                });\n                animation.onfinish = e => {\n                    callback();\n                };\n            }\n        };\n        /**\n         * Add a place holder in the content node in StickyLand when the cell is floating\n         * @returns Placeholder node\n         */\n        this.addPlaceholder = () => {\n            const placeholder = document.createElement('div');\n            placeholder.classList.add('floating-placeholder');\n            this.stickyCell.stickyContent.wrapperNode.appendChild(placeholder);\n            // Add an icon\n            const addIconElem = document.createElement('div');\n            addIconElem.classList.add('svg-icon');\n            placeholder.append(addIconElem);\n            MyIcons.launchIcon.element({ container: addIconElem });\n            // Add a text label\n            const label = document.createElement('span');\n            label.classList.add('placeholder-label');\n            label.innerText = 'This cell is floating';\n            placeholder.append(label);\n            // Add bottom container\n            const bottomContainer = document.createElement('div');\n            bottomContainer.classList.add('placeholder-bottom-container');\n            placeholder.append(bottomContainer);\n            // Create a button to summon the floating window\n            const button = document.createElement('button');\n            button.classList.add('placeholder-button', 'button');\n            bottomContainer.append(button);\n            button.type = 'button';\n            button.innerText = 'summon';\n            button.addEventListener('click', this.landButtonClicked);\n            return placeholder;\n        };\n        /**\n         * Put the cell back to StickyLand.\n         * @param e Event\n         */\n        this.landButtonClicked = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this.land();\n            const callback = () => {\n                this.dispose();\n            };\n            this.playLandingAnimation(callback);\n        };\n        /**\n         * Land the sticky window and close the corresponding tab\n         * @param e Event\n         */\n        this.closeButtonClicked = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const callback = () => {\n                // First put back the cell\n                this.land();\n                // Close the tab\n                if (this.tab) {\n                    this.stickyTab.closeTab(this.tab);\n                }\n                this.dispose();\n            };\n            // We don't need to play animation if user wants to close the cell\n            callback();\n        };\n        /**\n         * Put back the elements to the StickyLand.\n         */\n        this.land = () => {\n            var _a;\n            // Remove the placeholder\n            this.placeholder.remove();\n            // Put back the elements to stickyland\n            const floatingWrapper = this.node.querySelector('.sticky-content');\n            if (floatingWrapper) {\n                this.stickyCell.stickyContent.wrapperNode.append(...floatingWrapper.childNodes);\n            }\n            // Show the launching icon\n            const launchIcon = (_a = this.stickyCell.stickyContent.headerNode.querySelector('.button-launch')) === null || _a === void 0 ? void 0 : _a.parentElement;\n            launchIcon === null || launchIcon === void 0 ? void 0 : launchIcon.classList.remove('no-display');\n            // Remove the FloatingWindow object from the sticky content\n            const windowIndex = this.stickyCell.stickyContent.stickyLand.floatingWindows.indexOf(this);\n            this.stickyCell.stickyContent.stickyLand.floatingWindows.splice(windowIndex, 1);\n            this.stickyCell.isFloating = false;\n        };\n        /**\n         * Event handler for mouse down. It trigger the document to listen to mouse\n         * move events\n         * @param e Event\n         */\n        this.headerMousedownHandler = (e) => {\n            var _a;\n            e.preventDefault();\n            e.stopPropagation();\n            const mouseEvent = e;\n            // Raise the clicked window\n            (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);\n            // Create a window size mask so that we can override the codemirror cursor\n            const cursorMask = document.createElement('div');\n            cursorMask.classList.add('cursor-mask');\n            cursorMask.style.cursor = 'move';\n            document.body.appendChild(cursorMask);\n            // Also need to mask the internal region\n            const innerCursorMask = document.createElement('div');\n            innerCursorMask.classList.add('cursor-mask');\n            innerCursorMask.style.cursor = 'move';\n            this.node.appendChild(innerCursorMask);\n            // Register the offset from the initial click position to the div location\n            this.lastMousePos = [mouseEvent.pageX, mouseEvent.pageY];\n            const mouseMoveHandler = (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                const mouseEvent = e;\n                let newX = this.node.offsetLeft + mouseEvent.pageX - this.lastMousePos[0];\n                let newY = this.node.offsetTop + mouseEvent.pageY - this.lastMousePos[1];\n                this.lastMousePos[0] = mouseEvent.pageX;\n                this.lastMousePos[1] = mouseEvent.pageY;\n                const nodeBBox = this.node.getBoundingClientRect();\n                // Bound x and y so the window is not out of its container\n                const maxNewX = this.containerSize.width - nodeBBox.width - WINDOW_GAP;\n                newX = Math.max(0, newX);\n                newX = Math.min(maxNewX, newX);\n                const maxNewY = this.containerSize.height - nodeBBox.height - WINDOW_GAP;\n                newY = Math.max(0, newY);\n                newY = Math.min(maxNewY, newY);\n                this.node.style.left = `${newX}px`;\n                this.node.style.top = `${newY}px`;\n                // Also bound the max width and max height to avoid resize overflow\n                if (newX !== maxNewX) {\n                    this.node.style.maxWidth = `${this.containerSize.width - newX - WINDOW_GAP}px`;\n                }\n                if (newY !== maxNewY) {\n                    this.node.style.maxHeight = `${this.containerSize.height - newY - WINDOW_GAP}px`;\n                }\n            };\n            const mouseUpHandler = () => {\n                document.removeEventListener('mousemove', mouseMoveHandler, true);\n                document.removeEventListener('mouseup', mouseUpHandler, true);\n                document.body.style.cursor = 'default';\n                cursorMask.remove();\n                innerCursorMask.remove();\n            };\n            // Bind the mouse event listener to the document so we can track the movement\n            // if outside the header region\n            document.addEventListener('mousemove', mouseMoveHandler, true);\n            document.addEventListener('mouseup', mouseUpHandler, true);\n            document.body.style.cursor = 'move';\n        };\n        // Create the floating window element\n        this.node = document.createElement('div');\n        this.node.classList.add('floating-window', 'hidden');\n        // Append the floating window to different elements for notebook/lab\n        if (document.querySelector('#jp-main-content-panel') !== null) {\n            this.container = document.querySelector('#jp-main-content-panel');\n        }\n        else {\n            this.container = document.querySelector('#main-panel');\n        }\n        (_a = this.container) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);\n        if (this.container === null) {\n            console.warn('StickyLand: Cannot find container to inject the floating cell!');\n        }\n        // Set max size to bound the floating window\n        this.containerSize = {\n            width: 2000,\n            height: 1500\n        };\n        if (this.container !== null) {\n            const containerBBox = this.container.getBoundingClientRect();\n            this.containerSize.width = containerBBox.width;\n            this.containerSize.height = containerBBox.height;\n        }\n        // Add a top header to the window\n        this.header = document.createElement('div');\n        this.header.classList.add('floating-header');\n        this.node.appendChild(this.header);\n        const headerText = document.createElement('span');\n        this.cellType = cellType;\n        this.stickyCell = stickyCell;\n        this.stickyTab = this.stickyCell.stickyContent.stickyLand.stickyTab;\n        this.tab = this.stickyTab.activeTab;\n        this.stickyLand = this.stickyCell.stickyContent.stickyLand;\n        // We first put the cell on the left edge of the notebook panel\n        const initLeft = this.stickyCell.notebook.node.getBoundingClientRect().x + 10;\n        // Position the node to the inner region and offset it a little bit when\n        // users create multiple windows\n        const curLeft = initLeft + this.stickyLand.floatingWindows.length * 20;\n        const curTop = 100 + this.stickyLand.floatingWindows.length * 20;\n        this.node.style.left = `${curLeft}px`;\n        this.node.style.top = `${curTop}px`;\n        this.node.style.maxWidth = `${this.containerSize.width - curLeft - WINDOW_GAP}px`;\n        this.node.style.maxHeight = `${this.containerSize.height - curTop - WINDOW_GAP}px`;\n        // Query the cell index for this cell\n        let cellIndex = 1;\n        if (this.stickyTab.activeTab) {\n            cellIndex = this.stickyTab.activeTab.cellIndex;\n        }\n        if (cellType === ContentType.Code) {\n            headerText.innerText = `Code-${cellIndex}`;\n        }\n        else {\n            headerText.innerText = `Markdown-${cellIndex}`;\n        }\n        this.header.appendChild(headerText);\n        // Add two buttons to the header\n        const headerIcons = document.createElement('div');\n        headerIcons.classList.add('button-group');\n        this.header.appendChild(headerIcons);\n        const icon1 = document.createElement('div');\n        icon1.classList.add('header-button');\n        icon1.setAttribute('title', 'Put pack the cell to StickyLand');\n        MyIcons.landIcon.element({ container: icon1 });\n        headerIcons.appendChild(icon1);\n        const icon2 = document.createElement('div');\n        icon2.classList.add('header-button');\n        icon2.setAttribute('title', 'Close the cell');\n        MyIcons.closeIcon2.element({ container: icon2 });\n        headerIcons.appendChild(icon2);\n        // Bind event handlers for those two buttons\n        icon1.addEventListener('click', this.landButtonClicked);\n        icon2.addEventListener('click', this.closeButtonClicked);\n        // Need to cancel mousedown event to avoid header dragging\n        icon1.addEventListener('mousedown', e => {\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        icon2.addEventListener('mousedown', e => {\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        // Allow users to drag the window to change the position\n        this.header.addEventListener('mousedown', this.headerMousedownHandler);\n        // Push itself to the floating window array\n        this.stickyLand.floatingWindows.push(this);\n        // Hide the launching icon\n        const launchIcon = (_b = this.stickyCell.stickyContent.headerNode.querySelector('.button-launch')) === null || _b === void 0 ? void 0 : _b.parentElement;\n        launchIcon === null || launchIcon === void 0 ? void 0 : launchIcon.classList.add('no-display');\n        // Register the start position\n        this.startPos = this.registerStartPos();\n        // Add the content from the cell to the floating window\n        const floatingContent = this.stickyCell.stickyContent.wrapperNode.cloneNode(false);\n        floatingContent.append(...this.stickyCell.stickyContent.wrapperNode.childNodes);\n        this.node.append(floatingContent);\n        // Set the initial width to fit the codemirror default width\n        const cmSizer = this.node.querySelector('.CodeMirror-sizer');\n        if (cmSizer !== null) {\n            this.node.style.width = `${parseInt(cmSizer.style.minWidth) + 20}px`;\n        }\n        // Register the end position\n        this.endPos = this.registerEndPos();\n        // Override the auto height from code mirror\n        this.node.style.height = `${this.endPos.height}px`;\n        // Play the animation\n        this.node.classList.remove('hidden');\n        this.playLaunchingAnimation();\n        // Add a placeholder in the original sticky content\n        this.placeholder = this.addPlaceholder();\n    }\n    dispose() {\n        this.header.removeEventListener('mousedown', this.headerMousedownHandler);\n        this.node.remove();\n        this.isDisposed = true;\n    }\n}\n","import { LabIcon, runIcon, editIcon, ellipsesIcon, caretDownEmptyIcon, closeIcon, addIcon } from '@jupyterlab/ui-components';\nimport iconAdd from '../style/img/icon-add.svg';\nimport iconCollapse from '../style/img/icon-collapse.svg';\nimport iconLaunch from '../style/img/icon-launch.svg';\nimport iconLand from '../style/img/icon-land.svg';\nimport iconExpand from '../style/img/icon-expand.svg';\nimport iconClose2 from '../style/img/icon-close2.svg';\nimport iconChevron from '../style/img/icon-chevron.svg';\nimport iconDrag from '../style/img/icon-drag.svg';\nimport iconTabClose from '../style/img/icon-tabclose.svg';\nexport class MyIcons {\n}\nMyIcons.runIcon = runIcon;\nMyIcons.editIcon = editIcon;\nMyIcons.ellipsesIcon = ellipsesIcon;\nMyIcons.closeIcon = closeIcon;\nMyIcons.caretDownEmptyIcon = caretDownEmptyIcon;\nMyIcons.addIcon2 = addIcon;\nMyIcons.addIcon = new LabIcon({\n    name: 'icon-add',\n    svgstr: iconAdd\n});\nMyIcons.collapseIcon = new LabIcon({\n    name: 'icon-collapse',\n    svgstr: iconCollapse\n});\nMyIcons.launchIcon = new LabIcon({\n    name: 'icon-launch',\n    svgstr: iconLaunch\n});\nMyIcons.landIcon = new LabIcon({\n    name: 'icon-land',\n    svgstr: iconLand\n});\nMyIcons.closeIcon2 = new LabIcon({\n    name: 'icon-close2',\n    svgstr: iconClose2\n});\nMyIcons.expandIcon = new LabIcon({\n    name: 'icon-expand',\n    svgstr: iconExpand\n});\nMyIcons.chevronIcon = new LabIcon({\n    name: 'icon-chevron',\n    svgstr: iconChevron\n});\nMyIcons.dragIcon = new LabIcon({\n    name: 'icon-drag',\n    svgstr: iconDrag\n});\nMyIcons.tabCloseIcon = new LabIcon({\n    name: 'icon-tabClose',\n    svgstr: iconTabClose\n});\n","import { ICommandPalette } from '@jupyterlab/apputils';\nimport { ButtonExtension } from './button';\nconst plugin = {\n    id: 'jupyterlab_stickyland',\n    autoStart: true,\n    requires: [ICommandPalette],\n    activate: function (app) {\n        console.log('Activating StickyLand.');\n        app.docRegistry.addWidgetExtension('Notebook', new ButtonExtension());\n    }\n};\nexport default plugin;\n","import { NotebookActions } from '@jupyterlab/notebook';\nimport { FloatingWindow } from './floating';\nimport { ContentType } from './content';\nimport { MyIcons } from './icons';\n/**\n * Class that implements the Markdown cell in StickyLand.\n */\nexport class StickyMarkdown {\n    constructor() {\n        this.isDisposed = false;\n        this.isFloating = false;\n        /**\n         * Strip unnecessary elements from the nodes before appending it to stickyland\n         */\n        this.cleanCellClone = () => {\n            var _a, _b, _c, _d, _e;\n            // Remove the left region (prompt and collapser), header and footer\n            (_a = this.cellNode.querySelector('.jp-Cell-inputCollapser')) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = this.cellNode.querySelector('.jp-InputArea-prompt')) === null || _b === void 0 ? void 0 : _b.remove();\n            (_c = this.cellNode.querySelector('.jp-CellHeader')) === null || _c === void 0 ? void 0 : _c.remove();\n            (_d = this.cellNode.querySelector('.jp-CellFooter')) === null || _d === void 0 ? void 0 : _d.remove();\n            // Add class name to the rendered region\n            (_e = this.cellNode\n                .querySelector('.jp-MarkdownOutput')) === null || _e === void 0 ? void 0 : _e.classList.add('sticky-md-output');\n            this.cellNode.classList.add('sticky-md-cell');\n            this.cellNode.classList.remove('hidden');\n            // Render the latex on the clone node\n            this.renderLatex();\n        };\n        /**\n         * Bind event handlers for sticky markdown cell.\n         */\n        this.bindEventHandlers = () => {\n            // Double click the rendered view should trigger editor\n            this.node.addEventListener('dblclick', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                if (this.cell.rendered) {\n                    this.enterEditor();\n                }\n            });\n            // Click on the rendered view should focus the current element\n            this.node.addEventListener('click', (e) => {\n                if (this.cell.rendered) {\n                    this.node.focus();\n                }\n            });\n            // Bind keyboard short cuts\n            this.node.addEventListener('keydown', (e) => {\n                if (e.key === 'Enter') {\n                    if (e.shiftKey || e.ctrlKey) {\n                        // [Shift + enter] or [control + enter] render the markdown cell\n                        if (!this.cell.rendered) {\n                            this.quitEditor();\n                        }\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                    else {\n                        // [Enter] in rendered mode triggers the editor\n                        if (this.cell.rendered) {\n                            this.enterEditor();\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                    }\n                }\n            });\n        };\n        /**\n         * Create a toolbar element\n         * @param items List of toolbar item names and onclick handlers\n         */\n        this.createToolbar = (items) => {\n            const toolbar = document.createElement('div');\n            toolbar.classList.add('sticky-toolbar', 'jp-Toolbar');\n            // Add buttons into the toolbar\n            items.forEach(d => {\n                const item = document.createElement('div');\n                item.classList.add('jp-ToolbarButton', 'jp-Toolbar-item');\n                toolbar.appendChild(item);\n                const itemElem = document.createElement('button');\n                itemElem.classList.add('jp-ToolbarButtonComponent', 'button', 'jp-Button', 'toolbar-button', 'bp3-button', 'bp3-minimal', `button-${d.name}`);\n                itemElem.setAttribute('title', d.title);\n                itemElem.addEventListener('click', d.onClick);\n                item.appendChild(itemElem);\n                // Add icon to the button\n                const iconSpan = document.createElement('span');\n                iconSpan.classList.add('jp-ToolbarButtonComponent-icon');\n                itemElem.appendChild(iconSpan);\n                d.icon.element({\n                    container: iconSpan\n                });\n            });\n            return toolbar;\n        };\n        /**\n         * Helper function to enter the editor mode.\n         */\n        this.enterEditor = () => {\n            // Trigger the editor\n            this.cell.rendered = false;\n            // Move the cursor on the first line before the first character\n            this.cell.editor.focus();\n            this.cell.editor.setCursorPosition({ line: 0, column: 0 });\n        };\n        /**\n         * Helper function to quit the editor mode.\n         */\n        this.quitEditor = () => {\n            // Trigger the rendered output\n            this.cell.rendered = true;\n            // Focus the cell node so we can listen to keyboard events\n            this.node.focus();\n            /**\n             * Since we are not attaching the renderer widget to any other widget, the\n             * onAttach method is never called, so the latex typesetter is never called\n             * We need to manually call it after rendering the node\n             */\n            this.renderLatex();\n        };\n        /**\n         * A helper function to force render latex after timeout.\n         * @param timeout Call the latex renderer after `timeout` ms\n         */\n        this.renderLatex = (timeout = 100) => {\n            /**\n             * Since we are not attaching the renderer widget to any other widget, the\n             * onAttach method is never called, so the latex typesetter is never called\n             * We need to manually call it after rendering the node\n             * https://github.com/jupyterlab/jupyterlab/blob/d48e0c04efb786561137fb20773fc15788507f0a/packages/rendermime/src/widgets.ts#L225\n             */\n            setTimeout(() => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                (_a = this.renderer.latexTypesetter) === null || _a === void 0 ? void 0 : _a.typeset(this.renderer.node);\n            }, timeout);\n        };\n        /**\n         * Float the current code cell.\n         */\n        this.float = () => {\n            // Create the floating window and put content from stickyland to the floating\n            // window\n            this.floatingWindow = new FloatingWindow(ContentType.Markdown, this);\n            // Finally, toggle the `isFloating` property\n            this.isFloating = true;\n        };\n        this.editClicked = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Show the editing area\n            if (this.cell.rendered) {\n                this.enterEditor();\n            }\n        };\n        this.runClicked = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Render the markdown\n            if (!this.cell.rendered) {\n                this.quitEditor();\n            }\n        };\n        this.launchClicked = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            this.float();\n        };\n        this.closeClicked = () => {\n            // Show the original cell\n            this.originalCell.inputHidden = false;\n            // TEMP: replace the current content with the dropzone\n            this.stickyContent.showDropzone();\n            // Remove the code cell\n            this.dispose();\n        };\n        this.toolBarItems = [\n            {\n                name: 'run',\n                title: 'Run the cell',\n                icon: MyIcons.runIcon,\n                onClick: this.runClicked\n            },\n            {\n                name: 'edit',\n                title: 'Edit the cell',\n                icon: MyIcons.editIcon,\n                onClick: this.editClicked\n            },\n            {\n                name: 'launch',\n                title: 'Make the cell float',\n                icon: MyIcons.launchIcon,\n                onClick: this.launchClicked\n            }\n        ];\n    }\n    /**\n     * Factory function for StickyMarkdown when creating if from an existing cell\n     * through dragging\n     * @param stickyContent The sticky content that contains this markdown cell\n     * @param cell The existing markdown cell\n     * @param notebook The current notebook\n     * @returns A new StickyMarkdown object\n     */\n    static createFromExistingCell(stickyContent, cell, notebook) {\n        const md = new StickyMarkdown();\n        md.stickyContent = stickyContent;\n        md.notebook = notebook;\n        // Clone the cell\n        md.originalCell = cell;\n        md.cell = md.originalCell.clone();\n        // Collapse the original cell\n        if (!md.originalCell.inputHidden) {\n            md.originalCell.inputHidden = true;\n        }\n        // Save a reference to the cell's renderer (private)\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        md.renderer = md.cell._renderer;\n        // Add a markdown cell element\n        md.node = document.createElement('div');\n        md.node.classList.add('sticky-md');\n        // Need to add tabindex so it can receive keyboard events\n        md.node.setAttribute('tabindex', '0');\n        md.stickyContent.contentNode.appendChild(md.node);\n        // Add a toolbar\n        md.toolbar = md.createToolbar(md.toolBarItems);\n        md.stickyContent.headerNode.appendChild(md.toolbar);\n        // Clean the markdown cell\n        // Need to append the node to DOM first so we can do the cleaning\n        md.cellNode = md.cell.node;\n        md.cellNode.classList.add('hidden');\n        md.node.appendChild(md.cellNode);\n        // Bind the Codemirror\n        const codeMirrorNode = md.cell.node.querySelector('.CodeMirror');\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        md.codemirror = codeMirrorNode.CodeMirror;\n        // Bind events\n        md.bindEventHandlers();\n        // Clean the unnecessary elements from the node clone\n        md.cleanCellClone();\n        return md;\n    }\n    /**\n     * Factory function for StickyMarkdown when creating if from a new markdown\n     * cell. This function would append a new markdown cell to the main notebook.\n     * @param stickyContent The sticky content that contains this markdown cell\n     * @param notebook The current notebook\n     * @returns A new StickyMarkdown object\n     */\n    static createFromNewCell(stickyContent, notebook) {\n        // Append a new markdown cell to the main notebook\n        NotebookActions.insertBelow(notebook.content);\n        NotebookActions.changeCellType(notebook.content, 'markdown');\n        const newCell = notebook.content.activeCell;\n        // Activate the original active cell\n        notebook.content.activeCellIndex = notebook.content.activeCellIndex - 1;\n        // Construct StickyMarkdown using the new cell as an existing cell\n        return this.createFromExistingCell(stickyContent, newCell, notebook);\n    }\n    dispose() {\n        this.node.remove();\n        this.toolbar.remove();\n        this.isDisposed = true;\n    }\n}\n","import { StickyTab } from './tab';\nimport { MyIcons } from './icons';\nconst MIN_WIDTH = 235;\nconst MIN_HEIGHT = 240;\nexport class StickyLand {\n    constructor(panel) {\n        this.stickyContent = null;\n        this.floatingWindows = [];\n        /**\n         * Allow users to drag the bottom left corner to resize the container\n         */\n        this.enableResize = () => {\n            const resizeHandle = document.createElement('div');\n            resizeHandle.classList.add('resize-handle');\n            // Draw a few liens to signify the resize affordance\n            const line1 = document.createElement('div');\n            line1.classList.add('line', 'line-1');\n            resizeHandle.appendChild(line1);\n            const line2 = document.createElement('div');\n            line2.classList.add('line', 'line-2');\n            resizeHandle.appendChild(line2);\n            const line3 = document.createElement('div');\n            line3.classList.add('line', 'line-3');\n            resizeHandle.appendChild(line3);\n            this.node.append(resizeHandle);\n            resizeHandle.addEventListener('mousedown', this.resizeMousedownHandler);\n        };\n        /**\n         * Handle the dragging on the resize handle on the bottom left corner\n         * @param e Mouse event\n         */\n        this.resizeMousedownHandler = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const bbox = this.node.getBoundingClientRect();\n            const rightX = bbox.x + bbox.width;\n            const topY = bbox.y;\n            // Create a window size mask so that we can override the codemirror cursor\n            const cursorMask = document.createElement('div');\n            cursorMask.classList.add('cursor-mask');\n            cursorMask.style.cursor = 'nesw-resize';\n            document.body.appendChild(cursorMask);\n            const mouseMoveHandler = (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                const mouseEvent = e;\n                const newX = mouseEvent.pageX;\n                const newWidth = Math.max(MIN_WIDTH, rightX - newX);\n                const newY = mouseEvent.pageY;\n                const newHeight = Math.max(MIN_HEIGHT, newY - topY);\n                this.node.style.width = `${newWidth}px`;\n                this.node.style.height = `${newHeight}px`;\n            };\n            const mouseUpHandler = () => {\n                document.removeEventListener('mousemove', mouseMoveHandler, true);\n                document.removeEventListener('mouseup', mouseUpHandler, true);\n                document.body.style.cursor = 'default';\n                cursorMask.remove();\n            };\n            // Bind the mouse event listener to the document so we can track the movement\n            // if outside the header region\n            document.addEventListener('mousemove', mouseMoveHandler, true);\n            document.addEventListener('mouseup', mouseUpHandler, true);\n            document.body.style.cursor = 'newsw-resize';\n        };\n        /**\n         * Style the header so that users can reposition StickyLand.\n         */\n        this.initHeader = () => {\n            // Add the drag icon\n            const dragHandle = document.createElement('div');\n            dragHandle.classList.add('drag-handle');\n            this.header.appendChild(dragHandle);\n            MyIcons.dragIcon.element({ container: dragHandle });\n            // Allow the user to drag the header to change the vertical position of\n            // stickyland\n            this.header.addEventListener('mousedown', this.headerMousedownHandler);\n        };\n        this.headerMousedownHandler = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const mouseEvent = e;\n            const yOffset = this.node.offsetTop - mouseEvent.pageY;\n            // Create a window size mask so that we can override the codemirror cursor\n            const cursorMask = document.createElement('div');\n            cursorMask.classList.add('cursor-mask');\n            cursorMask.style.cursor = 'move';\n            document.body.appendChild(cursorMask);\n            const mouseMoveHandler = (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                const mouseEvent = e;\n                const newTop = mouseEvent.pageY + yOffset;\n                this.node.style.top = `${newTop}px`;\n            };\n            const mouseUpHandler = () => {\n                document.removeEventListener('mousemove', mouseMoveHandler, true);\n                document.removeEventListener('mouseup', mouseUpHandler, true);\n                document.body.style.cursor = 'default';\n                cursorMask.remove();\n            };\n            // Bind the mouse event listener to the document so we can track the movement\n            // if outside the header region\n            document.addEventListener('mousemove', mouseMoveHandler, true);\n            document.addEventListener('mouseup', mouseUpHandler, true);\n            document.body.style.cursor = 'move';\n        };\n        this.isHidden = () => {\n            return this.node.classList.contains('hidden');\n        };\n        this.hide = () => {\n            this.node.classList.add('hidden');\n            // Also hide all floating windows\n            this.floatingWindows.forEach(d => {\n                d.node.classList.add('hidden');\n            });\n        };\n        this.show = () => {\n            this.node.classList.remove('hidden');\n            // Also show all floating windows\n            this.floatingWindows.forEach(d => {\n                d.node.classList.remove('hidden');\n            });\n        };\n        /**\n         * Handle drag drop event\n         *\n         * ### Note\n         * https://jupyterlab.github.io/lumino/dragdrop/interfaces/idragevent.html\n         * We need to call preventDefault() to cancel (dispose) the event to have our\n         * own action\n         *\n         * @param event Lumino IDragEVent\n         */\n        this.dragDropHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Let the content handle drag drop\n            if (this.stickyContent) {\n                this.stickyContent.dragDropHandler(event);\n            }\n        };\n        /**\n         * Handle drag enter event\n         *\n         * ### Note\n         * https://jupyterlab.github.io/lumino/dragdrop/interfaces/idragevent.html\n         * We need to call preventDefault() to cancel (dispose) the event to have our\n         * own action\n         *\n         * @param event Lumino IDragEVent\n         */\n        this.dragEnterHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Change the view of content\n            if (this.stickyContent) {\n                this.stickyContent.dragEnterHandler(event);\n            }\n        };\n        /**\n         * Handle drag over events\n         *\n         * ### Note\n         * https://jupyterlab.github.io/lumino/dragdrop/interfaces/idragevent.html\n         * We need to call preventDefault() to cancel (dispose) the event to have our\n         * own action\n         *\n         * @param event Lumino IDragEVent\n         */\n        this.dragOverHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Changer the cursor style (only way to change cursor style here)\n            // Lumino's drag's dispatch checks the `dropAction` field to call\n            // overrideCursor() internally\n            // https://jupyterlab.github.io/lumino/dragdrop/interfaces/idragevent.html\n            // https://github.com/jupyterlab/lumino/blob/e6612f622c827b2e85cffb1858fcc3bf1b09be76/packages/dragdrop/src/index.ts#L474\n            event.dropAction = 'copy';\n            // Change the view of content\n            if (this.stickyContent) {\n                this.stickyContent.dragOverHandler(event);\n            }\n        };\n        /**\n         * Handle drag leave event\n         *\n         * ### Note\n         * https://jupyterlab.github.io/lumino/dragdrop/interfaces/idragevent.html\n         * We need to call preventDefault() to cancel (dispose) the event to have our\n         * own action\n         *\n         * @param event Lumino IDragEVent\n         */\n        this.dragLeaveHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            // Change the view of content\n            if (this.stickyContent) {\n                this.stickyContent.dragLeaveHandler(event);\n            }\n        };\n        this.node = document.createElement('div');\n        this.node.classList.add('sticky-container', 'hidden');\n        // Put stickyland below the toolbar\n        const toolbarHeight = parseFloat(panel.toolbar.node.style.height);\n        this.node.style.top = `${toolbarHeight + 30}px`;\n        panel.node.appendChild(this.node);\n        // Create a header so that users can drag\n        this.header = document.createElement('div');\n        this.header.classList.add('sticky-header');\n        this.node.appendChild(this.header);\n        this.initHeader();\n        // Add the tab element\n        this.stickyTab = new StickyTab(this.node, panel, this);\n        // Allow users to drag to resize\n        this.enableResize();\n        // Register the drag-and-drop events\n        this.node.addEventListener('lm-drop', e => this.dragDropHandler(e), true);\n        this.node.addEventListener('lm-dragenter', e => this.dragEnterHandler(e), true);\n        this.node.addEventListener('lm-dragover', e => this.dragOverHandler(e), true);\n        this.node.addEventListener('lm-dragleave', e => this.dragLeaveHandler(e), true);\n    }\n}\n","import { NotebookActions } from '@jupyterlab/notebook';\nimport { StickyContent } from './content';\nimport { StickyMarkdown } from './markdown';\nimport { StickyCode } from './code';\nimport { ContentType } from './content';\nimport { MyIcons } from './icons';\nexport class StickyTab {\n    constructor(stickyContainer, panel, stickyLand) {\n        this.activeTab = null;\n        this.tabs = [];\n        this.autoRunTimeout = null;\n        this.autoRunningCellNodes = new Set([]);\n        this.autoRunCells = new Array();\n        this.autoRunTabs = new Array();\n        this.isDisposed = false;\n        /**\n         * Handle the executionScheduled signal.\n         */\n        this.handleExecutionScheduled = (_, args) => {\n            if (this.autoRunningCellNodes.size !== 0) {\n                return;\n            }\n            // Get all the code cells that have auto-run turned on\n            const autoRunCells = new Array();\n            const autoRunTabs = new Array();\n            this.tabs.forEach(d => {\n                if (d.cellType === ContentType.Code) {\n                    const curContent = d.tabContent.curContent;\n                    if (curContent.autoRun) {\n                        autoRunCells.push(curContent);\n                        autoRunTabs.push(d);\n                    }\n                }\n            });\n            // We need to set a timeout to workaround the current executionScheduled\n            // emit order\n            // https://github.com/jupyterlab/jupyterlab/pull/11453\n            // Also users might run multiple cells at one time, we can set a short\n            // timeout so that we only run the sticky code cell once in a series of\n            // other executions of other cells\n            if (this.autoRunTimeout !== null) {\n                clearTimeout(this.autoRunTimeout);\n            }\n            this.autoRunTimeout = setTimeout(() => {\n                // Run the auto-run code cells\n                const toRunCells = new Array();\n                autoRunCells.forEach(d => {\n                    // If the signal source is the cell itself, we mark it as autoRunScheduled\n                    // so we won't run it again after its peers finish running\n                    if (d.originalCell.node === args.cell.node) {\n                        d.autoRunScheduled = true;\n                    }\n                    else {\n                        if (!d.autoRunScheduled) {\n                            d.autoRunScheduled = true;\n                            // d.execute returns a promise but the promise can be fulfilled before\n                            // the cell is executed, so we manually keep a record of all running\n                            // cells and resolve them manually\n                            toRunCells.push(d);\n                            this.autoRunningCellNodes.add(d.originalCell.node);\n                        }\n                    }\n                });\n                toRunCells.forEach(d => d.execute(true));\n                // Move the local autoRunCells/autoRunTabs to object level\n                this.autoRunCells = autoRunCells;\n                this.autoRunTabs = autoRunTabs;\n            }, 200);\n        };\n        /**\n         * Handle the executed signal.\n         */\n        this.handleExecuted = (_, args) => {\n            // Check if the cell that just finishes running is scheduled by us\n            if (this.autoRunningCellNodes.has(args.cell.node)) {\n                // Remove watching this cell\n                this.autoRunningCellNodes.delete(args.cell.node);\n                // If all auto-running cells finish running, we allow all these cells to\n                // be auto-run again in the future\n                if (this.autoRunningCellNodes.size === 0) {\n                    this.autoRunCells.forEach(d => {\n                        d.autoRunScheduled = false;\n                    });\n                    // Also mark the tab to indicate there is new update in this tab\n                    this.autoRunTabs.forEach(d => {\n                        // const curCell = d.tabContent.curContent as StickyCode;\n                        if (!d.tabNode.classList.contains('current')) {\n                            d.tabNode.classList.add('new-update');\n                        }\n                    });\n                    this.autoRunCells = [];\n                    this.autoRunTabs = [];\n                }\n            }\n        };\n        /**\n         * Create a tab containing a dropzone content. The tab name is always 'new'\n         * for new tabs. Creating a different content (after interacting with the\n         * dropzone will update the tab name).\n         * @returns New tab\n         */\n        this.createTab = () => {\n            // Create a new tab node\n            const tabNode = document.createElement('button');\n            tabNode.classList.add('tab', 'new-tab');\n            tabNode.setAttribute('title', 'New tab');\n            // Add a label to the button\n            const tabLabel = document.createElement('span');\n            tabLabel.classList.add('tab-label');\n            tabNode.appendChild(tabLabel);\n            // Add a delete icon\n            const tabIcon = document.createElement('div');\n            tabIcon.classList.add('tab-icon');\n            MyIcons.tabCloseIcon.element({ container: tabIcon });\n            tabNode.appendChild(tabIcon);\n            // New tab always has the dropzone content\n            tabLabel.innerHTML = 'New';\n            const tabContent = new StickyContent(this.stickyContainer, this.notebook, this.stickyLand);\n            // Add this tab to the model and view\n            const newTab = {\n                cellType: ContentType.Dropzone,\n                cellIndex: 0,\n                tabNode: tabNode,\n                tabContent: tabContent,\n                hasNewUpdate: false\n            };\n            // Handle delete icon clicked\n            tabIcon.addEventListener('click', (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                this.closeTab(newTab);\n            });\n            this.tabs.push(newTab);\n            this.node.insertBefore(newTab.tabNode, this.addButton);\n            // Handle tab clicked\n            tabNode.addEventListener('click', (e) => {\n                var _a;\n                e.preventDefault();\n                e.stopPropagation();\n                // Switch the active tab to the current one\n                if (((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.tabNode) !== tabNode) {\n                    this.switchActiveTab(newTab);\n                    // Remove the new update if it's there\n                    newTab.tabNode.classList.remove('new-update');\n                }\n            });\n            // Move the current active tab to this new one\n            this.switchActiveTab(newTab);\n            // Return this tab\n            return newTab;\n        };\n        /**\n         * Close the given tab\n         * @param tab Tab to close\n         */\n        this.closeTab = (tab) => {\n            // Case 1: this tab is the only tab\n            if (this.tabs.length === 1) {\n                // Swap the content to dropzone\n                tab.tabContent.swapToDropzone();\n                // Update the tab name\n                this.updateActiveTab();\n            }\n            else {\n                // Case 2: if there are other tabs\n                // First swap the content to dropzone\n                tab.tabContent.swapToDropzone();\n                // Then remove the content\n                tab.tabContent.dispose();\n                // Prepare to remove the tab\n                const tabIndex = this.tabs.indexOf(tab);\n                // Change the active tab to the one on the left or on the right if there\n                // is no tab on the left\n                if (tabIndex !== 0) {\n                    this.switchActiveTab(this.tabs[tabIndex - 1]);\n                }\n                else {\n                    this.switchActiveTab(this.tabs[tabIndex + 1]);\n                }\n                // Remove the tab from model\n                this.tabs.splice(tabIndex, 1);\n                // Remove the tab from the DOM\n                tab.tabNode.remove();\n            }\n        };\n        /**\n         * Change the currently active tab to the new tab\n         */\n        this.switchActiveTab = (newTab) => {\n            if (this.activeTab) {\n                // Hide the old active tab's content\n                this.activeTab.tabContent.wrapperNode.classList.add('no-display');\n                this.activeTab.tabNode.classList.remove('current');\n            }\n            this.activeTab = newTab;\n            newTab.tabNode.classList.add('current');\n            newTab.tabContent.wrapperNode.classList.remove('no-display');\n            this.stickyLand.stickyContent = newTab.tabContent;\n        };\n        /**\n         * Update the tab name for the active tab. This function is called when user\n         * creates a new code/md cell.\n         */\n        this.updateActiveTab = () => {\n            var _a;\n            if (this.activeTab) {\n                const newContent = (_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.tabContent.curContent;\n                // Find the new content type\n                let newCellType = ContentType.Dropzone;\n                if (newContent instanceof StickyCode) {\n                    newCellType = ContentType.Code;\n                }\n                else if (newContent instanceof StickyMarkdown) {\n                    newCellType = ContentType.Markdown;\n                }\n                // Find the new cell index\n                let newCellIndex = 1;\n                this.tabs.forEach(d => {\n                    if (d.cellType === newCellType) {\n                        newCellIndex++;\n                    }\n                });\n                // Update the tab name\n                const tabLabel = this.activeTab.tabNode.querySelector('.tab-label');\n                if (tabLabel) {\n                    switch (newCellType) {\n                        case ContentType.Code:\n                            tabLabel.innerHTML = `Code-${newCellIndex}`;\n                            this.activeTab.tabNode.setAttribute('title', `Code-${newCellIndex}`);\n                            this.activeTab.tabNode.classList.remove('new-tab');\n                            break;\n                        case ContentType.Markdown:\n                            tabLabel.innerHTML = `Markdown-${newCellIndex}`;\n                            this.activeTab.tabNode.setAttribute('title', `Markdown-${newCellIndex}`);\n                            this.activeTab.tabNode.classList.remove('new-tab');\n                            break;\n                        case ContentType.Dropzone:\n                            tabLabel.innerHTML = 'New';\n                            this.activeTab.tabNode.setAttribute('title', 'New tab');\n                            this.activeTab.tabNode.classList.add('new-tab');\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                // Update the model data\n                this.activeTab.cellIndex = newCellIndex;\n                this.activeTab.cellType = newCellType;\n            }\n        };\n        this.dispose = () => {\n            this.isDisposed = true;\n            NotebookActions.executionScheduled.disconnect(this.handleExecutionScheduled, this);\n            NotebookActions.executed.disconnect(this.handleExecuted, this);\n        };\n        this.stickyContainer = stickyContainer;\n        this.stickyLand = stickyLand;\n        this.notebook = panel;\n        // Add the tab element\n        this.node = document.createElement('div');\n        this.node.classList.add('sticky-tab', 'sticky-tab-bar');\n        this.stickyContainer.append(this.node);\n        // Add new cell button\n        this.addButton = document.createElement('button');\n        this.addButton.classList.add('add-tab');\n        this.node.appendChild(this.addButton);\n        MyIcons.addIcon2.element({ container: this.addButton });\n        this.addButton.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            // Create a new tab and switch the active tab\n            this.createTab();\n        });\n        // Create the first tab\n        this.createTab();\n        /**\n         * Listen to the notebook execution events so we can auto-run the code cell\n         * We need to register the listener at the tab level because there can be\n         * multiple code cells with auto-run turned on. If each triggers its own\n         * listener then there will be a race and infinite auto-runs.\n         */\n        NotebookActions.executionScheduled.connect(this.handleExecutionScheduled, this);\n        NotebookActions.executed.connect(this.handleExecuted, this);\n    }\n}\n","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><title>Add Circle</title><path d=\\\"M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm96 224h-80v80h-32v-80h-80v-32h80v-80h32v80h80z\\\"/></svg>\";","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><path fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"48\\\" d=\\\"M184 112l144 144-144 144\\\"/></svg>\";","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><path d=\\\"M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z\\\"/></svg>\";","export default \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\r\\n<!-- Generator: Adobe Illustrator 24.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\\r\\n<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\r\\n\\t viewBox=\\\"0 0 512 512\\\" style=\\\"enable-background:new 0 0 512 512;\\\" xml:space=\\\"preserve\\\">\\r\\n<style type=\\\"text/css\\\">\\r\\n\\t.st0{fill-rule:evenodd;clip-rule:evenodd;}\\r\\n</style>\\r\\n<g>\\r\\n\\t<path class=\\\"st0\\\" d=\\\"M36.6,256c0-10.1,8.2-18.3,18.3-18.3h402.3c10.1,0,18.3,8.2,18.3,18.3s-8.2,18.3-18.3,18.3H54.9\\r\\n\\t\\tC44.8,274.3,36.6,266.1,36.6,256z M256,0c10.1,0,18.3,8.2,18.3,18.3v164.6c0,10.1-8.2,18.3-18.3,18.3s-18.3-8.2-18.3-18.3V18.3\\r\\n\\t\\tC237.7,8.2,245.9,0,256,0z\\\"/>\\r\\n\\t<path class=\\\"st0\\\" d=\\\"M342.1,96.8c7.1,7.1,7.2,18.7,0,25.9l0,0L269,195.8c-7.1,7.1-18.7,7.2-25.9,0l0,0l-73.1-73.1\\r\\n\\t\\tc-7.1-7.2-7.1-18.7,0-25.9c7.2-7.1,18.7-7.1,25.9,0L256,157l60.2-60.2C323.3,89.6,334.9,89.6,342.1,96.8L342.1,96.8z M256,512\\r\\n\\t\\tc10.1,0,18.3-8.2,18.3-18.3V329.1c0-10.1-8.2-18.3-18.3-18.3s-18.3,8.2-18.3,18.3v164.6C237.7,503.8,245.9,512,256,512z\\\"/>\\r\\n\\t<path class=\\\"st0\\\" d=\\\"M342.1,415.2c7.1-7.1,7.2-18.7,0-25.9l0,0L269,316.2c-7.1-7.1-18.7-7.2-25.9,0l0,0l-73.1,73.1\\r\\n\\t\\tc-7.1,7.2-7.1,18.7,0,25.9c7.2,7.1,18.7,7.1,25.9,0L256,355l60.2,60.2C323.3,422.4,334.9,422.4,342.1,415.2L342.1,415.2z\\\"/>\\r\\n</g>\\r\\n</svg>\\r\\n\";","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><circle cx=\\\"256\\\" cy=\\\"256\\\" r=\\\"48\\\"/><circle cx=\\\"416\\\" cy=\\\"256\\\" r=\\\"48\\\"/><circle cx=\\\"96\\\" cy=\\\"256\\\" r=\\\"48\\\"/></svg>\";","export default \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?><!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\"><svg viewBox=\\\"0 0 106 124\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xml:space=\\\"preserve\\\" xmlns:serif=\\\"http://www.serif.com/\\\" style=\\\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\\\"><g><g><path d=\\\"M52.893,48.427c2.424,-0 4.392,-1.968 4.392,-4.392l0,-39.504c0,-2.424 -1.968,-4.392 -4.392,-4.392c-2.424,-0 -4.392,1.968 -4.392,4.392l0,39.504c0,2.424 1.968,4.392 4.392,4.392Z\\\"/><path d=\\\"M73.557,25.195c1.704,-1.704 1.728,-4.488 0,-6.216l-17.544,-17.544c-1.704,-1.704 -4.488,-1.728 -6.216,-0l-17.544,17.544c-1.704,1.728 -1.704,4.488 0,6.216c1.728,1.704 4.488,1.704 6.216,-0l14.424,-14.448l14.448,14.448c1.704,1.728 4.488,1.728 6.216,-0Z\\\"/></g><path d=\\\"M0.237,61.579c0,-2.424 1.968,-4.392 4.392,-4.392l96.552,-0c2.424,-0 4.392,1.968 4.392,4.392c0,2.424 -1.968,4.392 -4.392,4.392l-96.552,-0c-2.424,-0 -4.392,-1.968 -4.392,-4.392Z\\\"/><g><path d=\\\"M52.893,74.731c2.424,-0 4.392,1.968 4.392,4.392l0,39.504c0,2.424 -1.968,4.392 -4.392,4.392c-2.424,-0 -4.392,-1.968 -4.392,-4.392l0,-39.504c0,-2.424 1.968,-4.392 4.392,-4.392Z\\\"/><path d=\\\"M73.557,97.963c1.704,1.704 1.728,4.488 0,6.216l-17.544,17.544c-1.704,1.704 -4.488,1.728 -6.216,-0l-17.544,-17.544c-1.704,-1.728 -1.704,-4.488 0,-6.216c1.728,-1.704 4.488,-1.704 6.216,-0l14.424,14.448l14.448,-14.448c1.704,-1.728 4.488,-1.728 6.216,-0Z\\\"/></g></g></svg>\";","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><path d=\\\"M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm80 224H176a16 16 0 010-32h160a16 16 0 010 32z\\\"/></svg>\";","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"ionicon\\\" viewBox=\\\"0 0 512 512\\\"><path d=\\\"M473 39.05a24 24 0 00-25.5-5.46L47.47 185h-.08a24 24 0 001 45.16l.41.13 137.3 58.63a16 16 0 0015.54-3.59L422 80a7.07 7.07 0 0110 10L226.66 310.26a16 16 0 00-3.59 15.54l58.65 137.38c.06.2.12.38.19.57 3.2 9.27 11.3 15.81 21.09 16.25h1a24.63 24.63 0 0023-15.46L478.39 64.62A24 24 0 00473 39.05z\\\"/></svg>\";","export default \"<svg class=\\\"delete-tab\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"16\\\" data-icon=\\\"ui-components:close\\\" data-icon-id=\\\"58648a58-146c-4974-9873-7d2dfb468b8d\\\"><g class=\\\"x-icon-circle\\\" fill=\\\"none\\\"><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"11\\\"></circle></g><g class=\\\"x-icon\\\" fill=\\\"#616161\\\"><path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\"></path></g></svg>\\n\";"],"names":[],"sourceRoot":""}
{"version":3,"file":"4884.9231c61.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport const DRIVE_SEPARATOR = ':';\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n            stream.file = undefined;\n        }\n    }\n    read(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        const size = Math.min(((_a = stream.file.data.length) !== null && _a !== void 0 ? _a : 0) - position, length);\n        try {\n            buffer.set(stream.file.data.subarray(position, position + size), offset);\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a, _b;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        try {\n            if (position + length > ((_b = (_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) !== null && _b !== void 0 ? _b : 0)) {\n                const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n                stream.file.data = new Uint8Array(position + length);\n                stream.file.data.set(oldData);\n            }\n            stream.file.data.set(buffer.subarray(offset, offset + length), position);\n            return length;\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EINVAL']);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    getattr(node) {\n        return this.fs.API.getattr(this.fs.realPath(node));\n    }\n    setattr(node, attr) {\n        // TODO\n    }\n    lookup(parent, name) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n        }\n        return this.fs.createNode(parent, name, result.mode);\n    }\n    mknod(parent, name, mode, dev) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(parent, name, mode, dev);\n    }\n    rename(oldNode, newDir, newName) {\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDir), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    readdir(node) {\n        return this.fs.API.readdir(this.fs.realPath(node));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        this._baseUrl = baseUrl;\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return Number.parseInt(this.request({ method: 'getmode', path: this.normalizePath(path) }));\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({ method: 'get', path: this.normalizePath(path) });\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({ method: 'getattr', path: this.normalizePath(path) });\n        // Turn datetimes into proper objects\n        stats.atime = new Date(stats.atime);\n        stats.mtime = new Date(stats.mtime);\n        stats.ctime = new Date(stats.ctime);\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = new ContentsAPI(options.baseUrl, options.driveName, options.mountpoint, this.FS, this.ERRNO_CODES);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n","import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: 0,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        let item = await this.get(path);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            if (ext === '.ipynb') {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'notebook',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'file',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                item = {\n                    ...item,\n                    content: this.unescapeContent(options.content),\n                    format: 'text',\n                    type: 'file',\n                };\n            }\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    unescapeContent(content) {\n        return decodeURIComponent(escape(atob(content)));\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            content: null,\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(new Uint8Array(await response.arrayBuffer()).reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, PathExt } from '@jupyterlab/coreutils';\nimport { Contents, DIR_MODE, FILE_MODE, IContents, } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { IServiceWorkerRegistrationWrapper, ServiceWorkerRegistrationWrapper, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\nimport localforage from 'localforage';\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerRegistrationWrapper,\n    activate: (app) => {\n        return new ServiceWorkerRegistrationWrapper();\n    },\n};\n/**\n * A plugin handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    activate: (app) => {\n        // Setup communication with service worker for the virtual fs\n        const broadcast = new BroadcastChannel('/api/drive.v1');\n        let subitems;\n        broadcast.onmessage = async (event) => {\n            const request = event.data;\n            const contentManager = app.serviceManager.contents;\n            const path = request.path;\n            let model;\n            switch (request.method) {\n                case 'readdir': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory' && model.content) {\n                        subitems = model.content.map((subcontent) => subcontent.name);\n                        broadcast.postMessage(subitems);\n                    }\n                    else {\n                        broadcast.postMessage([]);\n                    }\n                    break;\n                }\n                case 'rmdir': {\n                    await contentManager.delete(path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'rename': {\n                    await contentManager.rename(path, request.data.newPath);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getmode': {\n                    model = await contentManager.get(path);\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(DIR_MODE);\n                    }\n                    else {\n                        broadcast.postMessage(FILE_MODE);\n                    }\n                    break;\n                }\n                case 'lookup': {\n                    try {\n                        model = await contentManager.get(path);\n                        broadcast.postMessage({\n                            ok: true,\n                            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        });\n                    }\n                    catch (e) {\n                        broadcast.postMessage({\n                            ok: false,\n                        });\n                    }\n                    break;\n                }\n                case 'mknod': {\n                    const mode = Number.parseInt(request.data.mode);\n                    model = await contentManager.newUntitled({\n                        path: PathExt.dirname(path),\n                        type: mode === DIR_MODE ? 'directory' : 'file',\n                        ext: PathExt.extname(path),\n                    });\n                    await contentManager.rename(model.path, path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getattr': {\n                    model = await contentManager.get(path);\n                    broadcast.postMessage({\n                        dev: 0,\n                        ino: 0,\n                        mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        nlink: 0,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size: model.size || 0,\n                        blksize: 0,\n                        blocks: 0,\n                        atime: model.last_modified,\n                        mtime: model.last_modified,\n                        ctime: model.last_modified,\n                        timestamp: 0,\n                    });\n                    break;\n                }\n                case 'get': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    let content = model.content;\n                    if (model.format === 'json') {\n                        content = JSON.stringify(model.content);\n                    }\n                    broadcast.postMessage({\n                        content,\n                        format: model.format,\n                    });\n                    break;\n                }\n                case 'put': {\n                    await contentManager.save(path, {\n                        content: request.data.format === 'json'\n                            ? JSON.parse(request.data.data)\n                            : request.data.data,\n                        type: 'file',\n                        format: request.data.format,\n                    });\n                    broadcast.postMessage(null);\n                    break;\n                }\n            }\n        };\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec !== null && spec !== void 0 ? spec : {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n"],"names":["DIR_MODE","FILE_MODE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","constructor","fs","this","open","stream","path","realPath","node","FS","isFile","mode","file","API","get","close","flags","parsedFlags","parseInt","needsWrite","put","undefined","read","buffer","offset","length","position","_a","size","Math","min","data","set","subarray","e","ErrnoError","ERRNO_CODES","write","_b","timestamp","Date","now","oldData","Uint8Array","llseek","whence","DriveFSEmscriptenNodeOps","getattr","setattr","attr","lookup","parent","name","PATH","join2","result","ok","genericErrors","createNode","mknod","dev","rename","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","xhr","XMLHttpRequest","encodeURI","endpoint","send","JSON","stringify","console","error","status","parse","responseText","method","normalizePath","getmode","Number","newPath","dirlist","push","response","serializedContent","content","format","encode","binString","atob","len","i","charCodeAt","value","decode","binary","byteLength","String","fromCharCode","btoa","stats","atime","mtime","ctime","startsWith","slice","DriveFS","options","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","join","apply","IContents","Token","MIME","FILE","PLAIN_TEXT","OCTET_STREAM","TYPES","PageConfig","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","hasFormat","fileFormat","DEFAULT_STORAGE_NAME","Contents","reduceBytesToString","byte","_serverContents","Map","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","async","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","createInstance","description","storeName","_c","type","created","toISOString","dirname","PathExt","basename","extname","item","_incrementCounter","last_modified","mimetype","writable","counter","Private","EMPTY_NB","indexOf","key","setItem","toDir","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","serverContents","Array","from","_getServerDirectory","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","URLExt","newUntitled","unescapeContent","escape","slashed","toDelete","keys","filter","Promise","all","map","forgetPath","copies","Boolean","splice","id","normalizeCheckpoint","toString","checkpointID","includes","fileUrl","fetch","headers","match","json","text","arrayBuffer","reduce","apiURL","err","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","localforagePlugin","autoStart","provides","ILocalForage","activate","app","localforageMemoryPlugin","requires","forage","ensureMemoryStorage","contentsPlugin","contents","started","initialize","catch","contentsRoutesPlugin","router","req","filename","res","listCheckpoints","Response","post","checkpoint","restoreCheckpoint","createCheckpoint","delete","deleteCheckpoint","query","nb","body","copyFrom","copy_from","copy","patch","save","serviceWorkerPlugin","IServiceWorkerRegistrationWrapper","ServiceWorkerRegistrationWrapper","emscriptenFileSystemPlugin","broadcast","BroadcastChannel","subitems","onmessage","event","contentManager","serviceManager","subcontent","postMessage","ino","nlink","uid","gid","rdev","blksize","blocks","kernelsPlugin","IKernels","IKernelSpecs","kernelspecs","Kernels","kernelsRoutesPlugin","kernels","kernelId","restart","shutdown","kernelSpecPlugin","KernelSpecs","kernelSpecRoutesPlugin","specs","allKernelSpecs","allSpecs","forEach","spec","resources","default","licensesPlugin","ILicenses","Licenses","licensesRoutesPlugin","licenses","nbconvertRoutesPlugin","sessionsPlugin","ISessions","Sessions","sessionsRoutesPlugin","sessions","session","list","startNew","settingsPlugin","ISettings","settings","Settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale"],"sourceRoot":""}
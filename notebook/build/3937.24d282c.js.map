{"version":3,"file":"3937.24d282c.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module documentsearch-extension\n */\nimport { ILabShell } from '@jupyterlab/application';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { CodeMirrorSearchProvider, ISearchProviderRegistry, NotebookSearchProvider, SearchInstance, SearchProviderRegistry } from '@jupyterlab/documentsearch';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nconst SEARCHABLE_CLASS = 'jp-mod-searchable';\nconst labShellWidgetListener = {\n    id: '@jupyterlab/documentsearch:labShellWidgetListener',\n    requires: [ILabShell, ISearchProviderRegistry],\n    autoStart: true,\n    activate: (app, labShell, registry) => {\n        // If a given widget is searchable, apply the searchable class.\n        // If it's not searchable, remove the class.\n        const transformWidgetSearchability = (widget) => {\n            if (!widget) {\n                return;\n            }\n            const providerForWidget = registry.getProviderForWidget(widget);\n            if (providerForWidget) {\n                widget.addClass(SEARCHABLE_CLASS);\n            }\n            if (!providerForWidget) {\n                widget.removeClass(SEARCHABLE_CLASS);\n            }\n        };\n        // Update searchability of the active widget when the registry\n        // changes, in case a provider for the current widget was added\n        // or removed\n        registry.changed.connect(() => transformWidgetSearchability(labShell.activeWidget));\n        // Apply the searchable class only to the active widget if it is actually\n        // searchable. Remove the searchable class from a widget when it's\n        // no longer active.\n        labShell.activeChanged.connect((_, args) => {\n            const oldWidget = args.oldValue;\n            if (oldWidget) {\n                oldWidget.removeClass(SEARCHABLE_CLASS);\n            }\n            transformWidgetSearchability(args.newValue);\n        });\n    }\n};\n/**\n * Initialization data for the document-search extension.\n */\nconst extension = {\n    id: '@jupyterlab/documentsearch:plugin',\n    provides: ISearchProviderRegistry,\n    requires: [ITranslator],\n    optional: [ICommandPalette, ISettingRegistry],\n    autoStart: true,\n    activate: (app, translator, palette, settingRegistry) => {\n        const trans = translator.load('jupyterlab');\n        let searchDebounceTime = 500;\n        // Create registry, retrieve all default providers\n        const registry = new SearchProviderRegistry();\n        // Register default implementations of the Notebook and CodeMirror search providers\n        registry.register('jp-notebookSearchProvider', NotebookSearchProvider);\n        registry.register('jp-codeMirrorSearchProvider', CodeMirrorSearchProvider);\n        const activeSearches = new Map();\n        const startCommand = 'documentsearch:start';\n        const startReplaceCommand = 'documentsearch:startWithReplace';\n        const nextCommand = 'documentsearch:highlightNext';\n        const prevCommand = 'documentsearch:highlightPrevious';\n        if (settingRegistry) {\n            const loadSettings = settingRegistry.load('@jupyterlab/documentsearch-extension:plugin');\n            const updateSettings = (settings) => {\n                searchDebounceTime = settings.get('searchDebounceTime')\n                    .composite;\n            };\n            Promise.all([loadSettings, app.restored])\n                .then(([settings]) => {\n                updateSettings(settings);\n                settings.changed.connect(settings => {\n                    updateSettings(settings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        const currentWidgetHasSearchProvider = () => {\n            const currentWidget = app.shell.currentWidget;\n            if (!currentWidget) {\n                return false;\n            }\n            return registry.getProviderForWidget(currentWidget) !== undefined;\n        };\n        const getCurrentWidgetSearchInstance = () => {\n            const currentWidget = app.shell.currentWidget;\n            if (!currentWidget) {\n                return;\n            }\n            const widgetId = currentWidget.id;\n            let searchInstance = activeSearches.get(widgetId);\n            if (!searchInstance) {\n                const searchProvider = registry.getProviderForWidget(currentWidget);\n                if (!searchProvider) {\n                    return;\n                }\n                searchInstance = new SearchInstance(currentWidget, searchProvider, translator, searchDebounceTime);\n                activeSearches.set(widgetId, searchInstance);\n                // find next and previous are now enabled\n                app.commands.notifyCommandChanged();\n                searchInstance.disposed.connect(() => {\n                    activeSearches.delete(widgetId);\n                    // find next and previous are now not enabled\n                    app.commands.notifyCommandChanged();\n                });\n            }\n            return searchInstance;\n        };\n        app.commands.addCommand(startCommand, {\n            label: trans.__('Find…'),\n            isEnabled: currentWidgetHasSearchProvider,\n            execute: args => {\n                const searchInstance = getCurrentWidgetSearchInstance();\n                if (searchInstance) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchInstance.setSearchText(searchText);\n                    }\n                    searchInstance.focusInput();\n                }\n            }\n        });\n        app.commands.addCommand(startReplaceCommand, {\n            label: trans.__('Find and Replace…'),\n            isEnabled: currentWidgetHasSearchProvider,\n            execute: args => {\n                const searchInstance = getCurrentWidgetSearchInstance();\n                if (searchInstance) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchInstance.setSearchText(searchText);\n                    }\n                    const replaceText = args['replaceText'];\n                    if (replaceText) {\n                        searchInstance.setReplaceText(replaceText);\n                    }\n                    searchInstance.showReplace();\n                    searchInstance.focusInput();\n                }\n            }\n        });\n        app.commands.addCommand(nextCommand, {\n            label: trans.__('Find Next'),\n            isEnabled: () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return false;\n                }\n                return activeSearches.has(currentWidget.id);\n            },\n            execute: async () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const instance = activeSearches.get(currentWidget.id);\n                if (!instance) {\n                    return;\n                }\n                await instance.provider.highlightNext();\n                instance.updateIndices();\n            }\n        });\n        app.commands.addCommand(prevCommand, {\n            label: trans.__('Find Previous'),\n            isEnabled: () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return false;\n                }\n                return activeSearches.has(currentWidget.id);\n            },\n            execute: async () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const instance = activeSearches.get(currentWidget.id);\n                if (!instance) {\n                    return;\n                }\n                await instance.provider.highlightPrevious();\n                instance.updateIndices();\n            }\n        });\n        // Add the command to the palette.\n        if (palette) {\n            palette.addItem({\n                command: startCommand,\n                category: trans.__('Main Area')\n            });\n            palette.addItem({\n                command: nextCommand,\n                category: trans.__('Main Area')\n            });\n            palette.addItem({\n                command: prevCommand,\n                category: trans.__('Main Area')\n            });\n        }\n        // Provide the registry to the system.\n        return registry;\n    }\n};\nexport default [extension, labShellWidgetListener];\n//# sourceMappingURL=index.js.map"],"names":["SEARCHABLE_CLASS","labShellWidgetListener","id","requires","ILabShell","ISearchProviderRegistry","autoStart","activate","app","labShell","registry","transformWidgetSearchability","widget","providerForWidget","getProviderForWidget","addClass","removeClass","changed","connect","activeWidget","activeChanged","_","args","oldWidget","oldValue","newValue","provides","ITranslator","optional","ICommandPalette","ISettingRegistry","translator","palette","settingRegistry","trans","load","searchDebounceTime","SearchProviderRegistry","register","NotebookSearchProvider","CodeMirrorSearchProvider","activeSearches","Map","startCommand","nextCommand","prevCommand","loadSettings","updateSettings","settings","get","composite","Promise","all","restored","then","catch","reason","console","error","message","currentWidgetHasSearchProvider","currentWidget","shell","undefined","getCurrentWidgetSearchInstance","widgetId","searchInstance","searchProvider","SearchInstance","set","commands","notifyCommandChanged","disposed","delete","addCommand","label","__","isEnabled","execute","searchText","setSearchText","focusInput","replaceText","setReplaceText","showReplace","has","async","instance","provider","highlightNext","updateIndices","highlightPrevious","addItem","command","category"],"sourceRoot":""}
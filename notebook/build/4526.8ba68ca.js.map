{"version":3,"file":"4526.8ba68ca.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/dataconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/interfaces.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/restorablepool.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/statedb.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/tokens.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataConnector = void 0;\n/**\n * An abstract class that adheres to the data connector interface.\n *\n * @typeparam T - The basic entity response type a service's connector.\n *\n * @typeparam U - The basic entity request type, which is conventionally the\n * same as the response type but may be different if a service's implementation\n * requires input data to be different from output responses. Defaults to `T`.\n *\n * @typeparam V - The basic token applied to a request, conventionally a string\n * ID or filter, but may be set to a different type when an implementation\n * requires it. Defaults to `string`.\n *\n * @typeparam W - The type of the optional `query` parameter of the `list`\n * method. Defaults to `string`.\n *\n * #### Notes\n * The only abstract method in this class is the `fetch` method, which must be\n * reimplemented by all subclasses. The `remove` and `save` methods have a\n * default implementation that returns a promise that will always reject. This\n * class is a convenience superclass for connectors that only need to `fetch`.\n */\nclass DataConnector {\n    /**\n     * Retrieve the list of items available from the data connector.\n     *\n     * @param query - The optional query filter to apply to the connector request.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can list.\n     */\n    async list(query) {\n        throw new Error('DataConnector#list method has not been implemented.');\n    }\n    /**\n     * Remove a value using the data connector.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can remove.\n     */\n    async remove(id) {\n        throw new Error('DataConnector#remove method has not been implemented.');\n    }\n    /**\n     * Save a value using the data connector.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can save.\n     */\n    async save(id, value) {\n        throw new Error('DataConnector#save method has not been implemented.');\n    }\n}\nexports.DataConnector = DataConnector;\n//# sourceMappingURL=dataconnector.js.map","\"use strict\";\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module statedb\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./dataconnector\"), exports);\n__exportStar(require(\"./interfaces\"), exports);\n__exportStar(require(\"./restorablepool\"), exports);\n__exportStar(require(\"./statedb\"), exports);\n__exportStar(require(\"./tokens\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestorablePool = void 0;\nconst coreutils_1 = require(\"@lumino/coreutils\");\nconst properties_1 = require(\"@lumino/properties\");\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * An object pool that supports restoration.\n *\n * @typeparam T - The type of object being tracked.\n */\nclass RestorablePool {\n    /**\n     * Create a new restorable pool.\n     *\n     * @param options - The instantiation options for a restorable pool.\n     */\n    constructor(options) {\n        this._added = new signaling_1.Signal(this);\n        this._current = null;\n        this._currentChanged = new signaling_1.Signal(this);\n        this._hasRestored = false;\n        this._isDisposed = false;\n        this._objects = new Set();\n        this._restore = null;\n        this._restored = new coreutils_1.PromiseDelegate();\n        this._updated = new signaling_1.Signal(this);\n        this.namespace = options.namespace;\n    }\n    /**\n     * A signal emitted when an object object is added.\n     *\n     * #### Notes\n     * This signal will only fire when an object is added to the pool.\n     * It will not fire if an object injected into the pool.\n     */\n    get added() {\n        return this._added;\n    }\n    /**\n     * The current object.\n     *\n     * #### Notes\n     * The restorable pool does not set `current`. It is intended for client use.\n     *\n     * If `current` is set to an object that does not exist in the pool, it is a\n     * no-op.\n     */\n    get current() {\n        return this._current;\n    }\n    set current(obj) {\n        if (this._current === obj) {\n            return;\n        }\n        if (obj !== null && this._objects.has(obj)) {\n            this._current = obj;\n            this._currentChanged.emit(this._current);\n        }\n    }\n    /**\n     * A signal emitted when the current widget changes.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * Test whether the pool is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise resolved when the restorable pool has been restored.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * The number of objects held by the pool.\n     */\n    get size() {\n        return this._objects.size;\n    }\n    /**\n     * A signal emitted when an object is updated.\n     */\n    get updated() {\n        return this._updated;\n    }\n    /**\n     * Add a new object to the pool.\n     *\n     * @param obj - The object object being added.\n     *\n     * #### Notes\n     * The object passed into the pool is added synchronously; its existence in\n     * the pool can be checked with the `has()` method. The promise this method\n     * returns resolves after the object has been added and saved to an underlying\n     * restoration connector, if one is available.\n     */\n    async add(obj) {\n        var _a, _b;\n        if (obj.isDisposed) {\n            const warning = 'A disposed object cannot be added.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        if (this._objects.has(obj)) {\n            const warning = 'This object already exists in the pool.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        this._objects.add(obj);\n        obj.disposed.connect(this._onInstanceDisposed, this);\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (this._restore) {\n            const { connector } = this._restore;\n            const objName = this._restore.name(obj);\n            if (objName) {\n                const name = `${this.namespace}:${objName}`;\n                const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n                Private.nameProperty.set(obj, name);\n                await connector.save(name, { data });\n            }\n        }\n        // Emit the added signal.\n        this._added.emit(obj);\n    }\n    /**\n     * Dispose of the resources held by the pool.\n     *\n     * #### Notes\n     * Disposing a pool does not affect the underlying data in the data connector,\n     * it simply disposes the client-side pool without making any connector calls.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._current = null;\n        this._isDisposed = true;\n        this._objects.clear();\n        signaling_1.Signal.clearData(this);\n    }\n    /**\n     * Find the first object in the pool that satisfies a filter function.\n     *\n     * @param - fn The filter function to call on each object.\n     */\n    find(fn) {\n        const values = this._objects.values();\n        for (const value of values) {\n            if (fn(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Iterate through each object in the pool.\n     *\n     * @param fn - The function to call on each object.\n     */\n    forEach(fn) {\n        this._objects.forEach(fn);\n    }\n    /**\n     * Filter the objects in the pool based on a predicate.\n     *\n     * @param fn - The function by which to filter.\n     */\n    filter(fn) {\n        const filtered = [];\n        this.forEach(obj => {\n            if (fn(obj)) {\n                filtered.push(obj);\n            }\n        });\n        return filtered;\n    }\n    /**\n     * Inject an object into the restorable pool without the pool handling its\n     * restoration lifecycle.\n     *\n     * @param obj - The object to inject into the pool.\n     */\n    inject(obj) {\n        Private.injectedProperty.set(obj, true);\n        return this.add(obj);\n    }\n    /**\n     * Check if this pool has the specified object.\n     *\n     * @param obj - The object whose existence is being checked.\n     */\n    has(obj) {\n        return this._objects.has(obj);\n    }\n    /**\n     * Restore the objects in this pool's namespace.\n     *\n     * @param options - The configuration options that describe restoration.\n     *\n     * @returns A promise that resolves when restoration has completed.\n     *\n     * #### Notes\n     * This function should almost never be invoked by client code. Its primary\n     * use case is to be invoked by a layout restorer plugin that handles\n     * multiple restorable pools and, when ready, asks them each to restore their\n     * respective objects.\n     */\n    async restore(options) {\n        if (this._hasRestored) {\n            throw new Error('This pool has already been restored.');\n        }\n        this._hasRestored = true;\n        const { command, connector, registry, when } = options;\n        const namespace = this.namespace;\n        const promises = when\n            ? [connector.list(namespace)].concat(when)\n            : [connector.list(namespace)];\n        this._restore = options;\n        const [saved] = await Promise.all(promises);\n        const values = await Promise.all(saved.ids.map(async (id, index) => {\n            const value = saved.values[index];\n            const args = value && value.data;\n            if (args === undefined) {\n                return connector.remove(id);\n            }\n            // Execute the command and if it fails, delete the state restore data.\n            return registry\n                .execute(command, args)\n                .catch(() => connector.remove(id));\n        }));\n        this._restored.resolve();\n        return values;\n    }\n    /**\n     * Save the restore data for a given object.\n     *\n     * @param obj - The object being saved.\n     */\n    async save(obj) {\n        var _a, _b;\n        const injected = Private.injectedProperty.get(obj);\n        if (!this._restore || !this.has(obj) || injected) {\n            return;\n        }\n        const { connector } = this._restore;\n        const objName = this._restore.name(obj);\n        const oldName = Private.nameProperty.get(obj);\n        const newName = objName ? `${this.namespace}:${objName}` : '';\n        if (oldName && oldName !== newName) {\n            await connector.remove(oldName);\n        }\n        // Set the name property irrespective of whether the new name is null.\n        Private.nameProperty.set(obj, newName);\n        if (newName) {\n            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n            await connector.save(newName, { data });\n        }\n        if (oldName !== newName) {\n            this._updated.emit(obj);\n        }\n    }\n    /**\n     * Clean up after disposed objects.\n     */\n    _onInstanceDisposed(obj) {\n        this._objects.delete(obj);\n        if (obj === this._current) {\n            this._current = null;\n            this._currentChanged.emit(this._current);\n        }\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (!this._restore) {\n            return;\n        }\n        const { connector } = this._restore;\n        const name = Private.nameProperty.get(obj);\n        if (name) {\n            void connector.remove(name);\n        }\n    }\n}\nexports.RestorablePool = RestorablePool;\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property to indicate whether an object has been injected.\n     */\n    Private.injectedProperty = new properties_1.AttachedProperty({\n        name: 'injected',\n        create: () => false\n    });\n    /**\n     * An attached property for an object's ID.\n     */\n    Private.nameProperty = new properties_1.AttachedProperty({\n        name: 'name',\n        create: () => ''\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=restorablepool.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateDB = void 0;\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * The default concrete implementation of a state database.\n */\nclass StateDB {\n    /**\n     * Create a new state database.\n     *\n     * @param options - The instantiation options for a state database.\n     */\n    constructor(options = {}) {\n        this._changed = new signaling_1.Signal(this);\n        const { connector, transform } = options;\n        this._connector = connector || new StateDB.Connector();\n        if (!transform) {\n            this._ready = Promise.resolve(undefined);\n        }\n        else {\n            this._ready = transform.then(transformation => {\n                const { contents, type } = transformation;\n                switch (type) {\n                    case 'cancel':\n                        return;\n                    case 'clear':\n                        return this._clear();\n                    case 'merge':\n                        return this._merge(contents || {});\n                    case 'overwrite':\n                        return this._overwrite(contents || {});\n                    default:\n                        return;\n                }\n            });\n        }\n    }\n    /**\n     * A signal that emits the change type any time a value changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Clear the entire database.\n     */\n    async clear() {\n        await this._ready;\n        await this._clear();\n    }\n    /**\n     * Retrieve a saved bundle from the database.\n     *\n     * @param id - The identifier used to retrieve a data bundle.\n     *\n     * @returns A promise that bears a data payload if available.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     *\n     * The promise returned by this method may be rejected if an error occurs in\n     * retrieving the data. Non-existence of an `id` will succeed with the `value`\n     * `undefined`.\n     */\n    async fetch(id) {\n        await this._ready;\n        return this._fetch(id);\n    }\n    /**\n     * Retrieve all the saved bundles for a namespace.\n     *\n     * @param filter - The namespace prefix to retrieve.\n     *\n     * @returns A promise that bears a collection of payloads for a namespace.\n     *\n     * #### Notes\n     * Namespaces are entirely conventional entities. The `id` values of stored\n     * items in the state database are formatted: `'namespace:identifier'`, which\n     * is the same convention that command identifiers in JupyterLab use as well.\n     *\n     * If there are any errors in retrieving the data, they will be logged to the\n     * console in order to optimistically return any extant data without failing.\n     * This promise will always succeed.\n     */\n    async list(namespace) {\n        await this._ready;\n        return this._list(namespace);\n    }\n    /**\n     * Remove a value from the database.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that is rejected if remove fails and succeeds otherwise.\n     */\n    async remove(id) {\n        await this._ready;\n        await this._remove(id);\n        this._changed.emit({ id, type: 'remove' });\n    }\n    /**\n     * Save a value in the database.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that is rejected if saving fails and succeeds otherwise.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     */\n    async save(id, value) {\n        await this._ready;\n        await this._save(id, value);\n        this._changed.emit({ id, type: 'save' });\n    }\n    /**\n     * Return a serialized copy of the state database's entire contents.\n     *\n     * @returns A promise that resolves with the database contents as JSON.\n     */\n    async toJSON() {\n        await this._ready;\n        const { ids, values } = await this._list();\n        return values.reduce((acc, val, idx) => {\n            acc[ids[idx]] = val;\n            return acc;\n        }, {});\n    }\n    /**\n     * Clear the entire database.\n     */\n    async _clear() {\n        await Promise.all((await this._list()).ids.map(id => this._remove(id)));\n    }\n    /**\n     * Fetch a value from the database.\n     */\n    async _fetch(id) {\n        const value = await this._connector.fetch(id);\n        if (value) {\n            return JSON.parse(value).v;\n        }\n    }\n    /**\n     * Fetch a list from the database.\n     */\n    async _list(namespace = '') {\n        const { ids, values } = await this._connector.list(namespace);\n        return {\n            ids,\n            values: values.map(val => JSON.parse(val).v)\n        };\n    }\n    /**\n     * Merge data into the state database.\n     */\n    async _merge(contents) {\n        await Promise.all(Object.keys(contents).map(key => contents[key] && this._save(key, contents[key])));\n    }\n    /**\n     * Overwrite the entire database with new contents.\n     */\n    async _overwrite(contents) {\n        await this._clear();\n        await this._merge(contents);\n    }\n    /**\n     * Remove a key in the database.\n     */\n    async _remove(id) {\n        return this._connector.remove(id);\n    }\n    /**\n     * Save a key and its value in the database.\n     */\n    async _save(id, value) {\n        return this._connector.save(id, JSON.stringify({ v: value }));\n    }\n}\nexports.StateDB = StateDB;\n/**\n * A namespace for StateDB statics.\n */\n(function (StateDB) {\n    /**\n     * An in-memory string key/value data connector.\n     */\n    class Connector {\n        constructor() {\n            this._storage = {};\n        }\n        /**\n         * Retrieve an item from the data connector.\n         */\n        async fetch(id) {\n            return this._storage[id];\n        }\n        /**\n         * Retrieve the list of items available from the data connector.\n         *\n         * @param namespace - If not empty, only keys whose first token before `:`\n         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.\n         */\n        async list(namespace = '') {\n            return Object.keys(this._storage).reduce((acc, val) => {\n                if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                    acc.ids.push(val);\n                    acc.values.push(this._storage[val]);\n                }\n                return acc;\n            }, { ids: [], values: [] });\n        }\n        /**\n         * Remove a value using the data connector.\n         */\n        async remove(id) {\n            delete this._storage[id];\n        }\n        /**\n         * Save a value using the data connector.\n         */\n        async save(id, value) {\n            this._storage[id] = value;\n        }\n    }\n    StateDB.Connector = Connector;\n})(StateDB = exports.StateDB || (exports.StateDB = {}));\n//# sourceMappingURL=statedb.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IStateDB = void 0;\nconst coreutils_1 = require(\"@lumino/coreutils\");\n/* tslint:disable */\n/**\n * The default state database token.\n */\nexports.IStateDB = new coreutils_1.Token('@jupyterlab/coreutils:IStateDB');\n//# sourceMappingURL=tokens.js.map"],"names":["Object","defineProperty","exports","value","DataConnector","async","query","Error","id","__createBinding","this","create","o","m","k","k2","undefined","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","RestorablePool","coreutils_1","properties_1","signaling_1","Private","constructor","options","_added","Signal","_current","_currentChanged","_hasRestored","_isDisposed","_objects","Set","_restore","_restored","PromiseDelegate","_updated","namespace","added","current","obj","has","emit","currentChanged","isDisposed","restored","promise","size","updated","_a","_b","warning","console","warn","add","disposed","connect","_onInstanceDisposed","injectedProperty","connector","objName","name","data","args","nameProperty","set","save","dispose","clear","clearData","find","fn","values","forEach","filter","filtered","push","inject","command","registry","when","promises","list","concat","saved","Promise","all","ids","map","index","remove","execute","catch","resolve","injected","oldName","newName","delete","AttachedProperty","StateDB","_changed","transform","_connector","Connector","_ready","then","transformation","contents","type","_clear","_merge","_overwrite","changed","_fetch","_list","_remove","_save","reduce","acc","val","idx","fetch","JSON","parse","v","keys","key","stringify","_storage","split","IStateDB","Token"],"sourceRoot":""}
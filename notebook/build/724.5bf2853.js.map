{"version":3,"file":"724.5bf2853.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/actions.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/default-toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/celllist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modelfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooktools.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tracker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/truststatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widgetfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/executionindicator.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Clipboard, Dialog, sessionContextDialogs, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, isCodeCellModel, isMarkdownCellModel, isRawCellModel, MarkdownCell } from '@jupyterlab/cells';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, each, findIndex, toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\nexport class KernelError extends Error {\n    /**\n     * Construct the kernel error.\n     */\n    constructor(content) {\n        const errorContent = content;\n        const errorName = errorContent.ename;\n        const errorValue = errorContent.evalue;\n        super(`KernelReplyNotOK: ${errorName} ${errorValue}`);\n        this.errorName = errorName;\n        this.errorValue = errorValue;\n        this.traceback = errorContent.traceback;\n        Object.setPrototypeOf(this, KernelError.prototype);\n    }\n}\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class NotebookActions {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get executionScheduled() {\n        return Private.executionScheduled;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get selectionExecuted() {\n        return Private.selectionExecuted;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (NotebookActions) {\n    /**\n     * Split the active cell into two or more cells.\n     *\n     * @param notebook The target notebook widget.\n     *\n     * #### Notes\n     * It will preserve the existing mode.\n     * The last cell will be activated if no selection is found.\n     * If text was selected, the cell containing the selection will\n     * be activated.\n     * The existing selection will be cleared.\n     * The activated cell will have focus and the cursor will\n     * remain in the initial position.\n     * The leading whitespace in the second cell will be removed.\n     * If there is no content, two empty cells will be created.\n     * Both cells will have the same type as the original cell.\n     * This action can be undone.\n     */\n    function splitCell(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        const nbModel = notebook.model;\n        const index = notebook.activeCellIndex;\n        const child = notebook.widgets[index];\n        const editor = child.editor;\n        const selections = editor.getSelections();\n        const orig = child.model.value.text;\n        const offsets = [0];\n        let start = -1;\n        let end = -1;\n        for (let i = 0; i < selections.length; i++) {\n            // append start and end to handle selections\n            // cursors will have same start and end\n            start = editor.getOffsetAt(selections[i].start);\n            end = editor.getOffsetAt(selections[i].end);\n            if (start < end) {\n                offsets.push(start);\n                offsets.push(end);\n            }\n            else if (end < start) {\n                offsets.push(end);\n                offsets.push(start);\n            }\n            else {\n                offsets.push(start);\n            }\n        }\n        offsets.push(orig.length);\n        const clones = [];\n        for (let i = 0; i + 1 < offsets.length; i++) {\n            const clone = Private.cloneCell(nbModel, child.model);\n            clones.push(clone);\n        }\n        for (let i = 0; i < clones.length; i++) {\n            if (i !== clones.length - 1 && clones[i].type === 'code') {\n                clones[i].outputs.clear();\n            }\n            clones[i].value.text = orig\n                .slice(offsets[i], offsets[i + 1])\n                .replace(/^\\n+/, '')\n                .replace(/\\n+$/, '');\n        }\n        const cells = nbModel.cells;\n        cells.beginCompoundOperation();\n        for (let i = 0; i < clones.length; i++) {\n            if (i === 0) {\n                cells.set(index, clones[i]);\n            }\n            else {\n                cells.insert(index + i, clones[i]);\n            }\n        }\n        cells.endCompoundOperation();\n        // If there is a selection the selected cell will be activated\n        const activeCellDelta = start !== end ? 2 : 1;\n        notebook.activeCellIndex = index + clones.length - activeCellDelta;\n        const focusedEditor = notebook.activeCell.editor;\n        focusedEditor.focus();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.splitCell = splitCell;\n    /**\n     * Merge the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mergeAbove - If only one cell is selected, indicates whether to merge it\n     *    with the cell above (true) or below (false, default).\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * If only one cell is selected and `mergeAbove` is true, the above cell will be selected.\n     * If only one cell is selected and `mergeAbove` is false, the below cell will be selected.\n     * If the active cell is a code cell, its outputs will be cleared.\n     * This action can be undone.\n     * The final cell will have the same type as the active cell.\n     * If the active cell is a markdown cell, it will be unrendered.\n     */\n    function mergeCells(notebook, mergeAbove = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const toMerge = [];\n        const toDelete = [];\n        const model = notebook.model;\n        const cells = model.cells;\n        const primary = notebook.activeCell;\n        const active = notebook.activeCellIndex;\n        const attachments = {};\n        // Get the cells to merge.\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                toMerge.push(child.model.value.text);\n                if (index !== active) {\n                    toDelete.push(child.model);\n                }\n                // Collect attachments if the cell is a markdown cell or a raw cell\n                const model = child.model;\n                if (isRawCellModel(model) || isMarkdownCellModel(model)) {\n                    for (const key of model.attachments.keys) {\n                        attachments[key] = model.attachments.get(key).toJSON();\n                    }\n                }\n            }\n        });\n        // Check for only a single cell selected.\n        if (toMerge.length === 1) {\n            // Merge with the cell above when mergeAbove is true\n            if (mergeAbove === true) {\n                // Bail if it is the first cell.\n                if (active === 0) {\n                    return;\n                }\n                // Otherwise merge with the previous cell.\n                const cellModel = cells.get(active - 1);\n                toMerge.unshift(cellModel.value.text);\n                toDelete.push(cellModel);\n            }\n            else if (mergeAbove === false) {\n                // Bail if it is the last cell.\n                if (active === cells.length - 1) {\n                    return;\n                }\n                // Otherwise merge with the next cell.\n                const cellModel = cells.get(active + 1);\n                toMerge.push(cellModel.value.text);\n                toDelete.push(cellModel);\n            }\n        }\n        notebook.deselectAll();\n        // Create a new cell for the source to preserve history.\n        const newModel = Private.cloneCell(model, primary.model);\n        newModel.value.text = toMerge.join('\\n\\n');\n        if (isCodeCellModel(newModel)) {\n            newModel.outputs.clear();\n        }\n        else if (isMarkdownCellModel(newModel) || isRawCellModel(newModel)) {\n            newModel.attachments.fromJSON(attachments);\n        }\n        // Make the changes while preserving history.\n        cells.beginCompoundOperation();\n        cells.set(active, newModel);\n        toDelete.forEach(cell => {\n            cells.removeValue(cell);\n        });\n        cells.endCompoundOperation();\n        // If the original cell is a markdown cell, make sure\n        // the new cell is unrendered.\n        if (primary instanceof MarkdownCell) {\n            notebook.activeCell.rendered = false;\n        }\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.mergeCells = mergeCells;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.deleteCells(notebook);\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.deleteCells = deleteCells;\n    /**\n     * Insert a new code cell above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will the active cell.\n     */\n    function insertAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        const active = notebook.activeCellIndex;\n        model.cells.insert(active, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = active;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertAbove = insertAbove;\n    /**\n     * Insert a new code cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will be the active cell.\n     */\n    function insertBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex++;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertBelow = insertBelow;\n    /**\n     * Move the selected cell(s) down.\n     *\n     * @param notebook = The target notebook widget.\n     */\n    function moveDown(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = cells.length - 2; i > -1; i--) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i + 1])) {\n                    cells.move(i, i + 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex++;\n                    }\n                    notebook.select(widgets[i + 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveDown = moveDown;\n    /**\n     * Move the selected cell(s) up.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function moveUp(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = 1; i < cells.length; i++) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i - 1])) {\n                    cells.move(i, i - 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex--;\n                    }\n                    notebook.select(widgets[i - 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveUp = moveUp;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.changeCellType(notebook, value);\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.changeCellType = changeCellType;\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, false);\n        return promise;\n    }\n    NotebookActions.run = run;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    function runAndAdvance(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n            // Do not use push here, as we want an widget insertion\n            // to make sure no placeholder widget is rendered.\n            model.cells.insert(notebook.widgets.length, cell);\n            notebook.activeCellIndex++;\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    function runAndInsert(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        notebook.activeCellIndex++;\n        notebook.mode = 'edit';\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex = previousIndex;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex--;\n        notebook.deselectAll();\n        for (let i = 0; i < notebook.activeCellIndex; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex++;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllBelow = runAllBelow;\n    /**\n     * Replaces the selection in the active cell of the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param text - The text to replace the selection.\n     */\n    function replaceSelection(notebook, text) {\n        var _a, _b;\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        (_b = (_a = notebook.activeCell.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);\n    }\n    NotebookActions.replaceSelection = replaceSelection;\n    /**\n     * Select the above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the first cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex - 1;\n        // find first non hidden cell above current cell\n        while (possibleNextCellIndex >= 0) {\n            const possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex -= 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectAbove = selectAbove;\n    /**\n     * Select the cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the last cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let maxCellIndex = notebook.widgets.length - 1;\n        // Find last non-hidden cell\n        while (notebook.widgets[maxCellIndex].isHidden ||\n            notebook.widgets[maxCellIndex].inputHidden) {\n            maxCellIndex -= 1;\n        }\n        if (notebook.activeCellIndex === maxCellIndex) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex + 1;\n        // find first non hidden cell below current cell\n        while (possibleNextCellIndex < maxCellIndex) {\n            let possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex += 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectBelow = selectBelow;\n    /**\n     * Extend the selection to the cell above.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toTop - If true, denotes selection to extend to the top.\n     *\n     * #### Notes\n     * This is a no-op if the first cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionAbove(notebook, toTop = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toTop is true, if yes, selection is made to the top.\n        if (toTop) {\n            notebook.extendContiguousSelectionTo(0);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionAbove = extendSelectionAbove;\n    /**\n     * Extend the selection to the cell below.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toBottom - If true, denotes selection to extend to the bottom.\n     *\n     * #### Notes\n     * This is a no-op if the last cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionBelow(notebook, toBottom = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toBottom is true, if yes selection is made to the bottom.\n        if (toBottom) {\n            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionBelow = extendSelectionBelow;\n    /**\n     * Select all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function selectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n    }\n    NotebookActions.selectAll = selectAll;\n    /**\n     * Deselect all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function deselectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.deselectAll();\n    }\n    NotebookActions.deselectAll = deselectAll;\n    /**\n     * Copy the selected cell(s) data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function copy(notebook) {\n        Private.copyOrCut(notebook, false);\n    }\n    NotebookActions.copy = copy;\n    /**\n     * Cut the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This action can be undone.\n     * A new code cell is added if all cells are cut.\n     */\n    function cut(notebook) {\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        Private.copyOrCut(notebook, true);\n    }\n    NotebookActions.cut = cut;\n    /**\n     * Paste cells from the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function paste(notebook, mode = 'below') {\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const clipboard = Clipboard.getInstance();\n        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        const values = clipboard.getData(JUPYTER_CELL_MIME);\n        addCells(notebook, mode, values, true);\n    }\n    NotebookActions.paste = paste;\n    /**\n     * Duplicate selected cells in the notebook without using the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function duplicate(notebook, mode = 'below') {\n        const values = Private.selectedCells(notebook);\n        if (!values || values.length === 0) {\n            return;\n        }\n        addCells(notebook, mode, values, false); // Cells not from the clipboard\n    }\n    NotebookActions.duplicate = duplicate;\n    /**\n     * Adds cells to the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * @param values  The cells to add to the notebook.\n     *\n     * @param cellsFromClipboard  True if the cells were sourced from the clipboard.\n     *\n     * #### Notes\n     * The last added cell becomes the active cell.\n     * This is a no-op if values is an empty array.\n     * This action can be undone.\n     */\n    function addCells(notebook, mode = 'below', values, cellsFromClipboard = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        notebook.mode = 'command';\n        const newCells = values.map(cell => {\n            switch (cell.cell_type) {\n                case 'code':\n                    if (notebook.lastClipboardInteraction === 'cut' &&\n                        typeof cell.id === 'string') {\n                        let cell_id = cell.id;\n                        return model.contentFactory.createCodeCell({\n                            id: cell_id,\n                            cell: cell\n                        });\n                    }\n                    else {\n                        return model.contentFactory.createCodeCell({ cell });\n                    }\n                case 'markdown':\n                    return model.contentFactory.createMarkdownCell({ cell });\n                default:\n                    return model.contentFactory.createRawCell({ cell });\n            }\n        });\n        const cells = notebook.model.cells;\n        let index;\n        cells.beginCompoundOperation();\n        // Set the starting index of the paste operation depending upon the mode.\n        switch (mode) {\n            case 'below':\n                index = notebook.activeCellIndex;\n                break;\n            case 'belowSelected':\n                notebook.widgets.forEach((child, childIndex) => {\n                    if (notebook.isSelectedOrActive(child)) {\n                        index = childIndex;\n                    }\n                });\n                break;\n            case 'above':\n                index = notebook.activeCellIndex - 1;\n                break;\n            case 'replace': {\n                // Find the cells to delete.\n                const toDelete = [];\n                notebook.widgets.forEach((child, index) => {\n                    const deletable = child.model.metadata.get('deletable') !== false;\n                    if (notebook.isSelectedOrActive(child) && deletable) {\n                        toDelete.push(index);\n                    }\n                });\n                // If cells are not deletable, we may not have anything to delete.\n                if (toDelete.length > 0) {\n                    // Delete the cells as one undo event.\n                    toDelete.reverse().forEach(i => {\n                        cells.remove(i);\n                    });\n                }\n                index = toDelete[0];\n                break;\n            }\n            default:\n                break;\n        }\n        newCells.forEach(cell => {\n            cells.insert(++index, cell);\n        });\n        cells.endCompoundOperation();\n        notebook.activeCellIndex += newCells.length;\n        notebook.deselectAll();\n        if (cellsFromClipboard) {\n            notebook.lastClipboardInteraction = 'paste';\n        }\n        Private.handleState(notebook, state);\n    }\n    /**\n     * Undo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if if there are no cell actions to undo.\n     */\n    function undo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.undo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.undo = undo;\n    /**\n     * Redo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to redo.\n     */\n    function redo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.redo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.redo = redo;\n    /**\n     * Toggle the line number of all cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The original state is based on the state of the active cell.\n     * The `mode` of the widget will be preserved.\n     */\n    function toggleAllLineNumbers(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const config = notebook.editorConfig;\n        const lineNumbers = !(config.code.lineNumbers &&\n            config.markdown.lineNumbers &&\n            config.raw.lineNumbers);\n        const newConfig = {\n            code: Object.assign(Object.assign({}, config.code), { lineNumbers }),\n            markdown: Object.assign(Object.assign({}, config.markdown), { lineNumbers }),\n            raw: Object.assign(Object.assign({}, config.raw), { lineNumbers })\n        };\n        notebook.editorConfig = newConfig;\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;\n    /**\n     * Clear the code outputs of the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearOutputs = clearOutputs;\n    /**\n     * Clear all the code outputs on the widget.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearAllOutputs = clearAllOutputs;\n    /**\n     * Hide the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideCode = hideCode;\n    /**\n     * Show the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showCode = showCode;\n    /**\n     * Hide the code on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideAllCode = hideAllCode;\n    /**\n     * Show the code on all code cells.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function showAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllCode = showAllCode;\n    /**\n     * Hide the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideOutput = hideOutput;\n    /**\n     * Show the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showOutput = showOutput;\n    /**\n     * Hide the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideAllOutputs = hideAllOutputs;\n    /**\n     * Render side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderSideBySide(notebook) {\n        notebook.renderingLayout = 'side-by-side';\n    }\n    NotebookActions.renderSideBySide = renderSideBySide;\n    /**\n     * Render not side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderDefault(notebook) {\n        notebook.renderingLayout = 'default';\n    }\n    NotebookActions.renderDefault = renderDefault;\n    /**\n     * Show the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllOutputs = showAllOutputs;\n    /**\n     * Enable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function enableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.enableOutputScrolling = enableOutputScrolling;\n    /**\n     * Disable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function disableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.disableOutputScrolling = disableOutputScrolling;\n    /**\n     * Go to the last cell that is run or current if it is running.\n     *\n     * Note: This requires execution timing to be toggled on or this will have\n     * no effect.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function selectLastRunCell(notebook) {\n        let latestTime = null;\n        let latestCellIdx = null;\n        notebook.widgets.forEach((cell, cellIndx) => {\n            if (cell.model.type === 'code') {\n                const execution = cell.model.metadata.get('execution');\n                if (execution &&\n                    JSONExt.isObject(execution) &&\n                    execution['iopub.status.busy'] !== undefined) {\n                    // The busy status is used as soon as a request is received:\n                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html\n                    const timestamp = execution['iopub.status.busy'].toString();\n                    if (timestamp) {\n                        const startTime = new Date(timestamp);\n                        if (!latestTime || startTime >= latestTime) {\n                            latestTime = startTime;\n                            latestCellIdx = cellIndx;\n                        }\n                    }\n                }\n            }\n        });\n        if (latestCellIdx !== null) {\n            notebook.activeCellIndex = latestCellIdx;\n        }\n    }\n    NotebookActions.selectLastRunCell = selectLastRunCell;\n    /**\n     * Set the markdown header level.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param level - The header level.\n     *\n     * #### Notes\n     * All selected cells will be switched to markdown.\n     * The level will be clamped between 1 and 6.\n     * If there is an existing header, it will be replaced.\n     * There will always be one blank space after the header.\n     * The cells will be unrendered.\n     */\n    function setMarkdownHeader(notebook, level) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        level = Math.min(Math.max(level, 1), 6);\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                Private.setMarkdownHeader(cells.get(index), level);\n            }\n        });\n        Private.changeCellType(notebook, 'markdown');\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.setMarkdownHeader = setMarkdownHeader;\n    /**\n     * Collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function collapseAll(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, true, notebook);\n                NotebookActions.setCellCollapse(cell, true);\n            }\n        }\n    }\n    NotebookActions.collapseAll = collapseAll;\n    /**\n     * Un-collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function expandAllHeadings(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, false, notebook);\n                // similar to collapseAll.\n                NotebookActions.setCellCollapse(cell, false);\n            }\n        }\n    }\n    NotebookActions.expandAllHeadings = expandAllHeadings;\n    function findNearestParentHeader(cell, notebook) {\n        const index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return;\n        }\n        // Finds the nearest header above the given cell. If the cell is a header itself, it does not return itself;\n        // this can be checked directly by calling functions.\n        if (index >= notebook.widgets.length) {\n            return;\n        }\n        let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);\n        for (let cellN = index - 1; cellN >= 0; cellN--) {\n            if (cellN < notebook.widgets.length) {\n                let hInfo = getHeadingInfo(notebook.widgets[cellN]);\n                if (hInfo.isHeading &&\n                    hInfo.headingLevel < childHeaderInfo.headingLevel) {\n                    return notebook.widgets[cellN];\n                }\n            }\n        }\n        // else no parent header found.\n        return;\n    }\n    /**\n     * Finds the \"parent\" heading of the given cell and expands.\n     * Used for the case that a cell becomes active that is within a collapsed heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function expandParent(cell, notebook) {\n        let nearestParentCell = findNearestParentHeader(cell, notebook);\n        if (!nearestParentCell) {\n            return;\n        }\n        if (!getHeadingInfo(nearestParentCell).collapsed &&\n            !nearestParentCell.isHidden) {\n            return;\n        }\n        if (nearestParentCell.isHidden) {\n            expandParent(nearestParentCell, notebook);\n        }\n        if (getHeadingInfo(nearestParentCell).collapsed) {\n            setHeadingCollapse(nearestParentCell, false, notebook);\n        }\n    }\n    NotebookActions.expandParent = expandParent;\n    /**\n     * Finds the next heading that isn't a child of the given markdown heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function findNextParentHeading(cell, notebook) {\n        let index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return -1;\n        }\n        let childHeaderInfo = getHeadingInfo(cell);\n        for (index = index + 1; index < notebook.widgets.length; index++) {\n            let hInfo = getHeadingInfo(notebook.widgets[index]);\n            if (hInfo.isHeading &&\n                hInfo.headingLevel <= childHeaderInfo.headingLevel) {\n                return index;\n            }\n        }\n        // else no parent header found. return the index of the last cell\n        return notebook.widgets.length;\n    }\n    NotebookActions.findNextParentHeading = findNextParentHeading;\n    /**\n     * Set the given cell and ** all \"child\" cells **\n     * to the given collapse / expand if cell is\n     * a markdown header.\n     *\n     * @param cell - The cell\n     * @param collapsing - Whether to collapse or expand the cell\n     * @param notebook - The target notebook widget.\n     */\n    function setHeadingCollapse(cell, collapsing, notebook) {\n        const which = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (which === -1) {\n            return -1;\n        }\n        if (!notebook.widgets.length) {\n            return which + 1;\n        }\n        let selectedHeadingInfo = NotebookActions.getHeadingInfo(cell);\n        if (cell.isHidden ||\n            !(cell instanceof MarkdownCell) ||\n            !selectedHeadingInfo.isHeading) {\n            // otherwise collapsing and uncollapsing already hidden stuff can\n            // cause some funny looking bugs.\n            return which + 1;\n        }\n        let localCollapsed = false;\n        let localCollapsedLevel = 0;\n        // iterate through all cells after the active cell.\n        let cellNum;\n        for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {\n            let subCell = notebook.widgets[cellNum];\n            let subCellHeadingInfo = NotebookActions.getHeadingInfo(subCell);\n            if (subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {\n                // then reached an equivalent or higher heading level than the\n                // original the end of the collapse.\n                cellNum -= 1;\n                break;\n            }\n            if (localCollapsed &&\n                subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= localCollapsedLevel) {\n                // then reached the end of the local collapsed, so unset NotebookActions.\n                localCollapsed = false;\n            }\n            if (collapsing || localCollapsed) {\n                // then no extra handling is needed for further locally collapsed\n                // headings.\n                subCell.setHidden(true);\n                continue;\n            }\n            if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {\n                localCollapsed = true;\n                localCollapsedLevel = subCellHeadingInfo.headingLevel;\n                // but don't collapse the locally collapsed heading, so continue to\n                // expand the heading. This will get noticed in the next round.\n            }\n            subCell.setHidden(false);\n        }\n        if (cellNum === notebook.widgets.length) {\n            cell.numberChildNodes = cellNum - which - 1;\n        }\n        else {\n            cell.numberChildNodes = cellNum - which;\n        }\n        NotebookActions.setCellCollapse(cell, collapsing);\n        return cellNum + 1;\n    }\n    NotebookActions.setHeadingCollapse = setHeadingCollapse;\n    /**\n     * Toggles the collapse state of the active cell of the given notebook\n     * and ** all of its \"child\" cells ** if the cell is a heading.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function toggleCurrentHeadingCollapse(notebook) {\n        if (!notebook.activeCell || notebook.activeCellIndex === undefined) {\n            return;\n        }\n        let headingInfo = NotebookActions.getHeadingInfo(notebook.activeCell);\n        if (headingInfo.isHeading) {\n            // Then toggle!\n            NotebookActions.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);\n        }\n        ElementExt.scrollIntoViewIfNeeded(notebook.node, notebook.activeCell.node);\n    }\n    NotebookActions.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;\n    /**\n     * If cell is a markdown heading, sets the headingCollapsed field,\n     * and otherwise hides the cell.\n     *\n     * @param cell - The cell to collapse / expand\n     * @param collapsing - Whether to collapse or expand the given cell\n     */\n    function setCellCollapse(cell, collapsing) {\n        if (cell instanceof MarkdownCell) {\n            cell.headingCollapsed = collapsing;\n        }\n        else {\n            cell.setHidden(collapsing);\n        }\n    }\n    NotebookActions.setCellCollapse = setCellCollapse;\n    /**\n     * If given cell is a markdown heading, returns the heading level.\n     * If given cell is not markdown, returns 7 (there are only 6 levels of markdown headings)\n     *\n     * @param cell - The target cell widget.\n     */\n    function getHeadingInfo(cell) {\n        if (!(cell instanceof MarkdownCell)) {\n            return { isHeading: false, headingLevel: 7 };\n        }\n        let level = cell.headingInfo.level;\n        let collapsed = cell.headingCollapsed;\n        return { isHeading: level > 0, headingLevel: level, collapsed: collapsed };\n    }\n    NotebookActions.getHeadingInfo = getHeadingInfo;\n    /**\n     * Trust the notebook after prompting the user.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns a promise that resolves when the transaction is finished.\n     *\n     * #### Notes\n     * No dialog will be presented if the notebook is already trusted.\n     */\n    function trust(notebook, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        if (!notebook.model) {\n            return Promise.resolve();\n        }\n        // Do nothing if already trusted.\n        const cells = toArray(notebook.model.cells);\n        const trusted = cells.every(cell => cell.trusted);\n        // FIXME\n        const trustMessage = (React.createElement(\"p\", null,\n            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you open it.'),\n            React.createElement(\"br\", null),\n            trans.__('Selecting trust will re-render this notebook in a trusted state.'),\n            React.createElement(\"br\", null),\n            trans.__('For more information, see'),\n            ' ',\n            React.createElement(\"a\", { href: \"https://jupyter-server.readthedocs.io/en/stable/operators/security.html\", target: \"_blank\", rel: \"noopener noreferrer\" }, trans.__('the Jupyter security documentation'))));\n        if (trusted) {\n            return showDialog({\n                body: trans.__('Notebook is already trusted'),\n                buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n            }).then(() => undefined);\n        }\n        return showDialog({\n            body: trustMessage,\n            title: trans.__('Trust this notebook?'),\n            buttons: [\n                Dialog.cancelButton({ label: trans.__('Cancel') }),\n                Dialog.warnButton({ label: trans.__('Ok') })\n            ] // FIXME?\n        }).then(result => {\n            if (result.button.accept) {\n                cells.forEach(cell => {\n                    cell.trusted = true;\n                });\n            }\n        });\n    }\n    NotebookActions.trust = trust;\n})(NotebookActions || (NotebookActions = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    Private.executed = new Signal({});\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    Private.executionScheduled = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.selectionExecuted = new Signal({});\n    function isNotebookRendered(notebook) {\n        const translator = notebook.translator;\n        const trans = translator.load('jupyterlab');\n        if (notebook.remainingCellToRenderCount !== 0) {\n            showDialog({\n                body: trans.__(`Notebook is still rendering and has for now (%1) remaining cells to render.\n\nPlease wait for the complete rendering before invoking that action.`, notebook.remainingCellToRenderCount),\n                buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n            }).catch(reason => {\n                console.error('An error occurred when displaying notebook rendering warning', reason);\n            });\n            return false;\n        }\n        return true;\n    }\n    Private.isNotebookRendered = isNotebookRendered;\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCell: notebook.activeCell\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, node } = notebook;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scrollIfNeeded && activeCell) {\n            ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    function handleRunState(notebook, state, scroll = false) {\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scroll && state.activeCell) {\n            // Scroll to the top of the previous active cell output.\n            const rect = state.activeCell.inputArea.node.getBoundingClientRect();\n            notebook.scrollToPosition(rect.bottom, 45);\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Clone a cell model.\n     */\n    function cloneCell(model, cell) {\n        switch (cell.type) {\n            case 'code':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createCodeCell({ cell: cell.toJSON() });\n            case 'markdown':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });\n            default:\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createRawCell({ cell: cell.toJSON() });\n        }\n    }\n    Private.cloneCell = cloneCell;\n    /**\n     * Run the selected cells.\n     */\n    function runSelected(notebook, sessionContext) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext)))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message.startsWith('KernelReplyNotOK')) {\n                selected.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    function runCell(notebook, cell, sessionContext, translator) {\n        var _a, _b, _c;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        switch (cell.model.type) {\n            case 'markdown':\n                cell.rendered = true;\n                cell.inputHidden = false;\n                Private.executed.emit({ notebook, cell, success: true });\n                break;\n            case 'code':\n                if (sessionContext) {\n                    if (sessionContext.isTerminating) {\n                        void showDialog({\n                            title: trans.__('Kernel Terminating'),\n                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        break;\n                    }\n                    if (sessionContext.pendingInput) {\n                        void showDialog({\n                            title: trans.__('Cell not executed due to pending input'),\n                            body: trans.__('The cell has not been executed to avoid kernel deadlock as there is another pending input! Submit your pending input and try again.'),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        return Promise.resolve(false);\n                    }\n                    if (sessionContext.hasNoKernel) {\n                        void sessionContextDialogs.selectKernel(sessionContext);\n                        return Promise.resolve(false);\n                    }\n                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];\n                    Private.executionScheduled.emit({ notebook, cell });\n                    return CodeCell.execute(cell, sessionContext, {\n                        deletedCells,\n                        recordTiming: notebook.notebookConfig.recordTiming\n                    })\n                        .then(reply => {\n                        deletedCells.splice(0, deletedCells.length);\n                        if (cell.isDisposed) {\n                            return false;\n                        }\n                        if (!reply) {\n                            return true;\n                        }\n                        if (reply.content.status === 'ok') {\n                            const content = reply.content;\n                            if (content.payload && content.payload.length) {\n                                handlePayload(content, notebook, cell);\n                            }\n                            return true;\n                        }\n                        else {\n                            throw new KernelError(reply.content);\n                        }\n                    })\n                        .catch(reason => {\n                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                            return false;\n                        }\n                        Private.executed.emit({ notebook, cell, success: false, error: reason });\n                        throw reason;\n                    })\n                        .then(ran => {\n                        if (ran) {\n                            Private.executed.emit({ notebook, cell, success: true });\n                        }\n                        return ran;\n                    });\n                }\n                cell.model.clearExecution();\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * Handle payloads from an execute reply.\n     *\n     * #### Notes\n     * Payloads are deprecated and there are no official interfaces for them in\n     * the kernel type definitions.\n     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n     */\n    function handlePayload(content, notebook, cell) {\n        var _a;\n        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n            return i.source === 'set_next_input';\n        })[0];\n        if (!setNextInput) {\n            return;\n        }\n        const text = setNextInput.text;\n        const replace = setNextInput.replace;\n        if (replace) {\n            cell.model.value.text = text;\n            return;\n        }\n        // Create a new code cell and add as the next cell.\n        const newCell = notebook.model.contentFactory.createCodeCell({});\n        const cells = notebook.model.cells;\n        const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);\n        newCell.value.text = text;\n        if (index === -1) {\n            cells.push(newCell);\n        }\n        else {\n            cells.insert(index + 1, newCell);\n        }\n    }\n    /**\n     * Get the selected cell(s) without affecting the clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns A list of 0 or more selected cells\n     */\n    function selectedCells(notebook) {\n        return notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n    }\n    Private.selectedCells = selectedCells;\n    /**\n     * Copy or cut the selected cell data to the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param cut - True if the cells should be cut, false if they should be copied.\n     */\n    function copyOrCut(notebook, cut) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = getState(notebook);\n        const clipboard = Clipboard.getInstance();\n        notebook.mode = 'command';\n        clipboard.clear();\n        const data = Private.selectedCells(notebook);\n        clipboard.setData(JUPYTER_CELL_MIME, data);\n        if (cut) {\n            deleteCells(notebook);\n        }\n        else {\n            notebook.deselectAll();\n        }\n        if (cut) {\n            notebook.lastClipboardInteraction = 'cut';\n        }\n        else {\n            notebook.lastClipboardInteraction = 'copy';\n        }\n        handleState(notebook, state);\n    }\n    Private.copyOrCut = copyOrCut;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        const model = notebook.model;\n        const cells = model.cells;\n        cells.beginCompoundOperation();\n        notebook.widgets.forEach((child, index) => {\n            if (!notebook.isSelectedOrActive(child)) {\n                return;\n            }\n            if (child.model.type !== value) {\n                const cell = child.model.toJSON();\n                let newCell;\n                switch (value) {\n                    case 'code':\n                        newCell = model.contentFactory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        newCell = model.contentFactory.createMarkdownCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                        break;\n                    default:\n                        newCell = model.contentFactory.createRawCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                }\n                cells.set(index, newCell);\n            }\n            if (value === 'markdown') {\n                // Fetch the new widget and unrender it.\n                child = notebook.widgets[index];\n                child.rendered = false;\n            }\n        });\n        cells.endCompoundOperation();\n        notebook.deselectAll();\n    }\n    Private.changeCellType = changeCellType;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * If the last cell is deleted, then the previous one will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        const model = notebook.model;\n        const cells = model.cells;\n        const toDelete = [];\n        notebook.mode = 'command';\n        // Find the cells to delete.\n        notebook.widgets.forEach((child, index) => {\n            const deletable = child.model.metadata.get('deletable') !== false;\n            if (notebook.isSelectedOrActive(child) && deletable) {\n                toDelete.push(index);\n                model.deletedCells.push(child.model.id);\n            }\n        });\n        // If cells are not deletable, we may not have anything to delete.\n        if (toDelete.length > 0) {\n            // Delete the cells as one undo event.\n            cells.beginCompoundOperation();\n            // Delete cells in reverse order to maintain the correct indices.\n            toDelete.reverse().forEach(index => {\n                cells.remove(index);\n            });\n            // Add a new cell if the notebook is empty. This is done\n            // within the compound operation to make the deletion of\n            // a notebook's last cell undoable.\n            if (!cells.length) {\n                cells.push(model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {}));\n            }\n            cells.endCompoundOperation();\n            // Select the *first* interior cell not deleted or the cell\n            // *after* the last selected cell.\n            // Note: The activeCellIndex is clamped to the available cells,\n            // so if the last cell is deleted the previous cell will be activated.\n            // The *first* index is the index of the last cell in the initial\n            // toDelete list due to the `reverse` operation above.\n            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;\n        }\n        // Deselect any remaining, undeletable cells. Do this even if we don't\n        // delete anything so that users are aware *something* happened.\n        notebook.deselectAll();\n    }\n    Private.deleteCells = deleteCells;\n    /**\n     * Set the markdown header level of a cell.\n     */\n    function setMarkdownHeader(cell, level) {\n        // Remove existing header or leading white space.\n        let source = cell.value.text;\n        const regex = /^(#+\\s*)|^(\\s*)/;\n        const newHeader = Array(level + 1).join('#') + ' ';\n        const matches = regex.exec(source);\n        if (matches) {\n            source = source.slice(matches[0].length);\n        }\n        cell.value.text = newHeader + source;\n    }\n    Private.setMarkdownHeader = setMarkdownHeader;\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { addToolbarButtonClass, Dialog, ReactWidget, sessionContextDialogs, showDialog, Toolbar, ToolbarButton, ToolbarButtonComponent, UseSignal } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { addIcon, copyIcon, cutIcon, fastForwardIcon, HTMLSelect, pasteIcon, runIcon, saveIcon } from '@jupyterlab/ui-components';\nimport * as React from 'react';\nimport { NotebookActions } from './actions';\n/**\n * The class name added to toolbar cell type dropdown wrapper.\n */\nconst TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';\n/**\n * The class name added to toolbar cell type dropdown.\n */\nconst TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';\n/**\n * A namespace for the default toolbar items.\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createSaveButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        function onClick() {\n            if (panel.context.model.readOnly) {\n                return showDialog({\n                    title: trans.__('Cannot Save'),\n                    body: trans.__('Document is read-only'),\n                    buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            void panel.context.save().then(() => {\n                if (!panel.isDisposed) {\n                    return panel.context.createCheckpoint();\n                }\n            });\n        }\n        return addToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: panel.context.fileChanged }, () => (React.createElement(ToolbarButtonComponent, { icon: saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&\n                panel.context &&\n                panel.context.contentsModel &&\n                panel.context.contentsModel.writable) })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n    /**\n     * Create an insert toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createInsertButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                NotebookActions.insertBelow(panel.content);\n            },\n            tooltip: trans.__('Insert a cell below')\n        });\n    }\n    ToolbarItems.createInsertButton = createInsertButton;\n    /**\n     * Create a cut toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCutButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: cutIcon,\n            onClick: () => {\n                NotebookActions.cut(panel.content);\n            },\n            tooltip: trans.__('Cut the selected cells')\n        });\n    }\n    ToolbarItems.createCutButton = createCutButton;\n    /**\n     * Create a copy toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCopyButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: copyIcon,\n            onClick: () => {\n                NotebookActions.copy(panel.content);\n            },\n            tooltip: trans.__('Copy the selected cells')\n        });\n    }\n    ToolbarItems.createCopyButton = createCopyButton;\n    /**\n     * Create a paste toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createPasteButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: pasteIcon,\n            onClick: () => {\n                NotebookActions.paste(panel.content);\n            },\n            tooltip: trans.__('Paste cells from the clipboard')\n        });\n    }\n    ToolbarItems.createPasteButton = createPasteButton;\n    /**\n     * Create a run toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRunButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: runIcon,\n            onClick: () => {\n                void NotebookActions.runAndAdvance(panel.content, panel.sessionContext);\n            },\n            tooltip: trans.__('Run the selected cells and advance')\n        });\n    }\n    ToolbarItems.createRunButton = createRunButton;\n    /**\n     * Create a restart run all toolbar item\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRestartRunAllButton(panel, dialogs, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: fastForwardIcon,\n            onClick: () => {\n                void (dialogs !== null && dialogs !== void 0 ? dialogs : sessionContextDialogs)\n                    .restart(panel.sessionContext, translator)\n                    .then(restarted => {\n                    if (restarted) {\n                        void NotebookActions.runAll(panel.content, panel.sessionContext);\n                    }\n                    return restarted;\n                });\n            },\n            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')\n        });\n    }\n    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;\n    /**\n     * Create a cell type switcher item.\n     *\n     * #### Notes\n     * It will display the type of the current active cell.\n     * If more than one cell is selected but are of different types,\n     * it will display `'-'`.\n     * When the user changes the cell type, it will change the\n     * cell types of the selected cells.\n     * It can handle a change to the context.\n     */\n    function createCellTypeItem(panel, translator) {\n        return new CellTypeSwitcher(panel.content, translator);\n    }\n    ToolbarItems.createCellTypeItem = createCellTypeItem;\n    /**\n     * Get the default toolbar items for panel\n     */\n    function getDefaultItems(panel, sessionDialogs, translator) {\n        return [\n            { name: 'save', widget: createSaveButton(panel, translator) },\n            { name: 'insert', widget: createInsertButton(panel, translator) },\n            { name: 'cut', widget: createCutButton(panel, translator) },\n            { name: 'copy', widget: createCopyButton(panel, translator) },\n            { name: 'paste', widget: createPasteButton(panel, translator) },\n            { name: 'run', widget: createRunButton(panel, translator) },\n            {\n                name: 'interrupt',\n                widget: Toolbar.createInterruptButton(panel.sessionContext, translator)\n            },\n            {\n                name: 'restart',\n                widget: Toolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'restart-and-run',\n                widget: createRestartRunAllButton(panel, sessionDialogs, translator)\n            },\n            { name: 'cellType', widget: createCellTypeItem(panel, translator) },\n            { name: 'spacer', widget: Toolbar.createSpacerItem() },\n            {\n                name: 'kernelName',\n                widget: Toolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)\n            }\n        ];\n    }\n    ToolbarItems.getDefaultItems = getDefaultItems;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A toolbar widget that switches cell types.\n */\nexport class CellTypeSwitcher extends ReactWidget {\n    /**\n     * Construct a new cell type switcher.\n     */\n    constructor(widget, translator) {\n        super();\n        /**\n         * Handle `change` events for the HTMLSelect component.\n         */\n        this.handleChange = (event) => {\n            if (event.target.value !== '-') {\n                NotebookActions.changeCellType(this._notebook, event.target.value);\n                this._notebook.activate();\n            }\n        };\n        /**\n         * Handle `keydown` events for the HTMLSelect component.\n         */\n        this.handleKeyDown = (event) => {\n            if (event.keyCode === 13) {\n                this._notebook.activate();\n            }\n        };\n        this._trans = (translator || nullTranslator).load('jupyterlab');\n        this.addClass(TOOLBAR_CELLTYPE_CLASS);\n        this._notebook = widget;\n        if (widget.model) {\n            this.update();\n        }\n        widget.activeCellChanged.connect(this.update, this);\n        // Follow a change in the selection.\n        widget.selectionChanged.connect(this.update, this);\n    }\n    render() {\n        let value = '-';\n        if (this._notebook.activeCell) {\n            value = this._notebook.activeCell.model.type;\n        }\n        for (const widget of this._notebook.widgets) {\n            if (this._notebook.isSelectedOrActive(widget)) {\n                if (widget.model.type !== value) {\n                    value = '-';\n                    break;\n                }\n            }\n        }\n        return (React.createElement(HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, \"aria-label\": this._trans.__('Cell type'), title: this._trans.__('Select the cell type') },\n            React.createElement(\"option\", { value: \"-\" }, \"-\"),\n            React.createElement(\"option\", { value: \"code\" }, this._trans.__('Code')),\n            React.createElement(\"option\", { value: \"markdown\" }, this._trans.__('Markdown')),\n            React.createElement(\"option\", { value: \"raw\" }, this._trans.__('Raw'))));\n    }\n}\n//# sourceMappingURL=default-toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ObservableMap } from '@jupyterlab/observables';\nimport * as models from '@jupyterlab/shared-models';\nimport { ArrayExt, ArrayIterator, each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList {\n    /**\n     * Construct the cell list.\n     */\n    constructor(modelDB, factory, model) {\n        /**\n         * Prevents that the modeldb event handler is executed when the shared-model event handler is executed and vice-versa.\n         */\n        this._mutex = models.createMutex();\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        this._factory = factory;\n        this._cellOrder = modelDB.createList('cellOrder');\n        this._cellMap = new ObservableMap();\n        this._cellOrder.changed.connect(this._onOrderChanged, this);\n        this.nbmodel = model;\n        this.nbmodel.changed.connect(this.onSharedModelChanged, this);\n        this.changed.connect(this.onModelDBChanged, this);\n    }\n    onModelDBChanged(self, change) {\n        this._mutex(() => {\n            const nbmodel = this.nbmodel;\n            nbmodel.transact(() => {\n                if (change.type === 'set' || change.type === 'remove') {\n                    nbmodel.deleteCellRange(change.oldIndex, change.oldIndex + change.oldValues.length);\n                }\n                if (change.type === 'set' ||\n                    change.type === 'add' ||\n                    change.type === 'move') {\n                    const cells = change.newValues.map(cell => {\n                        return cell.sharedModel.clone();\n                    });\n                    let insertLocation = change.newIndex;\n                    if (change.type === 'move' && insertLocation > change.oldIndex) {\n                        insertLocation += change.oldValues.length;\n                    }\n                    nbmodel.insertCells(insertLocation, cells);\n                    change.newValues.forEach((cell, index) => {\n                        cell.switchSharedModel(cells[index], false);\n                    });\n                }\n                if (change.type === 'move') {\n                    let from = change.oldIndex;\n                    if (from >= change.newIndex) {\n                        from += change.oldValues.length;\n                    }\n                    nbmodel.deleteCellRange(from, from + change.oldValues.length);\n                }\n            });\n        });\n    }\n    onSharedModelChanged(self, change) {\n        this._mutex(() => {\n            var _a;\n            let currpos = 0;\n            (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach(delta => {\n                if (delta.insert != null) {\n                    const cells = delta.insert.map(nbcell => {\n                        const cell = this._factory.createCell(nbcell.cell_type, {});\n                        cell.switchSharedModel(nbcell, true);\n                        return cell;\n                    });\n                    this.insertAll(currpos, cells);\n                    currpos += delta.insert.length;\n                }\n                else if (delta.delete != null) {\n                    this.removeRange(currpos, currpos + delta.delete);\n                }\n                else if (delta.retain != null) {\n                    currpos += delta.retain;\n                }\n            });\n        });\n    }\n    /**\n     * A signal emitted when the cell list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Test whether the cell list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Test whether the list is empty.\n     *\n     * @returns `true` if the cell list is empty, `false` otherwise.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get isEmpty() {\n        return this._cellOrder.length === 0;\n    }\n    /**\n     * Get the length of the cell list.\n     *\n     * @return The number of cells in the cell list.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get length() {\n        return this._cellOrder.length;\n    }\n    /**\n     * Create an iterator over the cells in the cell list.\n     *\n     * @returns A new iterator starting at the front of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        const arr = [];\n        for (const id of toArray(this._cellOrder)) {\n            arr.push(this._cellMap.get(id));\n        }\n        return new ArrayIterator(arr);\n    }\n    /**\n     * Dispose of the resources held by the cell list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        // Clean up the cell map and cell order objects.\n        for (const cell of this._cellMap.values()) {\n            cell.dispose();\n        }\n        this._cellMap.dispose();\n        this._cellOrder.dispose();\n    }\n    /**\n     * Get the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The cell at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._cellMap.get(this._cellOrder.get(index));\n    }\n    /**\n     * Set the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    set(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.set(index, cell.id);\n    }\n    /**\n     * Add a cell to the back of the cell list.\n     *\n     * @param cell - The cell to add to the back of the cell list.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    push(cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        const num = this._cellOrder.push(cell.id);\n        return num;\n    }\n    /**\n     * Insert a cell into the cell list at a specific index.\n     *\n     * @param index - The index at which to insert the cell.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insert(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.insert(index, cell.id);\n    }\n    /**\n     * Remove the first occurrence of a cell from the cell list.\n     *\n     * @param cell - The cell of interest.\n     *\n     * @returns The index of the removed cell, or `-1` if the cell\n     *   is not contained in the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     */\n    removeValue(cell) {\n        const index = ArrayExt.findFirstIndex(toArray(this._cellOrder), id => this._cellMap.get(id) === cell);\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the cell at a specific index.\n     *\n     * @param index - The index of the cell of interest.\n     *\n     * @returns The cell at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const id = this._cellOrder.get(index);\n        this._cellOrder.remove(index);\n        const cell = this._cellMap.get(id);\n        return cell;\n    }\n    /**\n     * Remove all cells from the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        this._cellOrder.clear();\n    }\n    /**\n     * Move a cell from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        this._cellOrder.move(fromIndex, toIndex);\n    }\n    /**\n     * Push a set of cells to the back of the cell list.\n     *\n     * @param cells - An iterable or array-like set of cells to add.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    pushAll(cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            // Set the internal data structures.\n            this._cellMap.set(cell.id, cell);\n            this._cellOrder.push(cell.id);\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the cell list at the specified index.\n     *\n     * @param index - The index at which to insert the cells.\n     *\n     * @param cells - The cells to insert at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insertAll(index, cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            this._cellMap.set(cell.id, cell);\n            // @todo it looks like this compound operation shoult start before the `each` loop.\n            this._cellOrder.beginCompoundOperation();\n            this._cellOrder.insert(index++, cell.id);\n            this._cellOrder.endCompoundOperation();\n        });\n        return this.length;\n    }\n    /**\n     * Remove a range of items from the cell list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed cell and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        this._cellOrder.removeRange(startIndex, endIndex);\n        return this.length;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    get canRedo() {\n        return this.nbmodel.canRedo();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    get canUndo() {\n        return this.nbmodel.canUndo();\n    }\n    /**\n     * Begin a compound operation.\n     *\n     * @param isUndoAble - Whether the operation is undoable.\n     *   The default is `true`.\n     */\n    beginCompoundOperation(isUndoAble) {\n        this._cellOrder.beginCompoundOperation(isUndoAble);\n    }\n    /**\n     * End a compound operation.\n     */\n    endCompoundOperation() {\n        this._cellOrder.endCompoundOperation();\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.nbmodel.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.nbmodel.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndo() {\n        this.nbmodel.clearUndoHistory();\n    }\n    _onOrderChanged(order, change) {\n        if (change.type === 'add' || change.type === 'set') {\n            each(change.newValues, id => {\n                const existingCell = this._cellMap.get(id);\n                if (existingCell == null) {\n                    const cellDB = this._factory.modelDB;\n                    const cellType = cellDB.createValue(id + '.type');\n                    let cell;\n                    switch (cellType.get()) {\n                        case 'code':\n                            cell = this._factory.createCodeCell({ id: id });\n                            break;\n                        case 'markdown':\n                            cell = this._factory.createMarkdownCell({ id: id });\n                            break;\n                        default:\n                            cell = this._factory.createRawCell({ id: id });\n                            break;\n                    }\n                    this._cellMap.set(id, cell);\n                }\n                else if (!existingCell.sharedModel.isStandalone) {\n                    this._mutex(() => {\n                        // it does already exist, probably because it was deleted previously and we introduced it\n                        // copy it to a fresh codecell instance\n                        const cell = existingCell.toJSON();\n                        let freshCell = null;\n                        switch (cell.cell_type) {\n                            case 'code':\n                                freshCell = this._factory.createCodeCell({ cell });\n                                break;\n                            case 'markdown':\n                                freshCell = this._factory.createMarkdownCell({ cell });\n                                break;\n                            default:\n                                freshCell = this._factory.createRawCell({ cell });\n                                break;\n                        }\n                        this._cellMap.set(id, freshCell);\n                    });\n                }\n            });\n        }\n        const newValues = [];\n        const oldValues = [];\n        each(change.newValues, id => {\n            newValues.push(this._cellMap.get(id));\n        });\n        each(change.oldValues, id => {\n            oldValues.push(this._cellMap.get(id));\n        });\n        this._changed.emit({\n            type: change.type,\n            oldIndex: change.oldIndex,\n            newIndex: change.newIndex,\n            oldValues,\n            newValues\n        });\n    }\n}\n//# sourceMappingURL=celllist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCellModel, MarkdownCellModel, RawCellModel } from '@jupyterlab/cells';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { ModelDB } from '@jupyterlab/observables';\nimport * as models from '@jupyterlab/shared-models';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { CellList } from './celllist';\nconst UNSHARED_KEYS = ['kernelspec', 'language_info'];\n/**\n * An implementation of a notebook Model.\n */\nexport class NotebookModel {\n    /**\n     * Construct a new notebook model.\n     */\n    constructor(options = {}) {\n        /**\n         * A mutex to update the shared model.\n         */\n        this._modelDBMutex = models.createMutex();\n        this._readOnly = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._nbformat = nbformat.MAJOR_VERSION;\n        this._nbformatMinor = nbformat.MINOR_VERSION;\n        this._isDisposed = false;\n        if (options.modelDB) {\n            this.modelDB = options.modelDB;\n        }\n        else {\n            this.modelDB = new ModelDB();\n        }\n        this.sharedModel = models.YNotebook.create(options.disableDocumentWideUndoRedo || false);\n        this._isInitialized = options.isInitialized === false ? false : true;\n        const factory = options.contentFactory || NotebookModel.defaultContentFactory;\n        this.contentFactory = factory.clone(this.modelDB.view('cells'));\n        this._cells = new CellList(this.modelDB, this.contentFactory, this.sharedModel);\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        this._cells.changed.connect(this._onCellsChanged, this);\n        // Handle initial metadata.\n        const metadata = this.modelDB.createMap('metadata');\n        if (!metadata.has('language_info')) {\n            const name = options.languagePreference || '';\n            metadata.set('language_info', { name });\n        }\n        this._ensureMetadata();\n        metadata.changed.connect(this._onMetadataChanged, this);\n        this._deletedCells = [];\n        this.sharedModel.dirty = false;\n        this.sharedModel.changed.connect(this._onStateChanged, this);\n    }\n    /**\n     * A signal emitted when the document content changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * A signal emitted when the document state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * The dirty state of the document.\n     */\n    get dirty() {\n        return this.sharedModel.dirty;\n    }\n    set dirty(newValue) {\n        if (newValue === this.dirty) {\n            return;\n        }\n        this.sharedModel.dirty = newValue;\n    }\n    /**\n     * The read only state of the document.\n     */\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(newValue) {\n        if (newValue === this._readOnly) {\n            return;\n        }\n        const oldValue = this._readOnly;\n        this._readOnly = newValue;\n        this.triggerStateChange({ name: 'readOnly', oldValue, newValue });\n    }\n    /**\n     * The metadata associated with the notebook.\n     */\n    get metadata() {\n        return this.modelDB.get('metadata');\n    }\n    /**\n     * Get the observable list of notebook cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /**\n     * The major version number of the nbformat.\n     */\n    get nbformat() {\n        return this._nbformat;\n    }\n    /**\n     * The minor version number of the nbformat.\n     */\n    get nbformatMinor() {\n        return this._nbformatMinor;\n    }\n    /**\n     * The default kernel name of the document.\n     */\n    get defaultKernelName() {\n        const spec = this.metadata.get('kernelspec');\n        return spec ? spec.name : '';\n    }\n    /**\n     * A list of deleted cells for the notebook..\n     */\n    get deletedCells() {\n        return this._deletedCells;\n    }\n    /**\n     * If the model is initialized or not.\n     */\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    /**\n     * The default kernel language of the document.\n     */\n    get defaultKernelLanguage() {\n        const info = this.metadata.get('language_info');\n        return info ? info.name : '';\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        const cells = this.cells;\n        this._cells = null;\n        cells.dispose();\n        this._isDisposed = true;\n        this.modelDB.dispose();\n        Signal.clearData(this);\n    }\n    /**\n     * Serialize the model to a string.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value) {\n        this.fromJSON(JSON.parse(value));\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        var _a, _b;\n        const cells = [];\n        for (let i = 0; i < ((_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i++) {\n            const cell = this.cells.get(i).toJSON();\n            if (this._nbformat === 4 && this._nbformatMinor <= 4) {\n                // strip cell ids if we have notebook format 4.0-4.4\n                delete cell.id;\n            }\n            cells.push(cell);\n        }\n        this._ensureMetadata();\n        const metadata = this.sharedModel.getMetadata();\n        for (const key of this.metadata.keys()) {\n            metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));\n        }\n        return {\n            metadata,\n            nbformat_minor: this._nbformatMinor,\n            nbformat: this._nbformat,\n            cells\n        };\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value) {\n        const cells = [];\n        const factory = this.contentFactory;\n        const useId = value.nbformat === 4 && value.nbformat_minor >= 5;\n        for (const cell of value.cells) {\n            const options = { cell };\n            if (useId) {\n                options.id = cell.id;\n            }\n            switch (cell.cell_type) {\n                case 'code':\n                    cells.push(factory.createCodeCell(options));\n                    break;\n                case 'markdown':\n                    cells.push(factory.createMarkdownCell(options));\n                    break;\n                case 'raw':\n                    cells.push(factory.createRawCell(options));\n                    break;\n                default:\n                    continue;\n            }\n        }\n        this.cells.beginCompoundOperation();\n        this.cells.clear();\n        this.cells.pushAll(cells);\n        this.cells.endCompoundOperation();\n        this.sharedModel.nbformat_minor =\n            nbformat.MINOR_VERSION;\n        this.sharedModel.nbformat = nbformat.MAJOR_VERSION;\n        const origNbformat = value.metadata.orig_nbformat;\n        if (value.nbformat !== this._nbformat) {\n            this.sharedModel.nbformat = value.nbformat;\n        }\n        if (value.nbformat_minor > this._nbformatMinor) {\n            this.sharedModel.nbformat_minor =\n                value.nbformat_minor;\n        }\n        // Alert the user if the format changes.\n        if (origNbformat !== undefined && this._nbformat !== origNbformat) {\n            const newer = this._nbformat > origNbformat;\n            let msg;\n            if (newer) {\n                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\n'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            else {\n                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\nSome features of the original notebook may not be available.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            void showDialog({\n                title: this._trans.__('Notebook converted'),\n                body: msg,\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n        }\n        // Update the metadata.\n        this.metadata.clear();\n        const metadata = value.metadata;\n        for (const key in metadata) {\n            // orig_nbformat is not intended to be stored per spec.\n            if (key === 'orig_nbformat') {\n                continue;\n            }\n            this.metadata.set(key, metadata[key]);\n        }\n        this._ensureMetadata();\n        this.dirty = true;\n    }\n    /**\n     * Initialize the model with its current state.\n     *\n     * # Notes\n     * Adds an empty code cell if the model is empty\n     * and clears undo state.\n     */\n    initialize() {\n        if (!this.cells.length) {\n            const factory = this.contentFactory;\n            this.cells.push(factory.createCodeCell({}));\n        }\n        this._isInitialized = true;\n        this.cells.clearUndo();\n    }\n    /**\n     * Handle a change in the cells list.\n     */\n    _onCellsChanged(list, change) {\n        switch (change.type) {\n            case 'add':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            case 'remove':\n                break;\n            case 'set':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            default:\n                break;\n        }\n        this.triggerContentChange();\n    }\n    _onStateChanged(sender, changes) {\n        if (changes.stateChange) {\n            changes.stateChange.forEach(value => {\n                if (value.name === 'nbformat') {\n                    this._nbformat = value.newValue;\n                }\n                if (value.name === 'nbformatMinor') {\n                    this._nbformatMinor = value.newValue;\n                }\n                if (value.name !== 'dirty' || value.oldValue !== value.newValue) {\n                    this.triggerStateChange(value);\n                }\n            });\n        }\n        if (changes.metadataChange) {\n            const metadata = changes.metadataChange.newValue;\n            this._modelDBMutex(() => {\n                Object.entries(metadata).forEach(([key, value]) => {\n                    this.metadata.set(key, value);\n                });\n            });\n        }\n    }\n    _onMetadataChanged(metadata, change) {\n        if (!UNSHARED_KEYS.includes(change.key)) {\n            this._modelDBMutex(() => {\n                this.sharedModel.updateMetadata(metadata.toJSON());\n            });\n        }\n        this.triggerContentChange();\n    }\n    /**\n     * Make sure we have the required metadata fields.\n     */\n    _ensureMetadata() {\n        const metadata = this.metadata;\n        if (!metadata.has('language_info')) {\n            metadata.set('language_info', { name: '' });\n        }\n        if (!metadata.has('kernelspec')) {\n            metadata.set('kernelspec', { name: '', display_name: '' });\n        }\n    }\n    /**\n     * Trigger a state change signal.\n     */\n    triggerStateChange(args) {\n        this._stateChanged.emit(args);\n    }\n    /**\n     * Trigger a content changed signal.\n     */\n    triggerContentChange() {\n        this._contentChanged.emit(void 0);\n        this.dirty = true;\n    }\n    /**\n     * Whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n}\n/**\n * The namespace for the `NotebookModel` class statics.\n */\n(function (NotebookModel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create a new cell model factory.\n         */\n        constructor(options) {\n            this.codeCellContentFactory =\n                options.codeCellContentFactory || CodeCellModel.defaultContentFactory;\n            this.modelDB = options.modelDB;\n        }\n        /**\n         * Create a new cell by cell type.\n         *\n         * @param type:  the type of the cell to create.\n         *\n         * @param options: the cell creation options.\n         *\n         * #### Notes\n         * This method is intended to be a convenience method to programmatically\n         * call the other cell creation methods in the factory.\n         */\n        createCell(type, options) {\n            switch (type) {\n                case 'code':\n                    return this.createCodeCell(options);\n                case 'markdown':\n                    return this.createMarkdownCell(options);\n                case 'raw':\n                default:\n                    return this.createRawCell(options);\n            }\n        }\n        /**\n         * Create a new code cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new code cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         *   If the contentFactory is not provided, the instance\n         *   `codeCellContentFactory` will be used.\n         */\n        createCodeCell(options) {\n            if (options.contentFactory) {\n                options.contentFactory = this.codeCellContentFactory;\n            }\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new CodeCellModel(options);\n        }\n        /**\n         * Create a new markdown cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new markdown cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createMarkdownCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new MarkdownCellModel(options);\n        }\n        /**\n         * Create a new raw cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new raw cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createRawCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new RawCellModel(options);\n        }\n        /**\n         * Clone the content factory with a new IModelDB.\n         */\n        clone(modelDB) {\n            return new ContentFactory({\n                modelDB: modelDB,\n                codeCellContentFactory: this.codeCellContentFactory\n            });\n        }\n    }\n    NotebookModel.ContentFactory = ContentFactory;\n    /**\n     * The default `ContentFactory` instance.\n     */\n    NotebookModel.defaultContentFactory = new ContentFactory({});\n})(NotebookModel || (NotebookModel = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from './model';\n/**\n * A model factory for notebooks.\n */\nexport class NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options) {\n        this._disposed = false;\n        this._disableDocumentWideUndoRedo =\n            options.disableDocumentWideUndoRedo || false;\n        const codeCellContentFactory = options.codeCellContentFactory;\n        this.contentFactory =\n            options.contentFactory ||\n                new NotebookModel.ContentFactory({ codeCellContentFactory });\n    }\n    /**\n     * Define the disableDocumentWideUndoRedo property.\n     */\n    set disableDocumentWideUndoRedo(disableDocumentWideUndoRedo) {\n        this._disableDocumentWideUndoRedo = disableDocumentWideUndoRedo;\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'notebook';\n    }\n    /**\n     * The content type of the file.\n     */\n    get contentType() {\n        return 'notebook';\n    }\n    /**\n     * The format of the file.\n     */\n    get fileFormat() {\n        return 'json';\n    }\n    /**\n     * Get whether the model factory has been disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the model factory.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(languagePreference, modelDB, isInitialized) {\n        const contentFactory = this.contentFactory;\n        return new NotebookModel({\n            languagePreference,\n            contentFactory,\n            modelDB,\n            isInitialized,\n            disableDocumentWideUndoRedo: this._disableDocumentWideUndoRedo\n        });\n    }\n    /**\n     * Get the preferred kernel language given a path.\n     */\n    preferredLanguage(path) {\n        return '';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport * as React from 'react';\n/**\n * A pure function for rendering a Command/Edit mode component.\n *\n * @param props: the props for rendering the component.\n *\n * @returns a tsx component for command/edit mode.\n */\nfunction CommandEditComponent(props) {\n    const trans = (props.translator || nullTranslator).load('jupyterlab');\n    return (React.createElement(TextItem, { source: trans.__('Mode: %1', props.modeNames[props.notebookMode]) }));\n}\n/**\n * StatusBar item to display which notebook mode user is in.\n */\nexport class CommandEditStatus extends VDomRenderer {\n    /**\n     * Construct a new CommandEdit status item.\n     */\n    constructor(translator) {\n        super(new CommandEditStatus.Model());\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._modeNames = {\n            command: this._trans.__('Command'),\n            edit: this._trans.__('Edit')\n        };\n    }\n    /**\n     * Render the CommandEdit status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = this._trans.__('Notebook is in %1 mode', this._modeNames[this.model.notebookMode]);\n        return (React.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator, modeNames: this._modeNames }));\n    }\n}\n/**\n * A namespace for CommandEdit statics.\n */\n(function (CommandEditStatus) {\n    /**\n     * A VDomModel for the CommandEdit renderer.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            /**\n             * On a change to the notebook, update the mode.\n             */\n            this._onChanged = (_notebook) => {\n                const oldMode = this._notebookMode;\n                if (this._notebook) {\n                    this._notebookMode = _notebook.mode;\n                }\n                else {\n                    this._notebookMode = 'command';\n                }\n                this._triggerChange(oldMode, this._notebookMode);\n            };\n            this._notebookMode = 'command';\n            this._notebook = null;\n        }\n        /**\n         * The current mode of the current notebook.\n         */\n        get notebookMode() {\n            return this._notebookMode;\n        }\n        /**\n         * Set the current notebook for the model.\n         */\n        set notebook(notebook) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.stateChanged.disconnect(this._onChanged, this);\n                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);\n            }\n            const oldMode = this._notebookMode;\n            this._notebook = notebook;\n            if (this._notebook === null) {\n                this._notebookMode = 'command';\n            }\n            else {\n                this._notebookMode = this._notebook.mode;\n                this._notebook.stateChanged.connect(this._onChanged, this);\n                this._notebook.activeCellChanged.connect(this._onChanged, this);\n                this._notebook.modelContentChanged.connect(this._onChanged, this);\n            }\n            this._triggerChange(oldMode, this._notebookMode);\n        }\n        /**\n         * Trigger a state change for the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState !== newState) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    CommandEditStatus.Model = Model;\n})(CommandEditStatus || (CommandEditStatus = {}));\n//# sourceMappingURL=modestatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Collapse, Styling } from '@jupyterlab/apputils';\nimport { CodeEditor, CodeEditorWrapper, JSONEditor } from '@jupyterlab/codeeditor';\nimport { ObservableJSON } from '@jupyterlab/observables';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, chain, each } from '@lumino/algorithm';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nclass RankedPanel extends Widget {\n    constructor() {\n        super();\n        this._items = [];\n        this.layout = new PanelLayout();\n        this.addClass('jp-RankedPanel');\n    }\n    addWidget(widget, rank) {\n        const rankItem = { widget, rank };\n        const index = ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);\n        ArrayExt.insert(this._items, index, rankItem);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n    }\n    /**\n     * Handle the removal of a child\n     *\n     */\n    onChildRemoved(msg) {\n        const index = ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);\n        if (index !== -1) {\n            ArrayExt.removeAt(this._items, index);\n        }\n    }\n}\n/**\n * A widget that provides metadata tools.\n */\nexport class NotebookTools extends Widget {\n    /**\n     * Construct a new NotebookTools object.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-NotebookTools');\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._commonTools = new RankedPanel();\n        this._advancedTools = new RankedPanel();\n        this._advancedTools.title.label = this._trans.__('Advanced Tools');\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(this._commonTools);\n        layout.addWidget(new Collapse({ widget: this._advancedTools }));\n        this._tracker = options.tracker;\n        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);\n        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);\n        this._onActiveNotebookPanelChanged();\n        this._onActiveCellChanged();\n        this._onSelectionChanged();\n    }\n    /**\n     * The active cell widget.\n     */\n    get activeCell() {\n        return this._tracker.activeCell;\n    }\n    /**\n     * The currently selected cells.\n     */\n    get selectedCells() {\n        const panel = this._tracker.currentWidget;\n        if (!panel) {\n            return [];\n        }\n        const notebook = panel.content;\n        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));\n    }\n    /**\n     * The current notebook.\n     */\n    get activeNotebookPanel() {\n        return this._tracker.currentWidget;\n    }\n    /**\n     * Add a cell tool item.\n     */\n    addItem(options) {\n        var _a;\n        const tool = options.tool;\n        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;\n        let section;\n        if (options.section === 'advanced') {\n            section = this._advancedTools;\n        }\n        else {\n            section = this._commonTools;\n        }\n        tool.addClass('jp-NotebookTools-tool');\n        section.addWidget(tool, rank);\n        // TODO: perhaps the necessary notebookTools functionality should be\n        // consolidated into a single object, rather than a broad reference to this.\n        tool.notebookTools = this;\n        // Trigger the tool to update its active notebook and cell.\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);\n    }\n    /**\n     * Handle a change to the notebook panel.\n     */\n    _onActiveNotebookPanelChanged() {\n        if (this._prevActiveNotebookModel &&\n            !this._prevActiveNotebookModel.isDisposed) {\n            this._prevActiveNotebookModel.metadata.changed.disconnect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content\n            ? this.activeNotebookPanel.content.model\n            : null;\n        this._prevActiveNotebookModel = activeNBModel;\n        if (activeNBModel) {\n            activeNBModel.metadata.changed.connect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);\n        });\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    _onActiveCellChanged() {\n        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {\n            this._prevActiveCell.metadata.changed.disconnect(this._onActiveCellMetadataChanged, this);\n        }\n        const activeCell = this.activeCell ? this.activeCell.model : null;\n        this._prevActiveCell = activeCell;\n        if (activeCell) {\n            activeCell.metadata.changed.connect(this._onActiveCellMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);\n        });\n    }\n    /**\n     * Handle a change in the selection.\n     */\n    _onSelectionChanged() {\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);\n        });\n    }\n    /**\n     * Handle a change in the active cell metadata.\n     */\n    _onActiveNotebookPanelMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    /**\n     * Handle a change in the notebook model metadata.\n     */\n    _onActiveCellMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activecell-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    _toolChildren() {\n        return chain(this._commonTools.children(), this._advancedTools.children());\n    }\n}\n/**\n * The namespace for NotebookTools class statics.\n */\n(function (NotebookTools) {\n    /**\n     * A singleton conflatable `'activenotebookpanel-changed'` message.\n     */\n    NotebookTools.ActiveNotebookPanelMessage = new ConflatableMessage('activenotebookpanel-changed');\n    /**\n     * A singleton conflatable `'activecell-changed'` message.\n     */\n    NotebookTools.ActiveCellMessage = new ConflatableMessage('activecell-changed');\n    /**\n     * A singleton conflatable `'selection-changed'` message.\n     */\n    NotebookTools.SelectionMessage = new ConflatableMessage('selection-changed');\n    /**\n     * The base notebook tool, meant to be subclassed.\n     */\n    class Tool extends Widget {\n        dispose() {\n            super.dispose();\n            if (this.notebookTools) {\n                this.notebookTools = null;\n            }\n        }\n        /**\n         * Process a message sent to the widget.\n         *\n         * @param msg - The message sent to the widget.\n         */\n        processMessage(msg) {\n            super.processMessage(msg);\n            switch (msg.type) {\n                case 'activenotebookpanel-changed':\n                    this.onActiveNotebookPanelChanged(msg);\n                    break;\n                case 'activecell-changed':\n                    this.onActiveCellChanged(msg);\n                    break;\n                case 'selection-changed':\n                    this.onSelectionChanged(msg);\n                    break;\n                case 'activecell-metadata-changed':\n                    this.onActiveCellMetadataChanged(msg);\n                    break;\n                case 'activenotebookpanel-metadata-changed':\n                    this.onActiveNotebookPanelMetadataChanged(msg);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle a change to the notebook panel.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the selection.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onSelectionChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellMetadataChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            /* no-op */\n        }\n    }\n    NotebookTools.Tool = Tool;\n    /**\n     * A cell tool displaying the active cell contents.\n     */\n    class ActiveCellTool extends Tool {\n        /**\n         * Construct a new active cell tool.\n         */\n        constructor() {\n            super();\n            this._model = new CodeEditor.Model();\n            this.addClass('jp-ActiveCellTool');\n            this.addClass('jp-InputArea');\n            this.layout = new PanelLayout();\n        }\n        /**\n         * Dispose of the resources used by the tool.\n         */\n        dispose() {\n            if (this._model === null) {\n                return;\n            }\n            this._model.dispose();\n            this._model = null;\n            super.dispose();\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            const layout = this.layout;\n            const count = layout.widgets.length;\n            for (let i = 0; i < count; i++) {\n                layout.widgets[0].dispose();\n            }\n            if (this._cellModel && !this._cellModel.isDisposed) {\n                this._cellModel.value.changed.disconnect(this._onValueChanged, this);\n                this._cellModel.mimeTypeChanged.disconnect(this._onMimeTypeChanged, this);\n            }\n            if (!activeCell) {\n                const cell = new Widget();\n                cell.addClass('jp-InputArea-editor');\n                cell.addClass('jp-InputArea-editor');\n                layout.addWidget(cell);\n                this._cellModel = null;\n                return;\n            }\n            const promptNode = activeCell.promptNode\n                ? activeCell.promptNode.cloneNode(true)\n                : undefined;\n            const prompt = new Widget({ node: promptNode });\n            const factory = activeCell.contentFactory.editorFactory;\n            const cellModel = (this._cellModel = activeCell.model);\n            cellModel.value.changed.connect(this._onValueChanged, this);\n            cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);\n            this._model.value.text = cellModel.value.text.split('\\n')[0];\n            this._model.mimeType = cellModel.mimeType;\n            const model = this._model;\n            const editorWidget = new CodeEditorWrapper({ model, factory });\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.editor.setOption('readOnly', true);\n            layout.addWidget(prompt);\n            layout.addWidget(editorWidget);\n        }\n        /**\n         * Handle a change to the current editor value.\n         */\n        _onValueChanged() {\n            this._model.value.text = this._cellModel.value.text.split('\\n')[0];\n        }\n        /**\n         * Handle a change to the current editor mimetype.\n         */\n        _onMimeTypeChanged() {\n            this._model.mimeType = this._cellModel.mimeType;\n        }\n    }\n    NotebookTools.ActiveCellTool = ActiveCellTool;\n    /**\n     * A raw metadata editor.\n     */\n    class MetadataEditorTool extends Tool {\n        /**\n         * Construct a new raw metadata tool.\n         */\n        constructor(options) {\n            super();\n            const { editorFactory } = options;\n            this.addClass('jp-MetadataEditorTool');\n            const layout = (this.layout = new PanelLayout());\n            this.editor = new JSONEditor({\n                editorFactory\n            });\n            this.editor.title.label = options.label || 'Edit Metadata';\n            const titleNode = new Widget({ node: document.createElement('label') });\n            titleNode.node.textContent = options.label || 'Edit Metadata';\n            layout.addWidget(titleNode);\n            layout.addWidget(this.editor);\n        }\n    }\n    NotebookTools.MetadataEditorTool = MetadataEditorTool;\n    /**\n     * A notebook metadata editor\n     */\n    class NotebookMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Notebook Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the notebook.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the notebook metadata.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            var _a, _b;\n            const nb = this.notebookTools.activeNotebookPanel &&\n                this.notebookTools.activeNotebookPanel.content;\n            this.editor.source = (_b = (_a = nb === null || nb === void 0 ? void 0 : nb.model) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : null;\n        }\n    }\n    NotebookTools.NotebookMetadataEditorTool = NotebookMetadataEditorTool;\n    /**\n     * A cell metadata editor\n     */\n    class CellMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Cell Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the active cell metadata.\n         */\n        onActiveCellMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            const cell = this.notebookTools.activeCell;\n            this.editor.source = cell ? cell.model.metadata : null;\n        }\n    }\n    NotebookTools.CellMetadataEditorTool = CellMetadataEditorTool;\n    /**\n     * A cell tool that provides a selection for a given metadata key.\n     */\n    class KeySelector extends Tool {\n        /**\n         * Construct a new KeySelector.\n         */\n        constructor(options) {\n            // TODO: use react\n            super({ node: Private.createSelectorNode(options) });\n            /**\n             * Get the value for the data.\n             */\n            this._getValue = (cell) => {\n                let value = cell.model.metadata.get(this.key);\n                if (value === undefined) {\n                    value = this._default;\n                }\n                return value;\n            };\n            /**\n             * Set the value for the data.\n             */\n            this._setValue = (cell, value) => {\n                if (value === this._default) {\n                    cell.model.metadata.delete(this.key);\n                }\n                else {\n                    cell.model.metadata.set(this.key, value);\n                }\n            };\n            this._changeGuard = false;\n            this.addClass('jp-KeySelector');\n            this.key = options.key;\n            this._default = options.default;\n            this._validCellTypes = options.validCellTypes || [];\n            this._getter = options.getter || this._getValue;\n            this._setter = options.setter || this._setValue;\n        }\n        /**\n         * The select node for the widget.\n         */\n        get selectNode() {\n            return this.node.getElementsByTagName('select')[0];\n        }\n        /**\n         * Handle the DOM events for the widget.\n         *\n         * @param event - The DOM event sent to the widget.\n         *\n         * #### Notes\n         * This method implements the DOM `EventListener` interface and is\n         * called in response to events on the notebook panel's node. It should\n         * not be called directly by user code.\n         */\n        handleEvent(event) {\n            switch (event.type) {\n                case 'change':\n                    this.onValueChanged();\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle `after-attach` messages for the widget.\n         */\n        onAfterAttach(msg) {\n            const node = this.selectNode;\n            node.addEventListener('change', this);\n        }\n        /**\n         * Handle `before-detach` messages for the widget.\n         */\n        onBeforeDetach(msg) {\n            const node = this.selectNode;\n            node.removeEventListener('change', this);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            const select = this.selectNode;\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell) {\n                select.disabled = true;\n                select.value = '';\n                return;\n            }\n            const cellType = activeCell.model.type;\n            if (this._validCellTypes.length &&\n                this._validCellTypes.indexOf(cellType) === -1) {\n                select.value = '';\n                select.disabled = true;\n                return;\n            }\n            select.disabled = false;\n            this._changeGuard = true;\n            const getter = this._getter;\n            select.value = JSON.stringify(getter(activeCell));\n            this._changeGuard = false;\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         */\n        onActiveCellMetadataChanged(msg) {\n            if (this._changeGuard) {\n                return;\n            }\n            const select = this.selectNode;\n            const cell = this.notebookTools.activeCell;\n            if (msg.args.key === this.key && cell) {\n                this._changeGuard = true;\n                const getter = this._getter;\n                select.value = JSON.stringify(getter(cell));\n                this._changeGuard = false;\n            }\n        }\n        /**\n         * Handle a change to the value.\n         */\n        onValueChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell || this._changeGuard) {\n                return;\n            }\n            this._changeGuard = true;\n            const select = this.selectNode;\n            const setter = this._setter;\n            setter(activeCell, JSON.parse(select.value));\n            this._changeGuard = false;\n        }\n    }\n    NotebookTools.KeySelector = KeySelector;\n    /**\n     * Create a slideshow selector.\n     */\n    function createSlideShowSelector(translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        trans.__('');\n        const options = {\n            key: 'slideshow',\n            title: trans.__('Slide Type'),\n            optionValueArray: [\n                ['-', null],\n                [trans.__('Slide'), 'slide'],\n                [trans.__('Sub-Slide'), 'subslide'],\n                [trans.__('Fragment'), 'fragment'],\n                [trans.__('Skip'), 'skip'],\n                [trans.__('Notes'), 'notes']\n            ],\n            getter: cell => {\n                const value = cell.model.metadata.get('slideshow');\n                return value && value['slide_type'];\n            },\n            setter: (cell, value) => {\n                let data = cell.model.metadata.get('slideshow') || Object.create(null);\n                if (value === null) {\n                    // Make a shallow copy so we aren't modifying the original metadata.\n                    data = Object.assign({}, data);\n                    delete data.slide_type;\n                }\n                else {\n                    data = Object.assign(Object.assign({}, data), { slide_type: value });\n                }\n                if (Object.keys(data).length > 0) {\n                    cell.model.metadata.set('slideshow', data);\n                }\n                else {\n                    cell.model.metadata.delete('slideshow');\n                }\n            }\n        };\n        return new KeySelector(options);\n    }\n    NotebookTools.createSlideShowSelector = createSlideShowSelector;\n    /**\n     * Create an nbconvert selector.\n     */\n    function createNBConvertSelector(optionValueArray, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        return new KeySelector({\n            key: 'raw_mimetype',\n            title: trans.__('Raw NBConvert Format'),\n            optionValueArray: optionValueArray,\n            validCellTypes: ['raw']\n        });\n    }\n    NotebookTools.createNBConvertSelector = createNBConvertSelector;\n})(NotebookTools || (NotebookTools = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A comparator function for widget rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n    /**\n     * Create the node for a KeySelector.\n     */\n    function createSelectorNode(options) {\n        const name = options.key;\n        const title = options.title || name[0].toLocaleUpperCase() + name.slice(1);\n        const optionNodes = [];\n        let value;\n        let option;\n        each(options.optionValueArray, item => {\n            option = item[0];\n            value = JSON.stringify(item[1]);\n            optionNodes.push(h.option({ value }, option));\n        });\n        const node = VirtualDOM.realize(h.div({}, h.label(title, h.select({}, optionNodes))));\n        Styling.styleNode(node);\n        return node;\n    }\n    Private.createSelectorNode = createSelectorNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=notebooktools.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';\nimport { CodeEditor } from '@jupyterlab/codeeditor';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, each, findIndex } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Drag } from '@lumino/dragdrop';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * The class name added to notebook widgets.\n */\nconst NB_CLASS = 'jp-Notebook';\n/**\n * The class name added to notebook widget cells.\n */\nconst NB_CELL_CLASS = 'jp-Notebook-cell';\n/**\n * The class name added to a notebook in edit mode.\n */\nconst EDIT_CLASS = 'jp-mod-editMode';\n/**\n * The class name added to a notebook in command mode.\n */\nconst COMMAND_CLASS = 'jp-mod-commandMode';\n/**\n * The class name added to the active cell.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class name added to selected cells.\n */\nconst SELECTED_CLASS = 'jp-mod-selected';\n/**\n * The class name added to an active cell when there are other selected cells.\n */\nconst OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';\n/**\n * The class name added to unconfined images.\n */\nconst UNCONFINED_CLASS = 'jp-mod-unconfined';\n/**\n * The class name added to a drop target.\n */\nconst DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The class name added to a drop source.\n */\nconst DROP_SOURCE_CLASS = 'jp-mod-dropSource';\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * The class attached to the heading collapser button\n */\nconst HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';\nconst SIDE_BY_SIDE_CLASS = 'jp-mod-sideBySide';\nif (window.requestIdleCallback === undefined) {\n    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout\n    window.requestIdleCallback = function (handler) {\n        let startTime = Date.now();\n        return setTimeout(function () {\n            handler({\n                didTimeout: false,\n                timeRemaining: function () {\n                    return Math.max(0, 50.0 - (Date.now() - startTime));\n                }\n            });\n        }, 1);\n    };\n    window.cancelIdleCallback = function (id) {\n        clearTimeout(id);\n    };\n}\n/**\n * A widget which renders static non-interactive notebooks.\n *\n * #### Notes\n * The widget model must be set separately and can be changed\n * at any time.  Consumers of the widget must account for a\n * `null` model, and may want to listen to the `modelChanged`\n * signal.\n */\nexport class StaticNotebook extends Widget {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        var _a, _b;\n        super();\n        this._editorConfig = StaticNotebook.defaultEditorConfig;\n        this._notebookConfig = StaticNotebook.defaultNotebookConfig;\n        this._mimetype = 'text/plain';\n        this._model = null;\n        this._modelChanged = new Signal(this);\n        this._modelContentChanged = new Signal(this);\n        this._fullyRendered = new Signal(this);\n        this._placeholderCellRendered = new Signal(this);\n        this._renderedCellsCount = 0;\n        this._renderingLayoutChanged = new Signal(this);\n        this.addClass(NB_CLASS);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.rendermime = options.rendermime;\n        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;\n        this.layout = new Private.NotebookPanelLayout();\n        this.contentFactory =\n            options.contentFactory || StaticNotebook.defaultContentFactory;\n        this.editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this.notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._mimetypeService = options.mimeTypeService;\n        this.renderingLayout = (_b = options.notebookConfig) === null || _b === void 0 ? void 0 : _b.renderingLayout;\n        // Section for the virtual-notebook behavior.\n        this._idleCallBack = null;\n        this._toRenderMap = new Map();\n        if ('IntersectionObserver' in window) {\n            this._observer = new IntersectionObserver((entries, observer) => {\n                entries.forEach(o => {\n                    if (o.isIntersecting) {\n                        observer.unobserve(o.target);\n                        const ci = this._toRenderMap.get(o.target.id);\n                        if (ci) {\n                            const { cell, index } = ci;\n                            this._renderPlaceholderCell(cell, index);\n                        }\n                    }\n                });\n            }, {\n                root: this.node,\n                threshold: 1,\n                rootMargin: `${this.notebookConfig.observedTopMargin} 0px ${this.notebookConfig.observedBottomMargin} 0px`\n            });\n        }\n    }\n    /**\n     * A signal emitted when the notebook is fully rendered.\n     */\n    get fullyRendered() {\n        return this._fullyRendered;\n    }\n    /**\n     * A signal emitted when the a placeholder cell is rendered.\n     */\n    get placeholderCellRendered() {\n        return this._placeholderCellRendered;\n    }\n    /**\n     * A signal emitted when the model of the notebook changes.\n     */\n    get modelChanged() {\n        return this._modelChanged;\n    }\n    /**\n     * A signal emitted when the model content changes.\n     *\n     * #### Notes\n     * This is a convenience signal that follows the current model.\n     */\n    get modelContentChanged() {\n        return this._modelContentChanged;\n    }\n    /**\n     * A signal emitted when the rendering layout of the notebook changes.\n     */\n    get renderingLayoutChanged() {\n        return this._renderingLayoutChanged;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(newValue) {\n        newValue = newValue || null;\n        if (this._model === newValue) {\n            return;\n        }\n        const oldValue = this._model;\n        this._model = newValue;\n        if (oldValue && oldValue.modelDB.isCollaborative) {\n            void oldValue.modelDB.connected.then(() => {\n                oldValue.modelDB.collaborators.changed.disconnect(this._onCollaboratorsChanged, this);\n            });\n        }\n        if (newValue && newValue.modelDB.isCollaborative) {\n            void newValue.modelDB.connected.then(() => {\n                newValue.modelDB.collaborators.changed.connect(this._onCollaboratorsChanged, this);\n            });\n        }\n        // Trigger private, protected, and public changes.\n        this._onModelChanged(oldValue, newValue);\n        this.onModelChanged(oldValue, newValue);\n        this._modelChanged.emit(void 0);\n    }\n    /**\n     * Get the mimetype for code cells.\n     */\n    get codeMimetype() {\n        return this._mimetype;\n    }\n    /**\n     * A read-only sequence of the widgets in the notebook.\n     */\n    get widgets() {\n        return this.layout.widgets;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n        this._updateEditorConfig();\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n        this._updateNotebookConfig();\n    }\n    get renderingLayout() {\n        return this._renderingLayout;\n    }\n    set renderingLayout(value) {\n        var _a;\n        this._renderingLayout = value;\n        if (this._renderingLayout === 'side-by-side') {\n            this.node.classList.add(SIDE_BY_SIDE_CLASS);\n        }\n        else {\n            this.node.classList.remove(SIDE_BY_SIDE_CLASS);\n        }\n        this._renderingLayoutChanged.emit((_a = this._renderingLayout) !== null && _a !== void 0 ? _a : 'default');\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._model = null;\n        super.dispose();\n    }\n    /**\n     * Handle a new model.\n     *\n     * #### Notes\n     * This method is called after the model change has been handled\n     * internally and before the `modelChanged` signal is emitted.\n     * The default implementation is a no-op.\n     */\n    onModelChanged(oldValue, newValue) {\n        // No-op.\n    }\n    /**\n     * Handle changes to the notebook model content.\n     *\n     * #### Notes\n     * The default implementation emits the `modelContentChanged` signal.\n     */\n    onModelContentChanged(model, args) {\n        this._modelContentChanged.emit(void 0);\n    }\n    /**\n     * Handle changes to the notebook model metadata.\n     *\n     * #### Notes\n     * The default implementation updates the mimetypes of the code cells\n     * when the `language_info` metadata changes.\n     */\n    onMetadataChanged(sender, args) {\n        switch (args.key) {\n            case 'language_info':\n                this._updateMimetype();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     *\n     * The default implementation is a no-op\n     */\n    onCellInserted(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being moved.\n     *\n     * The default implementation is a no-op\n     */\n    onCellMoved(fromIndex, toIndex) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being removed.\n     *\n     * The default implementation is a no-op\n     */\n    onCellRemoved(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a new model on the widget.\n     */\n    _onModelChanged(oldValue, newValue) {\n        const layout = this.layout;\n        if (oldValue) {\n            oldValue.cells.changed.disconnect(this._onCellsChanged, this);\n            oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);\n            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);\n            // TODO: reuse existing cell widgets if possible. Remember to initially\n            // clear the history of each cell if we do this.\n            while (layout.widgets.length) {\n                this._removeCell(0);\n            }\n        }\n        if (!newValue) {\n            this._mimetype = 'text/plain';\n            return;\n        }\n        this._updateMimetype();\n        const cells = newValue.cells;\n        if (!cells.length && newValue.isInitialized) {\n            cells.push(newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n        }\n        each(cells, (cell, i) => {\n            this._insertCell(i, cell, 'set');\n        });\n        cells.changed.connect(this._onCellsChanged, this);\n        newValue.contentChanged.connect(this.onModelContentChanged, this);\n        newValue.metadata.changed.connect(this.onMetadataChanged, this);\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        let index = 0;\n        switch (args.type) {\n            case 'add':\n                index = args.newIndex;\n                // eslint-disable-next-line no-case-declarations\n                const insertType = args.oldIndex == -1 ? 'push' : 'insert';\n                each(args.newValues, value => {\n                    this._insertCell(index++, value, insertType);\n                });\n                break;\n            case 'move':\n                this._moveCell(args.oldIndex, args.newIndex);\n                break;\n            case 'remove':\n                each(args.oldValues, value => {\n                    this._removeCell(args.oldIndex);\n                });\n                // Add default cell if there are no cells remaining.\n                if (!sender.length) {\n                    const model = this.model;\n                    // Add the cell in a new context to avoid triggering another\n                    // cell changed event during the handling of this signal.\n                    requestAnimationFrame(() => {\n                        if (model && !model.isDisposed && !model.cells.length) {\n                            model.cells.push(model.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n                        }\n                    });\n                }\n                break;\n            case 'set':\n                // TODO: reuse existing widgets if possible.\n                index = args.newIndex;\n                each(args.newValues, value => {\n                    // Note: this ordering (insert then remove)\n                    // is important for getting the active cell\n                    // index for the editable notebook correct.\n                    this._insertCell(index, value, 'set');\n                    this._removeCell(index + 1);\n                    index++;\n                });\n                break;\n            default:\n                return;\n        }\n    }\n    /**\n     * Create a cell widget and insert into the notebook.\n     */\n    _insertCell(index, cell, insertType) {\n        let widget;\n        switch (cell.type) {\n            case 'code':\n                widget = this._createCodeCell(cell);\n                widget.model.mimeType = this._mimetype;\n                break;\n            case 'markdown':\n                widget = this._createMarkdownCell(cell);\n                if (cell.value.text === '') {\n                    widget.rendered = false;\n                }\n                break;\n            default:\n                widget = this._createRawCell(cell);\n        }\n        widget.addClass(NB_CELL_CLASS);\n        const layout = this.layout;\n        if (this._observer &&\n            insertType === 'push' &&\n            this._renderedCellsCount >=\n                this.notebookConfig.numberCellsToRenderDirectly &&\n            cell.type !== 'markdown') {\n            // We have an observer and we are have been asked to push (not to insert).\n            // and we are above the number of cells to render directly, then\n            // we will add a placeholder and let the intersection observer or the\n            // idle browser render those placeholder cells.\n            this._toRenderMap.set(widget.model.id, { index: index, cell: widget });\n            const placeholder = this._createPlaceholderCell(cell, index);\n            placeholder.node.id = widget.model.id;\n            layout.insertWidget(index, placeholder);\n            this.onCellInserted(index, placeholder);\n            this._fullyRendered.emit(false);\n            this._observer.observe(placeholder.node);\n        }\n        else {\n            // We have no intersection observer, or we insert, or we are below\n            // the number of cells to render directly, so we render directly.\n            layout.insertWidget(index, widget);\n            this.onCellInserted(index, widget);\n            this._incrementRenderedCount();\n        }\n        this._scheduleCellRenderOnIdle();\n    }\n    _scheduleCellRenderOnIdle() {\n        if (this._observer &&\n            this.notebookConfig.renderCellOnIdle &&\n            !this.isDisposed) {\n            if (!this._idleCallBack) {\n                const renderPlaceholderCells = this._renderPlaceholderCells.bind(this);\n                this._idleCallBack = window.requestIdleCallback(renderPlaceholderCells, {\n                    timeout: 3000\n                });\n            }\n        }\n    }\n    _renderPlaceholderCells(deadline) {\n        var _a, _b;\n        if (this.notebookConfig.remainingTimeBeforeRescheduling > 0) {\n            const timeRemaining = deadline.timeRemaining();\n            // In case this got triggered because of timeout or when there are screen updates (https://w3c.github.io/requestidlecallback/#idle-periods),\n            // avoiding the render and rescheduling the place holder cell rendering.\n            if (deadline.didTimeout ||\n                timeRemaining < this.notebookConfig.remainingTimeBeforeRescheduling) {\n                if (this._idleCallBack) {\n                    window.cancelIdleCallback(this._idleCallBack);\n                    this._idleCallBack = null;\n                }\n                this._scheduleCellRenderOnIdle();\n            }\n        }\n        if (this._renderedCellsCount < ((_b = (_a = this.model) === null || _a === void 0 ? void 0 : _a.cells.length) !== null && _b !== void 0 ? _b : 0) &&\n            this._renderedCellsCount >=\n                this.notebookConfig.numberCellsToRenderDirectly) {\n            const ci = this._toRenderMap.entries().next();\n            this._renderPlaceholderCell(ci.value[1].cell, ci.value[1].index);\n        }\n    }\n    _renderPlaceholderCell(cell, index) {\n        // We don't have cancel mechanism for scheduled requestIdleCallback(renderPlaceholderCells),\n        // adding defensive check for layout in case tab is closed.\n        if (!this.layout) {\n            return;\n        }\n        const pl = this.layout;\n        pl.removeWidgetAt(index);\n        pl.insertWidget(index, cell);\n        this._toRenderMap.delete(cell.model.id);\n        this._incrementRenderedCount();\n        this.onCellInserted(index, cell);\n        this._placeholderCellRendered.emit(cell);\n    }\n    /**\n     * Create a code cell widget from a code cell model.\n     */\n    _createCodeCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.code;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false,\n            maxNumberOutputs: this.notebookConfig.maxNumberOutputs\n        };\n        const cell = this.contentFactory.createCodeCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        cell.syncScrolled = true;\n        return cell;\n    }\n    /**\n     * Create a markdown cell widget from a markdown cell model.\n     */\n    _createMarkdownCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.markdown;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false,\n            showEditorForReadOnlyMarkdown: this._notebookConfig\n                .showEditorForReadOnlyMarkdown\n        };\n        const cell = this.contentFactory.createMarkdownCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        // Connect collapsed signal for each markdown cell widget\n        cell.toggleCollapsedSignal.connect((newCell, collapsed) => {\n            NotebookActions.setHeadingCollapse(newCell, collapsed, this);\n        });\n        return cell;\n    }\n    /**\n     * Create a placeholder cell widget from a raw cell model.\n     */\n    _createPlaceholderCell(model, index) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: true\n        };\n        const cell = this.contentFactory.createRawCell(options, this);\n        cell.node.innerHTML = `\n      <div class=\"jp-Cell-Placeholder\">\n        <div class=\"jp-Cell-Placeholder-wrapper\">\n        </div>\n      </div>`;\n        cell.inputHidden = true;\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Create a raw cell widget from a raw cell model.\n     */\n    _createRawCell(model) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false\n        };\n        const cell = this.contentFactory.createRawCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Move a cell widget.\n     */\n    _moveCell(fromIndex, toIndex) {\n        const layout = this.layout;\n        layout.insertWidget(toIndex, layout.widgets[fromIndex]);\n        this.onCellMoved(fromIndex, toIndex);\n    }\n    /**\n     * Remove a cell widget.\n     */\n    _removeCell(index) {\n        const layout = this.layout;\n        const widget = layout.widgets[index];\n        widget.parent = null;\n        this.onCellRemoved(index, widget);\n        widget.dispose();\n    }\n    /**\n     * Update the mimetype of the notebook.\n     */\n    _updateMimetype() {\n        var _a;\n        const info = (_a = this._model) === null || _a === void 0 ? void 0 : _a.metadata.get('language_info');\n        if (!info) {\n            return;\n        }\n        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);\n        each(this.widgets, widget => {\n            if (widget.model.type === 'code') {\n                widget.model.mimeType = this._mimetype;\n            }\n        });\n    }\n    /**\n     * Handle an update to the collaborators.\n     */\n    _onCollaboratorsChanged() {\n        var _a, _b, _c;\n        // If there are selections corresponding to non-collaborators,\n        // they are stale and should be removed.\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            for (const key of cell.model.selections.keys()) {\n                if (false === ((_c = (_b = (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelDB) === null || _b === void 0 ? void 0 : _b.collaborators) === null || _c === void 0 ? void 0 : _c.has(key))) {\n                    cell.model.selections.delete(key);\n                }\n            }\n        }\n    }\n    /**\n     * Update editor settings for notebook cells.\n     */\n    _updateEditorConfig() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            let config = {};\n            switch (cell.model.type) {\n                case 'code':\n                    config = this._editorConfig.code;\n                    break;\n                case 'markdown':\n                    config = this._editorConfig.markdown;\n                    break;\n                default:\n                    config = this._editorConfig.raw;\n                    break;\n            }\n            cell.editor.setOptions(Object.assign({}, config));\n            cell.editor.refresh();\n        }\n    }\n    /**\n     * Apply updated notebook settings.\n     */\n    _updateNotebookConfig() {\n        // Apply scrollPastEnd setting.\n        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);\n        // Control editor visibility for read-only Markdown cells\n        const showEditorForReadOnlyMarkdown = this._notebookConfig\n            .showEditorForReadOnlyMarkdown;\n        if (showEditorForReadOnlyMarkdown !== undefined) {\n            for (const cell of this.widgets) {\n                if (cell.model.type === 'markdown') {\n                    cell.showEditorForReadOnly = showEditorForReadOnlyMarkdown;\n                }\n            }\n        }\n    }\n    _incrementRenderedCount() {\n        if (this._toRenderMap.size === 0) {\n            this._fullyRendered.emit(true);\n        }\n        this._renderedCellsCount++;\n    }\n    get remainingCellToRenderCount() {\n        return this._toRenderMap.size;\n    }\n}\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\n(function (StaticNotebook) {\n    /**\n     * Default configuration options for cell editors.\n     */\n    StaticNotebook.defaultEditorConfig = {\n        code: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'off', matchBrackets: true, autoClosingBrackets: false }),\n        markdown: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false }),\n        raw: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false })\n    };\n    /**\n     * Default configuration options for notebooks.\n     */\n    StaticNotebook.defaultNotebookConfig = {\n        scrollPastEnd: true,\n        defaultCell: 'code',\n        recordTiming: false,\n        numberCellsToRenderDirectly: 99999,\n        remainingTimeBeforeRescheduling: 50,\n        renderCellOnIdle: true,\n        observedTopMargin: '1000px',\n        observedBottomMargin: '1000px',\n        maxNumberOutputs: 50,\n        showEditorForReadOnlyMarkdown: true,\n        disableDocumentWideUndoRedo: false,\n        renderingLayout: 'default',\n        sideBySideLeftMarginOverride: '10px',\n        sideBySideRightMarginOverride: '10px',\n        sideBySideOutputRatio: 1\n    };\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new MarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new RawCell(options).initializeState();\n        }\n    }\n    StaticNotebook.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the static notebook widget.\n     */\n    StaticNotebook.defaultContentFactory = new ContentFactory();\n})(StaticNotebook || (StaticNotebook = {}));\n/**\n * A notebook widget that supports interactivity.\n */\nexport class Notebook extends StaticNotebook {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super(Private.processNotebookOptions(options));\n        this._activeCellIndex = -1;\n        this._activeCell = null;\n        this._mode = 'command';\n        this._drag = null;\n        this._fragment = '';\n        this._dragData = null;\n        this._mouseMode = null;\n        this._activeCellChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n        this._checkCacheOnNextResize = false;\n        this._lastClipboardInteraction = null;\n        this.node.tabIndex = 0; // Allow the widget to take focus.\n        // Allow the node to scroll while dragging items.\n        this.node.setAttribute('data-lm-dragscroll', 'true');\n    }\n    /**\n     * A signal emitted when the active cell changes.\n     *\n     * #### Notes\n     * This can be due to the active index changing or the\n     * cell at the active index changing.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the state of the notebook changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the selection state of the notebook changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * The interactivity mode of the notebook.\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(newValue) {\n        const activeCell = this.activeCell;\n        if (!activeCell) {\n            newValue = 'command';\n        }\n        if (newValue === this._mode) {\n            this._ensureFocus();\n            return;\n        }\n        // Post an update request.\n        this.update();\n        const oldValue = this._mode;\n        this._mode = newValue;\n        if (newValue === 'edit') {\n            // Edit mode deselects all cells.\n            each(this.widgets, widget => {\n                this.deselect(widget);\n            });\n            //  Edit mode unrenders an active markdown widget.\n            if (activeCell instanceof MarkdownCell) {\n                activeCell.rendered = false;\n            }\n            activeCell.inputHidden = false;\n        }\n        else {\n            // Focus on the notebook document, which blurs the active cell.\n            this.node.focus();\n        }\n        this._stateChanged.emit({ name: 'mode', oldValue, newValue });\n        this._ensureFocus();\n    }\n    /**\n     * The active cell index of the notebook.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the notebook cells.\n     */\n    get activeCellIndex() {\n        if (!this.model) {\n            return -1;\n        }\n        return this.model.cells.length ? this._activeCellIndex : -1;\n    }\n    set activeCellIndex(newValue) {\n        const oldValue = this._activeCellIndex;\n        if (!this.model || !this.model.cells.length) {\n            newValue = -1;\n        }\n        else {\n            newValue = Math.max(newValue, 0);\n            newValue = Math.min(newValue, this.model.cells.length - 1);\n        }\n        this._activeCellIndex = newValue;\n        const cell = this.widgets[newValue];\n        if (cell !== this._activeCell) {\n            // Post an update request.\n            this.update();\n            this._activeCell = cell;\n            this._activeCellChanged.emit(cell);\n        }\n        if (this.mode === 'edit' && cell instanceof MarkdownCell) {\n            cell.rendered = false;\n        }\n        this._ensureFocus();\n        if (newValue === oldValue) {\n            return;\n        }\n        this._trimSelections();\n        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });\n    }\n    /**\n     * Get the active cell widget.\n     *\n     * #### Notes\n     * This is a cell or `null` if there is no active cell.\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    get lastClipboardInteraction() {\n        return this._lastClipboardInteraction;\n    }\n    set lastClipboardInteraction(newValue) {\n        this._lastClipboardInteraction = newValue;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Select a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    select(widget) {\n        if (Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, true);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Deselect a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    deselect(widget) {\n        if (!Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, false);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Whether a cell is selected.\n     */\n    isSelected(widget) {\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Whether a cell is selected or is the active cell.\n     */\n    isSelectedOrActive(widget) {\n        if (widget === this._activeCell) {\n            return true;\n        }\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Deselect all of the cells.\n     */\n    deselectAll() {\n        let changed = false;\n        each(this.widgets, widget => {\n            if (Private.selectedProperty.get(widget)) {\n                changed = true;\n            }\n            Private.selectedProperty.set(widget, false);\n        });\n        if (changed) {\n            this._selectionChanged.emit(void 0);\n        }\n        // Make sure we have a valid active cell.\n        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line\n        this.update();\n    }\n    /**\n     * Move the head of an existing contiguous selection to extend the selection.\n     *\n     * @param index - The new head of the existing selection.\n     *\n     * #### Notes\n     * If there is no existing selection, the active cell is considered an\n     * existing one-cell selection.\n     *\n     * If the new selection is a single cell, that cell becomes the active cell\n     * and all cells are deselected.\n     *\n     * There is no change if there are no cells (i.e., activeCellIndex is -1).\n     */\n    extendContiguousSelectionTo(index) {\n        let { head, anchor } = this.getContiguousSelection();\n        let i;\n        // Handle the case of no current selection.\n        if (anchor === null || head === null) {\n            if (index === this.activeCellIndex) {\n                // Already collapsed selection, nothing more to do.\n                return;\n            }\n            // We will start a new selection below.\n            head = this.activeCellIndex;\n            anchor = this.activeCellIndex;\n        }\n        // Move the active cell. We do this before the collapsing shortcut below.\n        this.activeCellIndex = index;\n        // Make sure the index is valid, according to the rules for setting and clipping the\n        // active cell index. This may change the index.\n        index = this.activeCellIndex;\n        // Collapse the selection if it is only the active cell.\n        if (index === anchor) {\n            this.deselectAll();\n            return;\n        }\n        let selectionChanged = false;\n        if (head < index) {\n            if (head < anchor) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between head and index except anchor.\n            for (i = head + 1; i < index; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        else if (index < head) {\n            if (anchor < head) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between index and head except anchor.\n            for (i = index + 1; i < head; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        // Anchor and index should *always* be selected.\n        if (!Private.selectedProperty.get(this.widgets[anchor])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[anchor], true);\n        if (!Private.selectedProperty.get(this.widgets[index])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[index], true);\n        if (selectionChanged) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Get the head and anchor of a contiguous cell selection.\n     *\n     * The head of a contiguous selection is always the active cell.\n     *\n     * If there are no cells selected, `{head: null, anchor: null}` is returned.\n     *\n     * Throws an error if the currently selected cells do not form a contiguous\n     * selection.\n     */\n    getContiguousSelection() {\n        const cells = this.widgets;\n        const first = ArrayExt.findFirstIndex(cells, c => this.isSelected(c));\n        // Return early if no cells are selected.\n        if (first === -1) {\n            return { head: null, anchor: null };\n        }\n        const last = ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);\n        // Check that the selection is contiguous.\n        for (let i = first; i <= last; i++) {\n            if (!this.isSelected(cells[i])) {\n                throw new Error('Selection not contiguous');\n            }\n        }\n        // Check that the active cell is one of the endpoints of the selection.\n        const activeIndex = this.activeCellIndex;\n        if (first !== activeIndex && last !== activeIndex) {\n            throw new Error('Active cell not at endpoint of selection');\n        }\n        // Determine the head and anchor of the selection.\n        if (first === activeIndex) {\n            return { head: first, anchor: last };\n        }\n        else {\n            return { head: last, anchor: first };\n        }\n    }\n    /**\n     * Scroll so that the given position is centered.\n     *\n     * @param position - The vertical position in the notebook widget.\n     *\n     * @param threshold - An optional threshold for the scroll (0-50, defaults to\n     * 25).\n     *\n     * #### Notes\n     * If the position is within the threshold percentage of the widget height,\n     * measured from the center of the widget, the scroll position will not be\n     * changed. A threshold of 0 means we will always scroll so the position is\n     * centered, and a threshold of 50 means scrolling only happens if position is\n     * outside the current window.\n     */\n    scrollToPosition(position, threshold = 25) {\n        const node = this.node;\n        const ar = node.getBoundingClientRect();\n        const delta = position - ar.top - ar.height / 2;\n        if (Math.abs(delta) > (ar.height * threshold) / 100) {\n            node.scrollTop += delta;\n        }\n    }\n    /**\n     * Scroll so that the given cell is in view. Selects and activates cell.\n     *\n     * @param cell - A cell in the notebook widget.\n     *\n     */\n    scrollToCell(cell) {\n        // use Phosphor to scroll\n        ElementExt.scrollIntoViewIfNeeded(this.node, cell.node);\n        // change selection and active cell:\n        this.deselectAll();\n        this.select(cell);\n        cell.activate();\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        // Wait all cells are rendered then set fragment and update.\n        void Promise.all(this.widgets.map(widget => widget.ready)).then(() => {\n            this._fragment = fragment;\n            this.update();\n        });\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'contextmenu':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtContextMenuCapture(event);\n                }\n                break;\n            case 'mousedown':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtMouseDownCapture(event);\n                }\n                else {\n                    this._evtMouseDown(event);\n                }\n                break;\n            case 'mouseup':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMouseup(event);\n                }\n                break;\n            case 'mousemove':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMousemove(event);\n                }\n                break;\n            case 'keydown':\n                this._ensureFocus(true);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'focusin':\n                this._evtFocusIn(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('contextmenu', this, true);\n        node.addEventListener('mousedown', this, true);\n        node.addEventListener('mousedown', this);\n        node.addEventListener('keydown', this);\n        node.addEventListener('dblclick', this);\n        node.addEventListener('focusin', this);\n        node.addEventListener('focusout', this);\n        // Capture drag events for the notebook widget\n        // in order to preempt the drag/drop handlers in the\n        // code editor widgets, which can take text data.\n        node.addEventListener('lm-dragenter', this, true);\n        node.addEventListener('lm-dragleave', this, true);\n        node.addEventListener('lm-dragover', this, true);\n        node.addEventListener('lm-drop', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('contextmenu', this, true);\n        node.removeEventListener('mousedown', this, true);\n        node.removeEventListener('mousedown', this);\n        node.removeEventListener('keydown', this);\n        node.removeEventListener('dblclick', this);\n        node.removeEventListener('focusin', this);\n        node.removeEventListener('focusout', this);\n        node.removeEventListener('lm-dragenter', this, true);\n        node.removeEventListener('lm-dragleave', this, true);\n        node.removeEventListener('lm-dragover', this, true);\n        node.removeEventListener('lm-drop', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        this._checkCacheOnNextResize = true;\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (!this._checkCacheOnNextResize) {\n            return super.onResize(msg);\n        }\n        this._checkCacheOnNextResize = false;\n        const cache = this._cellLayoutStateCache;\n        const width = parseInt(this.node.style.width, 10);\n        if (cache) {\n            if (width === cache.width) {\n                // Cache identical, do nothing\n                return;\n            }\n        }\n        // Update cache\n        this._cellLayoutStateCache = { width };\n        // Fallback:\n        for (const w of this.widgets) {\n            if (w instanceof Cell) {\n                w.editorWidget.update();\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'before-hide'` message.\n     */\n    onBeforeHide(msg) {\n        // Update cache\n        const width = parseInt(this.node.style.width, 10);\n        this._cellLayoutStateCache = { width };\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle `update-request` messages sent to the widget.\n     */\n    onUpdateRequest(msg) {\n        const activeCell = this.activeCell;\n        // Set the appropriate classes on the cells.\n        if (this.mode === 'edit') {\n            this.addClass(EDIT_CLASS);\n            this.removeClass(COMMAND_CLASS);\n        }\n        else {\n            this.addClass(COMMAND_CLASS);\n            this.removeClass(EDIT_CLASS);\n        }\n        if (activeCell) {\n            activeCell.addClass(ACTIVE_CLASS);\n        }\n        let count = 0;\n        each(this.widgets, widget => {\n            if (widget !== activeCell) {\n                widget.removeClass(ACTIVE_CLASS);\n            }\n            widget.removeClass(OTHER_SELECTED_CLASS);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(SELECTED_CLASS);\n                count++;\n            }\n            else {\n                widget.removeClass(SELECTED_CLASS);\n            }\n        });\n        if (count > 1) {\n            activeCell === null || activeCell === void 0 ? void 0 : activeCell.addClass(OTHER_SELECTED_CLASS);\n        }\n        if (this._fragment) {\n            let el;\n            try {\n                el = this.node.querySelector(this._fragment.startsWith('#')\n                    ? `#${CSS.escape(this._fragment.slice(1))}`\n                    : this._fragment);\n            }\n            catch (error) {\n                console.warn('Unable to set URI fragment identifier', error);\n            }\n            if (el) {\n                el.scrollIntoView();\n            }\n            this._fragment = '';\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     */\n    onCellInserted(index, cell) {\n        if (this.model && this.model.modelDB.isCollaborative) {\n            const modelDB = this.model.modelDB;\n            void modelDB.connected.then(() => {\n                if (!cell.isDisposed) {\n                    // Setup the selection style for collaborators.\n                    const localCollaborator = modelDB.collaborators.localCollaborator;\n                    cell.editor.uuid = localCollaborator.sessionId;\n                    cell.editor.selectionStyle = Object.assign(Object.assign({}, CodeEditor.defaultSelectionStyle), { color: localCollaborator.color });\n                }\n            });\n        }\n        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);\n        // If the insertion happened above, increment the active cell\n        // index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex + 1\n                : this.activeCellIndex;\n    }\n    /**\n     * Handle a cell being moved.\n     */\n    onCellMoved(fromIndex, toIndex) {\n        const i = this.activeCellIndex;\n        if (fromIndex === i) {\n            this.activeCellIndex = toIndex;\n        }\n        else if (fromIndex < i && i <= toIndex) {\n            this.activeCellIndex--;\n        }\n        else if (toIndex <= i && i < fromIndex) {\n            this.activeCellIndex++;\n        }\n    }\n    /**\n     * Handle a cell being removed.\n     */\n    onCellRemoved(index, cell) {\n        // If the removal happened above, decrement the active\n        // cell index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex - 1\n                : this.activeCellIndex;\n        if (this.isSelected(cell)) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Handle a new model.\n     */\n    onModelChanged(oldValue, newValue) {\n        super.onModelChanged(oldValue, newValue);\n        // Try to set the active cell index to 0.\n        // It will be set to `-1` if there is no new model or the model is empty.\n        this.activeCellIndex = 0;\n    }\n    /**\n     * Handle edge request signals from cells.\n     */\n    _onEdgeRequest(editor, location) {\n        const prev = this.activeCellIndex;\n        if (location === 'top') {\n            this.activeCellIndex--;\n            // Move the cursor to the first position on the last line.\n            if (this.activeCellIndex < prev) {\n                const editor = this.activeCell.editor;\n                const lastLine = editor.lineCount - 1;\n                editor.setCursorPosition({ line: lastLine, column: 0 });\n            }\n        }\n        else if (location === 'bottom') {\n            this.activeCellIndex++;\n            // Move the cursor to the first character.\n            if (this.activeCellIndex > prev) {\n                const editor = this.activeCell.editor;\n                editor.setCursorPosition({ line: 0, column: 0 });\n            }\n        }\n        this.mode = 'edit';\n    }\n    /**\n     * Ensure that the notebook has proper focus.\n     */\n    _ensureFocus(force = false) {\n        const activeCell = this.activeCell;\n        if (this.mode === 'edit' && activeCell) {\n            if (!activeCell.editor.hasFocus()) {\n                activeCell.editor.focus();\n            }\n        }\n        if (force && !this.node.contains(document.activeElement)) {\n            this.node.focus();\n        }\n    }\n    /**\n     * Find the cell index containing the target html element.\n     *\n     * #### Notes\n     * Returns -1 if the cell is not found.\n     */\n    _findCell(node) {\n        // Trace up the DOM hierarchy to find the root cell node.\n        // Then find the corresponding child and select it.\n        let n = node;\n        while (n && n !== this.node) {\n            if (n.classList.contains(NB_CELL_CLASS)) {\n                const i = ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);\n                if (i !== -1) {\n                    return i;\n                }\n                break;\n            }\n            n = n.parentElement;\n        }\n        return -1;\n    }\n    /**\n     * Find the target of html mouse event and cell index containing this target.\n     *\n     * #### Notes\n     * Returned index is -1 if the cell is not found.\n     */\n    _findEventTargetAndCell(event) {\n        let target = event.target;\n        let index = this._findCell(target);\n        if (index === -1) {\n            // `event.target` sometimes gives an orphaned node in Firefox 57, which\n            // can have `null` anywhere in its parent line. If we fail to find a cell\n            // using `event.target`, try again using a target reconstructed from the\n            // position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            index = this._findCell(target);\n        }\n        return [target, index];\n    }\n    /**\n     * Handle `contextmenu` event.\n     */\n    _evtContextMenuCapture(event) {\n        // Allow the event to propagate un-modified if the user\n        // is holding the shift-key (and probably requesting\n        // the native context menu).\n        if (event.shiftKey) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        if (widget && widget.editorWidget.node.contains(target)) {\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` event in the capture phase for the widget.\n     */\n    _evtMouseDownCapture(event) {\n        const { button, shiftKey } = event;\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        // On OS X, the context menu may be triggered with ctrl-left-click. In\n        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,\n        // ctrl-left-click gives an event with button 0 with the ctrl modifier.\n        if (button === 2 &&\n            !shiftKey &&\n            widget &&\n            widget.editorWidget.node.contains(target)) {\n            this.mode = 'command';\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        var _a;\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2)) {\n            return;\n        }\n        // Shift right-click gives the browser default behavior.\n        if (shiftKey && button === 2) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        let targetArea;\n        if (widget) {\n            if (widget.editorWidget.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if (widget.promptNode.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'notebook';\n        }\n        // Make sure we go to command mode if the click isn't in the cell editor If\n        // we do click in the cell editor, the editor handles the focus event to\n        // switch to edit mode.\n        if (targetArea !== 'input') {\n            this.mode = 'command';\n        }\n        if (targetArea === 'notebook') {\n            this.deselectAll();\n        }\n        else if (targetArea === 'prompt' || targetArea === 'cell') {\n            // We don't want to prevent the default selection behavior\n            // if there is currently text selected in an output.\n            const hasSelection = ((_a = window.getSelection()) !== null && _a !== void 0 ? _a : '').toString() !== '';\n            if (button === 0 && shiftKey && !hasSelection) {\n                // Prevent browser selecting text in prompt or output\n                event.preventDefault();\n                // Shift-click - extend selection\n                try {\n                    this.extendContiguousSelectionTo(index);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.deselectAll();\n                    return;\n                }\n                // Enter selecting mode\n                this._mouseMode = 'select';\n                document.addEventListener('mouseup', this, true);\n                document.addEventListener('mousemove', this, true);\n            }\n            else if (button === 0 && !shiftKey) {\n                // Prepare to start a drag if we are on the drag region.\n                if (targetArea === 'prompt') {\n                    // Prepare for a drag start\n                    this._dragData = {\n                        pressX: event.clientX,\n                        pressY: event.clientY,\n                        index: index\n                    };\n                    // Enter possible drag mode\n                    this._mouseMode = 'couldDrag';\n                    document.addEventListener('mouseup', this, true);\n                    document.addEventListener('mousemove', this, true);\n                    event.preventDefault();\n                }\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n            }\n            else if (button === 2) {\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n                event.preventDefault();\n            }\n        }\n        else if (targetArea === 'input') {\n            if (button === 2 && !this.isSelectedOrActive(widget)) {\n                this.deselectAll();\n                this.activeCellIndex = index;\n            }\n        }\n        // If we didn't set focus above, make sure we get focus now.\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle the `'mouseup'` event on the document.\n     */\n    _evtDocumentMouseup(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the event listeners we put on the document\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        if (this._mouseMode === 'couldDrag') {\n            // We didn't end up dragging if we are here, so treat it as a click event.\n            const [, index] = this._findEventTargetAndCell(event);\n            this.deselectAll();\n            this.activeCellIndex = index;\n            // Focus notebook if active cell changes but does not have focus.\n            if (!this.activeCell.node.contains(document.activeElement)) {\n                this.node.focus();\n            }\n        }\n        this._mouseMode = null;\n    }\n    /**\n     * Handle the `'mousemove'` event for the widget.\n     */\n    _evtDocumentMousemove(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // If in select mode, update the selection\n        switch (this._mouseMode) {\n            case 'select': {\n                const target = event.target;\n                const index = this._findCell(target);\n                if (index !== -1) {\n                    this.extendContiguousSelectionTo(index);\n                }\n                break;\n            }\n            case 'couldDrag': {\n                // Check for a drag initialization.\n                const data = this._dragData;\n                const dx = Math.abs(event.clientX - data.pressX);\n                const dy = Math.abs(event.clientY - data.pressY);\n                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {\n                    this._mouseMode = null;\n                    this._startDrag(data.index, event.clientX, event.clientY);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the widget.\n     */\n    _evtDragEnter(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the widget.\n     */\n    _evtDragLeave(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the widget.\n     */\n    _evtDragOver(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Model presence should be checked before calling event handlers\n        const model = this.model;\n        const source = event.source;\n        if (source === this) {\n            // Handle the case where we are moving cells within\n            // the same notebook.\n            event.dropAction = 'move';\n            const toMove = event.mimeData.getData('internal:cells');\n            // For collapsed markdown headings with hidden \"child\" cells, move all\n            // child cells as well as the markdown heading.\n            const cell = toMove[toMove.length - 1];\n            if (cell instanceof MarkdownCell && cell.headingCollapsed) {\n                const nextParent = NotebookActions.findNextParentHeading(cell, source);\n                if (nextParent > 0) {\n                    const index = findIndex(source.widgets, (possibleCell) => {\n                        return cell.model.id === possibleCell.model.id;\n                    });\n                    toMove.push(...source.widgets.slice(index + 1, nextParent));\n                }\n            }\n            // Compute the to/from indices for the move.\n            let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);\n            let toIndex = this._findCell(target);\n            // This check is needed for consistency with the view.\n            if (toIndex !== -1 && toIndex > fromIndex) {\n                toIndex -= 1;\n            }\n            else if (toIndex === -1) {\n                // If the drop is within the notebook but not on any cell,\n                // most often this means it is past the cell areas, so\n                // set it to move the cells to the end of the notebook.\n                toIndex = this.widgets.length - 1;\n            }\n            // Don't move if we are within the block of selected cells.\n            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {\n                return;\n            }\n            // Move the cells one by one\n            model.cells.beginCompoundOperation();\n            if (fromIndex < toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex, toIndex);\n                });\n            }\n            else if (fromIndex > toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex++, toIndex++);\n                });\n            }\n            model.cells.endCompoundOperation();\n        }\n        else {\n            // Handle the case where we are copying cells between\n            // notebooks.\n            event.dropAction = 'copy';\n            // Find the target cell and insert the copied cells.\n            let index = this._findCell(target);\n            if (index === -1) {\n                index = this.widgets.length;\n            }\n            const start = index;\n            const values = event.mimeData.getData(JUPYTER_CELL_MIME);\n            const factory = model.contentFactory;\n            // Insert the copies of the original cells.\n            model.cells.beginCompoundOperation();\n            each(values, (cell) => {\n                let value;\n                switch (cell.cell_type) {\n                    case 'code':\n                        value = factory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        value = factory.createMarkdownCell({ cell });\n                        break;\n                    default:\n                        value = factory.createRawCell({ cell });\n                        break;\n                }\n                model.cells.insert(index++, value);\n            });\n            model.cells.endCompoundOperation();\n            // Select the inserted cells.\n            this.deselectAll();\n            this.activeCellIndex = start;\n            this.extendContiguousSelectionTo(index - 1);\n        }\n    }\n    /**\n     * Start a drag event.\n     */\n    _startDrag(index, clientX, clientY) {\n        var _a;\n        const cells = this.model.cells;\n        const selected = [];\n        const toMove = [];\n        each(this.widgets, (widget, i) => {\n            const cell = cells.get(i);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(DROP_SOURCE_CLASS);\n                selected.push(cell.toJSON());\n                toMove.push(widget);\n            }\n        });\n        const activeCell = this.activeCell;\n        let dragImage = null;\n        let countString;\n        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            countString = ' ';\n            if (executionCount) {\n                countString = executionCount.toString();\n            }\n        }\n        else {\n            countString = '';\n        }\n        // Create the drag image.\n        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.value.text.split('\\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');\n        // Set up the drag event.\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            supportedActions: 'copy-move',\n            proposedAction: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        // Add mimeData for the fully reified cell widgets, for the\n        // case where the target is in the same notebook and we\n        // can just move the cells.\n        this._drag.mimeData.setData('internal:cells', toMove);\n        // Add mimeData for the text content of the selected cells,\n        // allowing for drag/drop into plain text fields.\n        const textContent = toMove.map(cell => cell.model.value.text).join('\\n');\n        this._drag.mimeData.setData('text/plain', textContent);\n        // Remove mousemove and mouseup listeners and start the drag.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        this._mouseMode = null;\n        void this._drag.start(clientX, clientY).then(action => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            each(toMove, widget => {\n                widget.removeClass(DROP_SOURCE_CLASS);\n            });\n        });\n    }\n    /**\n     * Handle `focus` events for the widget.\n     */\n    _evtFocusIn(event) {\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            // If the editor itself does not have focus, ensure command mode.\n            if (!widget.editorWidget.node.contains(target)) {\n                this.mode = 'command';\n            }\n            this.activeCellIndex = index;\n            // If the editor has focus, ensure edit mode.\n            const node = widget.editorWidget.node;\n            if (node.contains(target)) {\n                this.mode = 'edit';\n            }\n            this.activeCellIndex = index;\n        }\n        else {\n            // No cell has focus, ensure command mode.\n            this.mode = 'command';\n        }\n    }\n    /**\n     * Handle `focusout` events for the notebook.\n     */\n    _evtFocusOut(event) {\n        const relatedTarget = event.relatedTarget;\n        // Bail if the window is losing focus, to preserve edit mode. This test\n        // assumes that we explicitly focus things rather than calling blur()\n        if (!relatedTarget) {\n            return;\n        }\n        // Bail if the item gaining focus is another cell,\n        // and we should not be entering command mode.\n        const index = this._findCell(relatedTarget);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            if (widget.editorWidget.node.contains(relatedTarget)) {\n                return;\n            }\n        }\n        // Otherwise enter command mode if not already.\n        if (this.mode !== 'command') {\n            this.mode = 'command';\n            // Switching to command mode currently focuses the notebook element, so\n            // refocus the relatedTarget so the focus actually switches as intended.\n            if (relatedTarget) {\n                relatedTarget.focus();\n            }\n        }\n    }\n    /**\n     * Handle `dblclick` events for the widget.\n     */\n    _evtDblClick(event) {\n        const model = this.model;\n        if (!model) {\n            return;\n        }\n        this.deselectAll();\n        const [target, index] = this._findEventTargetAndCell(event);\n        if (event.target.classList.contains(HEADING_COLLAPSER_CLASS)) {\n            return;\n        }\n        if (index === -1) {\n            return;\n        }\n        this.activeCellIndex = index;\n        if (model.cells.get(index).type === 'markdown') {\n            const widget = this.widgets[index];\n            widget.rendered = false;\n        }\n        else if (target.localName === 'img') {\n            target.classList.toggle(UNCONFINED_CLASS);\n        }\n    }\n    /**\n     * Remove selections from inactive cells to avoid\n     * spurious cursors.\n     */\n    _trimSelections() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            if (i !== this._activeCellIndex) {\n                const cell = this.widgets[i];\n                cell.model.selections.delete(cell.editor.uuid);\n            }\n        }\n    }\n}\n/**\n * The namespace for the `Notebook` class statics.\n */\n(function (Notebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends StaticNotebook.ContentFactory {\n    }\n    Notebook.ContentFactory = ContentFactory;\n    Notebook.defaultContentFactory = new ContentFactory();\n})(Notebook || (Notebook = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the selected state of a cell.\n     */\n    Private.selectedProperty = new AttachedProperty({\n        name: 'selected',\n        create: () => false\n    });\n    /**\n     * A custom panel layout for the notebook.\n     */\n    class NotebookPanelLayout extends PanelLayout {\n        /**\n         * A message handler invoked on an `'update-request'` message.\n         *\n         * #### Notes\n         * This is a reimplementation of the base class method,\n         * and is a no-op.\n         */\n        onUpdateRequest(msg) {\n            // This is a no-op.\n        }\n    }\n    Private.NotebookPanelLayout = NotebookPanelLayout;\n    /**\n     * Create a cell drag image.\n     */\n    function createDragImage(count, promptNumber, cellContent) {\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    Private.createDragImage = createDragImage;\n    /**\n     * Process the `IOptions` passed to the notebook widget.\n     *\n     * #### Notes\n     * This defaults the content factory to that in the `Notebook` namespace.\n     */\n    function processNotebookOptions(options) {\n        if (options.contentFactory) {\n            return options;\n        }\n        else {\n            return {\n                rendermime: options.rendermime,\n                languagePreference: options.languagePreference,\n                contentFactory: Notebook.defaultContentFactory,\n                mimeTypeService: options.mimeTypeService\n            };\n        }\n    }\n    Private.processNotebookOptions = processNotebookOptions;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, Printing, showDialog } from '@jupyterlab/apputils';\nimport { isMarkdownCellModel } from '@jupyterlab/cells';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { each } from '@lumino/algorithm';\nimport { Token } from '@lumino/coreutils';\nimport { Notebook } from './widget';\n/**\n * The class name added to notebook panels.\n */\nconst NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';\nconst NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';\nconst NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';\n/**\n * The class name to add when the document is loaded for the search box.\n */\nconst SEARCH_DOCUMENT_LOADED_CLASS = 'jp-DocumentSearch-document-loaded';\n/**\n * A widget that hosts a notebook toolbar and content area.\n *\n * #### Notes\n * The widget keeps the document metadata in sync with the current\n * kernel on the context.\n */\nexport class NotebookPanel extends DocumentWidget {\n    /**\n     * Construct a new notebook panel.\n     */\n    constructor(options) {\n        super(options);\n        /**\n         * Whether we are currently in a series of autorestarts we have already\n         * notified the user about.\n         */\n        this._autorestarting = false;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        // Set up CSS classes\n        this.addClass(NOTEBOOK_PANEL_CLASS);\n        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);\n        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);\n        // Set up things related to the context\n        this.content.model = this.context.model;\n        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);\n        this.content.fullyRendered.connect(this._onFullyRendered, this);\n        this.context.saveState.connect(this._onSave, this);\n        void this.revealed.then(() => {\n            if (this.isDisposed) {\n                // this widget has already been disposed, bail\n                return;\n            }\n            // Set the document edit mode on initial open if it looks like a new document.\n            if (this.content.widgets.length === 1) {\n                const cellModel = this.content.widgets[0].model;\n                if (cellModel.type === 'code' && cellModel.value.text === '') {\n                    this.content.mode = 'edit';\n                }\n            }\n        });\n    }\n    _onSave(sender, state) {\n        if (state === 'started' && this.model) {\n            // Find markdown cells\n            const { cells } = this.model;\n            each(cells, cell => {\n                if (isMarkdownCellModel(cell)) {\n                    for (const key of cell.attachments.keys) {\n                        if (!cell.value.text.includes(key)) {\n                            cell.attachments.remove(key);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * The session context used by the panel.\n     */\n    get sessionContext() {\n        return this.context.sessionContext;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this.content.model;\n    }\n    /**\n     * Update the options for the current notebook panel.\n     *\n     * @param config new options to set\n     */\n    setConfig(config) {\n        this.content.editorConfig = config.editorConfig;\n        this.content.notebookConfig = config.notebookConfig;\n        // Update kernel shutdown behavior\n        const kernelPreference = this.context.sessionContext.kernelPreference;\n        this.context.sessionContext.kernelPreference = Object.assign(Object.assign({}, kernelPreference), { shutdownOnDispose: config.kernelShutdown });\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        void this.context.ready.then(() => {\n            this.content.setFragment(fragment);\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        this.content.dispose();\n        super.dispose();\n    }\n    /**\n     * Prints the notebook by converting to HTML with nbconvert.\n     */\n    [Printing.symbol]() {\n        return async () => {\n            // Save before generating HTML\n            if (this.context.model.dirty && !this.context.model.readOnly) {\n                await this.context.save();\n            }\n            await Printing.printURL(PageConfig.getNBConvertURL({\n                format: 'html',\n                download: false,\n                path: this.context.path\n            }));\n        };\n    }\n    /**\n     * Handle a fully rendered signal notebook.\n     */\n    _onFullyRendered(notebook, fullyRendered) {\n        fullyRendered\n            ? this.removeClass(SEARCH_DOCUMENT_LOADED_CLASS)\n            : this.addClass(SEARCH_DOCUMENT_LOADED_CLASS);\n    }\n    /**\n     * Handle a change in the kernel by updating the document metadata.\n     */\n    _onKernelChanged(sender, args) {\n        if (!this.model || !args.newValue) {\n            return;\n        }\n        const { newValue } = args;\n        void newValue.info.then(info => {\n            var _a;\n            if (this.model &&\n                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {\n                this._updateLanguage(info.language_info);\n            }\n        });\n        void this._updateSpec(newValue);\n    }\n    _onSessionStatusChanged(sender, status) {\n        var _a;\n        // If the status is autorestarting, and we aren't already in a series of\n        // autorestarts, show the dialog.\n        if (status === 'autorestarting' && !this._autorestarting) {\n            // The kernel died and the server is restarting it. We notify the user so\n            // they know why their kernel state is gone.\n            void showDialog({\n                title: this._trans.__('Kernel Restarting'),\n                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n            this._autorestarting = true;\n        }\n        else if (status === 'restarting') {\n            // Another autorestart attempt will first change the status to\n            // restarting, then to autorestarting again, so we don't reset the\n            // autorestarting status if the status is 'restarting'.\n            /* no-op */\n        }\n        else {\n            this._autorestarting = false;\n        }\n    }\n    /**\n     * Update the kernel language.\n     */\n    _updateLanguage(language) {\n        this.model.metadata.set('language_info', language);\n    }\n    /**\n     * Update the kernel spec.\n     */\n    async _updateSpec(kernel) {\n        const spec = await kernel.spec;\n        if (this.isDisposed) {\n            return;\n        }\n        this.model.metadata.set('kernelspec', {\n            name: kernel.name,\n            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,\n            language: spec === null || spec === void 0 ? void 0 : spec.language\n        });\n    }\n}\n/**\n * A namespace for `NotebookPanel` statics.\n */\n(function (NotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Notebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new Notebook(options);\n        }\n    }\n    NotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the notebook panel.\n     */\n    NotebookPanel.defaultContentFactory = new ContentFactory();\n    /* tslint:disable */\n    /**\n     * The notebook renderer token.\n     */\n    NotebookPanel.IContentFactory = new Token('@jupyterlab/notebook:IContentFactory');\n    /* tslint:enable */\n})(NotebookPanel || (NotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The notebook widget factory token.\n */\nexport const INotebookWidgetFactory = new Token('@jupyterlab/notebook:INotebookWidgetFactory');\n/* tslint:enable */\n/* tslint:disable */\n/**\n * The notebook tools token.\n */\nexport const INotebookTools = new Token('@jupyterlab/notebook:INotebookTools');\n/* tslint:disable */\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token('@jupyterlab/notebook:INotebookTracker');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookTracker extends WidgetTracker {\n    constructor() {\n        super(...arguments);\n        this._activeCell = null;\n        this._activeCellChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n    }\n    /**\n     * The currently focused cell.\n     *\n     * #### Notes\n     * This is a read-only property. If there is no cell with the focus, then this\n     * value is `null`.\n     */\n    get activeCell() {\n        const widget = this.currentWidget;\n        if (!widget) {\n            return null;\n        }\n        return widget.content.activeCell || null;\n    }\n    /**\n     * A signal emitted when the current active cell changes.\n     *\n     * #### Notes\n     * If there is no cell with the focus, then `null` will be emitted.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the selection state changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * Add a new notebook panel to the tracker.\n     *\n     * @param panel - The notebook panel being added.\n     */\n    add(panel) {\n        const promise = super.add(panel);\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n        return promise;\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Handle the current change event.\n     */\n    onCurrentChanged(widget) {\n        // Store an internal reference to active cell to prevent false positives.\n        const activeCell = this.activeCell;\n        if (activeCell && activeCell === this._activeCell) {\n            return;\n        }\n        this._activeCell = activeCell;\n        if (!widget) {\n            return;\n        }\n        // Since the notebook has changed, immediately signal an active cell change\n        this._activeCellChanged.emit(widget.content.activeCell || null);\n    }\n    _onActiveCellChanged(sender, cell) {\n        // Check if the active cell change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._activeCell = cell || null;\n            this._activeCellChanged.emit(this._activeCell);\n        }\n    }\n    _onSelectionChanged(sender) {\n        // Check if the selection change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n}\n//# sourceMappingURL=tracker.js.map","import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { notTrustedIcon, trustedIcon } from '@jupyterlab/ui-components';\nimport { toArray } from '@lumino/algorithm';\nimport React from 'react';\n/**\n * Determine the notebook trust status message.\n */\nfunction cellTrust(props, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    if (props.trustedCells === props.totalCells) {\n        return [\n            trans.__('Notebook trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else if (props.activeCellTrusted) {\n        return [\n            trans.__('Active cell trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else {\n        return [\n            trans.__('Notebook not trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-untrusted'\n        ];\n    }\n}\n/**\n * A pure function for a notebook trust status component.\n *\n * @param props: the props for the component.\n *\n * @returns a tsx component for notebook trust.\n */\nfunction NotebookTrustComponent(props) {\n    if (props.allCellsTrusted) {\n        return React.createElement(trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n    else {\n        return React.createElement(notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n}\n/**\n * The NotebookTrust status item.\n */\nexport class NotebookTrustStatus extends VDomRenderer {\n    /**\n     * Construct a new status item.\n     */\n    constructor(translator) {\n        super(new NotebookTrustStatus.Model());\n        this.translator = translator || nullTranslator;\n    }\n    /**\n     * Render the NotebookTrust status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = cellTrust(this.model, this.translator)[0];\n        return (React.createElement(\"div\", null,\n            React.createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells })));\n    }\n}\n/**\n * A namespace for NotebookTrust statics.\n */\n(function (NotebookTrustStatus) {\n    /**\n     * A VDomModel for the NotebookTrust status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._trustedCells = 0;\n            this._totalCells = 0;\n            this._activeCellTrusted = false;\n            this._notebook = null;\n        }\n        /**\n         * The number of trusted cells in the current notebook.\n         */\n        get trustedCells() {\n            return this._trustedCells;\n        }\n        /**\n         * The total number of cells in the current notebook.\n         */\n        get totalCells() {\n            return this._totalCells;\n        }\n        /**\n         * Whether the active cell is trusted.\n         */\n        get activeCellTrusted() {\n            return this._activeCellTrusted;\n        }\n        /**\n         * The current notebook for the model.\n         */\n        get notebook() {\n            return this._notebook;\n        }\n        set notebook(model) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);\n            }\n            const oldState = this._getAllState();\n            this._notebook = model;\n            if (this._notebook === null) {\n                this._trustedCells = 0;\n                this._totalCells = 0;\n                this._activeCellTrusted = false;\n            }\n            else {\n                // Add listeners\n                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                this._notebook.modelContentChanged.connect(this._onModelChanged, this);\n                // Derive values\n                if (this._notebook.activeCell !== undefined) {\n                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;\n                }\n                else {\n                    this._activeCellTrusted = false;\n                }\n                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);\n                this._totalCells = total;\n                this._trustedCells = trusted;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the notebook model changes, update the trust state.\n         */\n        _onModelChanged(notebook) {\n            const oldState = this._getAllState();\n            const { total, trusted } = this._deriveCellTrustState(notebook.model);\n            this._totalCells = total;\n            this._trustedCells = trusted;\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the active cell changes, update the trust state.\n         */\n        _onActiveCellChanged(model, cell) {\n            const oldState = this._getAllState();\n            if (cell) {\n                this._activeCellTrusted = cell.model.trusted;\n            }\n            else {\n                this._activeCellTrusted = false;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Given a notebook model, figure out how many of the cells are trusted.\n         */\n        _deriveCellTrustState(model) {\n            if (model === null) {\n                return { total: 0, trusted: 0 };\n            }\n            const cells = toArray(model.cells);\n            const trusted = cells.reduce((accum, current) => {\n                if (current.trusted) {\n                    return accum + 1;\n                }\n                else {\n                    return accum;\n                }\n            }, 0);\n            const total = cells.length;\n            return {\n                total,\n                trusted\n            };\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._trustedCells, this._totalCells, this.activeCellTrusted];\n        }\n        /**\n         * Trigger a change in the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] ||\n                oldState[1] !== newState[1] ||\n                oldState[2] !== newState[2]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    NotebookTrustStatus.Model = Model;\n})(NotebookTrustStatus || (NotebookTrustStatus = {}));\n//# sourceMappingURL=truststatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { sessionContextDialogs } from '@jupyterlab/apputils';\nimport { ABCWidgetFactory } from '@jupyterlab/docregistry';\nimport { ToolbarItems } from './default-toolbar';\nimport { NotebookPanel } from './panel';\nimport { StaticNotebook } from './widget';\n/**\n * A widget factory for notebook panels.\n */\nexport class NotebookWidgetFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new notebook widget factory.\n     *\n     * @param options - The options used to construct the factory.\n     */\n    constructor(options) {\n        super(options);\n        this.rendermime = options.rendermime;\n        this.contentFactory =\n            options.contentFactory || NotebookPanel.defaultContentFactory;\n        this.mimeTypeService = options.mimeTypeService;\n        this._editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this._notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._sessionDialogs = options.sessionDialogs || sessionContextDialogs;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n    }\n    /**\n     * Create a new widget.\n     *\n     * #### Notes\n     * The factory will start the appropriate kernel.\n     */\n    createNewWidget(context, source) {\n        const nbOptions = {\n            rendermime: source\n                ? source.content.rendermime\n                : this.rendermime.clone({ resolver: context.urlResolver }),\n            contentFactory: this.contentFactory,\n            mimeTypeService: this.mimeTypeService,\n            editorConfig: source ? source.content.editorConfig : this._editorConfig,\n            notebookConfig: source\n                ? source.content.notebookConfig\n                : this._notebookConfig,\n            translator: this.translator\n        };\n        const content = this.contentFactory.createNotebook(nbOptions);\n        return new NotebookPanel({ context, content });\n    }\n    /**\n     * Default factory for toolbar items to be added after the widget is created.\n     */\n    defaultToolbarFactory(widget) {\n        return ToolbarItems.getDefaultItems(widget, this._sessionDialogs, this.translator);\n    }\n}\n//# sourceMappingURL=widgetfactory.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { translateKernelStatuses, VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport React from 'react';\nimport { interactiveItem, ProgressCircle } from '@jupyterlab/statusbar';\nimport { circleIcon, offlineBoltIcon } from '@jupyterlab/ui-components';\nimport { KernelMessage } from '@jupyterlab/services';\n/**\n * A react functional component for rendering execution indicator.\n */\nexport function ExecutionIndicatorComponent(props) {\n    const translator = props.translator || nullTranslator;\n    const kernelStatuses = translateKernelStatuses(translator);\n    const trans = translator.load('jupyterlab');\n    const state = props.state;\n    const showOnToolBar = props.displayOption.showOnToolBar;\n    const showProgress = props.displayOption.showProgress;\n    const tooltipClass = showOnToolBar ? 'down' : 'up';\n    const emptyDiv = React.createElement(\"div\", null);\n    if (!state) {\n        return emptyDiv;\n    }\n    const kernelStatus = state.kernelStatus;\n    const circleIconProps = {\n        alignSelf: 'normal',\n        height: '24px'\n    };\n    const time = state.totalTime;\n    const scheduledCellNumber = state.scheduledCellNumber || 0;\n    const remainingCellNumber = state.scheduledCell.size || 0;\n    const executedCellNumber = scheduledCellNumber - remainingCellNumber;\n    let percentage = (100 * executedCellNumber) / scheduledCellNumber;\n    let displayClass = showProgress ? '' : 'hidden';\n    if (!showProgress && percentage < 100) {\n        percentage = 0;\n    }\n    const progressBar = (percentage) => (React.createElement(ProgressCircle, { progress: percentage, width: 16, height: 24 }));\n    const titleFactory = (translatedStatus) => trans.__('Kernel status: %1', translatedStatus);\n    const reactElement = (status, circle, popup) => (React.createElement(\"div\", { className: 'jp-Notebook-ExecutionIndicator', title: showProgress ? '' : titleFactory(kernelStatuses[status]), \"data-status\": status },\n        circle,\n        React.createElement(\"div\", { className: `jp-Notebook-ExecutionIndicator-tooltip ${tooltipClass} ${displayClass}` },\n            React.createElement(\"span\", null,\n                \" \",\n                titleFactory(kernelStatuses[status]),\n                \" \"),\n            popup)));\n    if (state.kernelStatus === 'connecting' ||\n        state.kernelStatus === 'disconnected' ||\n        state.kernelStatus === 'unknown') {\n        return reactElement(kernelStatus, React.createElement(offlineBoltIcon.react, Object.assign({}, circleIconProps)), []);\n    }\n    if (state.kernelStatus === 'starting' ||\n        state.kernelStatus === 'terminating' ||\n        state.kernelStatus === 'restarting' ||\n        state.kernelStatus === 'initializing') {\n        return reactElement(kernelStatus, React.createElement(circleIcon.react, Object.assign({}, circleIconProps)), []);\n    }\n    if (state.executionStatus === 'busy') {\n        return reactElement('busy', progressBar(percentage), [\n            React.createElement(\"span\", { key: 0 }, trans.__(`Executed ${executedCellNumber}/${scheduledCellNumber} cells`)),\n            React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n        ]);\n    }\n    else {\n        // No cell is scheduled, fall back to the status of kernel\n        const progress = state.kernelStatus === 'busy' ? 0 : 100;\n        const popup = state.kernelStatus === 'busy' || time === 0\n            ? []\n            : [\n                React.createElement(\"span\", { key: 0 }, trans._n('Executed %1 cell', 'Executed %1 cells', scheduledCellNumber)),\n                React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n            ];\n        return reactElement(state.kernelStatus, progressBar(progress), popup);\n    }\n}\n/**\n * A VDomRenderer widget for displaying the execution status.\n */\nexport class ExecutionIndicator extends VDomRenderer {\n    /**\n     * Construct the kernel status widget.\n     */\n    constructor(translator, showProgress = true) {\n        super(new ExecutionIndicator.Model());\n        this.translator = translator || nullTranslator;\n        this.addClass(interactiveItem);\n    }\n    /**\n     * Render the execution status item.\n     */\n    render() {\n        if (this.model === null || !this.model.renderFlag) {\n            return React.createElement(\"div\", null);\n        }\n        else {\n            const nb = this.model.currentNotebook;\n            if (!nb) {\n                return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: undefined, translator: this.translator }));\n            }\n            return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: this.model.executionState(nb), translator: this.translator }));\n        }\n    }\n}\n/**\n * A namespace for ExecutionIndicator statics.\n */\n(function (ExecutionIndicator) {\n    /**\n     * A VDomModel for the execution status indicator.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super();\n            /**\n             * A weak map to hold execution status of multiple notebooks.\n             */\n            this._notebookExecutionProgress = new WeakMap();\n            this._displayOption = { showOnToolBar: true, showProgress: true };\n            this._renderFlag = true;\n        }\n        /**\n         * Attach a notebook with session context to model in order to keep\n         * track of multiple notebooks. If a session context is already\n         * attached, only set current activated notebook to input.\n         *\n         * @param data - The  notebook and session context to be attached to model\n         */\n        attachNotebook(data) {\n            var _a, _b, _c, _d;\n            if (data && data.content && data.context) {\n                const nb = data.content;\n                const context = data.context;\n                this._currentNotebook = nb;\n                if (!this._notebookExecutionProgress.has(nb)) {\n                    this._notebookExecutionProgress.set(nb, {\n                        executionStatus: 'idle',\n                        kernelStatus: 'idle',\n                        totalTime: 0,\n                        interval: 0,\n                        timeout: 0,\n                        scheduledCell: new Set(),\n                        scheduledCellNumber: 0,\n                        needReset: true\n                    });\n                    const state = this._notebookExecutionProgress.get(nb);\n                    const contextStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.statusChanged.connect(contextStatusChanged, this);\n                    const contextConnectionStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.connectionStatusChanged.connect(contextConnectionStatusChanged, this);\n                    context.disposed.connect(ctx => {\n                        ctx.connectionStatusChanged.disconnect(contextConnectionStatusChanged, this);\n                        ctx.statusChanged.disconnect(contextStatusChanged, this);\n                    });\n                    const handleKernelMsg = (sender, msg) => {\n                        const message = msg.msg;\n                        const msgId = message.header.msg_id;\n                        if (message.header.msg_type === 'execute_request') {\n                            // A cell code is scheduled for executing\n                            this._cellScheduledCallback(nb, msgId);\n                        }\n                        else if (KernelMessage.isStatusMsg(message) &&\n                            message.content.execution_state === 'idle') {\n                            // Idle status message case.\n                            const parentId = message.parent_header\n                                .msg_id;\n                            this._cellExecutedCallback(nb, parentId);\n                        }\n                        else if (message.header.msg_type === 'execute_input') {\n                            // A cell code starts executing.\n                            this._startTimer(nb);\n                        }\n                    };\n                    (_b = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.anyMessage.connect(handleKernelMsg);\n                    (_d = (_c = context.session) === null || _c === void 0 ? void 0 : _c.kernel) === null || _d === void 0 ? void 0 : _d.disposed.connect(kernel => kernel.anyMessage.disconnect(handleKernelMsg));\n                    const kernelChangedSlot = (_, kernelData) => {\n                        if (state) {\n                            this._resetTime(state);\n                            this.stateChanged.emit(void 0);\n                            if (kernelData.newValue) {\n                                kernelData.newValue.anyMessage.connect(handleKernelMsg);\n                            }\n                        }\n                    };\n                    context.kernelChanged.connect(kernelChangedSlot);\n                    context.disposed.connect(ctx => ctx.kernelChanged.disconnect(kernelChangedSlot));\n                }\n            }\n        }\n        /**\n         * The current activated notebook in model.\n         */\n        get currentNotebook() {\n            return this._currentNotebook;\n        }\n        /**\n         * The display options for progress bar and elapsed time.\n         */\n        get displayOption() {\n            return this._displayOption;\n        }\n        /**\n         * Set the display options for progress bar and elapsed time.\n         *\n         * @param options - Options to be used\n         */\n        set displayOption(options) {\n            this._displayOption = options;\n        }\n        /**\n         * Get the execution state associated with a notebook.\n         *\n         * @param nb - The notebook used to identify execution\n         * state.\n         *\n         * @return - The associated execution state.\n         */\n        executionState(nb) {\n            return this._notebookExecutionProgress.get(nb);\n        }\n        /**\n         * The function is called on kernel's idle status message.\n         * It is used to keep track number of executed\n         * cell or Comm custom messages and the status of kernel.\n         *\n         * @param  nb - The notebook which contains the executed code\n         * cell.\n         * @param  msg_id - The id of message.\n         *\n         * ### Note\n         *\n         * To keep track of cells executed under 1 second,\n         * the execution state is marked as `needReset` 1 second after executing\n         * these cells. This `Timeout` will be cleared if there is any cell\n         * scheduled after that.\n         */\n        _cellExecutedCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && state.scheduledCell.has(msg_id)) {\n                state.scheduledCell.delete(msg_id);\n                if (state.scheduledCell.size === 0) {\n                    window.setTimeout(() => {\n                        state.executionStatus = 'idle';\n                        clearInterval(state.interval);\n                        this.stateChanged.emit(void 0);\n                    }, 150);\n                    state.timeout = window.setTimeout(() => {\n                        state.needReset = true;\n                    }, 1000);\n                }\n            }\n        }\n        /**\n         * This function is called on kernel's `execute_input` message to start\n         * the elapsed time counter.\n         *\n         * @param  nb - The notebook which contains the scheduled execution request.\n         */\n        _startTimer(nb) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state) {\n                if (state.executionStatus !== 'busy') {\n                    state.executionStatus = 'busy';\n                    clearTimeout(state.timeout);\n                    this.stateChanged.emit(void 0);\n                    state.interval = window.setInterval(() => {\n                        this._tick(state);\n                    }, 1000);\n                }\n            }\n        }\n        /**\n         * The function is called on kernel's `execute_request` message or Comm message, it is\n         * used to keep track number of scheduled cell or Comm execution message\n         * and the status of kernel.\n         *\n         * @param  nb - The notebook which contains the scheduled code.\n         * cell\n         * @param  msg_id - The id of message.\n         */\n        _cellScheduledCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && !state.scheduledCell.has(msg_id)) {\n                if (state.needReset) {\n                    this._resetTime(state);\n                }\n                state.scheduledCell.add(msg_id);\n                state.scheduledCellNumber += 1;\n            }\n        }\n        /**\n         * Increment the executed time of input execution state\n         * and emit `stateChanged` signal to re-render the indicator.\n         *\n         * @param  data - the state to be updated.\n         */\n        _tick(data) {\n            data.totalTime += 1;\n            this.stateChanged.emit(void 0);\n        }\n        /**\n         * Reset the input execution state.\n         *\n         * @param  data - the state to be rested.\n         */\n        _resetTime(data) {\n            data.totalTime = 0;\n            data.scheduledCellNumber = 0;\n            data.executionStatus = 'idle';\n            data.scheduledCell = new Set();\n            clearTimeout(data.timeout);\n            clearInterval(data.interval);\n            data.needReset = false;\n        }\n        get renderFlag() {\n            return this._renderFlag;\n        }\n        updateRenderOption(options) {\n            if (this.displayOption.showOnToolBar) {\n                if (!options.showOnToolBar) {\n                    this._renderFlag = false;\n                }\n                else {\n                    this._renderFlag = true;\n                }\n            }\n            this.displayOption.showProgress = options.showProgress;\n            this.stateChanged.emit(void 0);\n        }\n    }\n    ExecutionIndicator.Model = Model;\n    function createExecutionIndicatorItem(panel, translator, loadSettings) {\n        const toolbarItem = new ExecutionIndicator(translator);\n        toolbarItem.model.displayOption = {\n            showOnToolBar: true,\n            showProgress: true\n        };\n        toolbarItem.model.attachNotebook({\n            content: panel.content,\n            context: panel.sessionContext\n        });\n        if (loadSettings) {\n            loadSettings\n                .then(settings => {\n                const updateSettings = (newSettings) => {\n                    toolbarItem.model.updateRenderOption(getSettingValue(newSettings));\n                };\n                settings.changed.connect(updateSettings);\n                updateSettings(settings);\n                toolbarItem.disposed.connect(() => {\n                    settings.changed.disconnect(updateSettings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        return toolbarItem;\n    }\n    ExecutionIndicator.createExecutionIndicatorItem = createExecutionIndicatorItem;\n    function getSettingValue(settings) {\n        let showOnToolBar = true;\n        let showProgress = true;\n        const configValues = settings.get('kernelStatus').composite;\n        if (configValues) {\n            showOnToolBar = !configValues.showOnStatusBar;\n            showProgress = configValues.showProgress;\n        }\n        return { showOnToolBar, showProgress };\n    }\n    ExecutionIndicator.getSettingValue = getSettingValue;\n})(ExecutionIndicator || (ExecutionIndicator = {}));\n//# sourceMappingURL=executionindicator.js.map"],"names":["JUPYTER_CELL_MIME","KernelError","Error","constructor","content","errorContent","errorName","ename","errorValue","evalue","super","this","traceback","Object","setPrototypeOf","prototype","NotebookActions","executed","Private","executionScheduled","selectionExecuted","addCells","notebook","mode","values","cellsFromClipboard","model","activeCell","state","getState","newCells","map","cell","cell_type","lastClipboardInteraction","id","cell_id","contentFactory","createCodeCell","createMarkdownCell","createRawCell","cells","index","beginCompoundOperation","activeCellIndex","widgets","forEach","child","childIndex","isSelectedOrActive","toDelete","deletable","metadata","get","push","length","reverse","i","remove","insert","endCompoundOperation","deselectAll","handleState","setHeadingCollapse","collapsing","which","findIndex","possibleCell","selectedHeadingInfo","getHeadingInfo","isHidden","MarkdownCell","isHeading","cellNum","localCollapsed","localCollapsedLevel","subCell","subCellHeadingInfo","headingLevel","setHidden","collapsed","numberChildNodes","setCellCollapse","level","headingInfo","headingCollapsed","splitCell","isNotebookRendered","nbModel","editor","selections","getSelections","orig","value","text","offsets","start","end","getOffsetAt","clones","clone","cloneCell","type","outputs","clear","slice","replace","set","activeCellDelta","focus","mergeCells","mergeAbove","toMerge","primary","active","attachments","isRawCellModel","isMarkdownCellModel","key","keys","toJSON","cellModel","unshift","newModel","join","isCodeCellModel","fromJSON","removeValue","rendered","deleteCells","insertAbove","createCell","notebookConfig","defaultCell","insertBelow","moveDown","move","select","deselect","moveUp","changeCellType","run","sessionContext","Promise","resolve","promise","runSelected","handleRunState","runAndAdvance","runAndInsert","runAll","renderAllMarkdown","previousIndex","runAllAbove","runAllBelow","replaceSelection","_a","_b","call","selectAbove","possibleNextCellIndex","possibleNextCell","inputHidden","selectBelow","maxCellIndex","extendSelectionAbove","toTop","extendContiguousSelectionTo","extendSelectionBelow","toBottom","selectAll","copy","copyOrCut","cut","paste","clipboard","Clipboard","hasData","getData","duplicate","selectedCells","undo","sharedModel","redo","toggleAllLineNumbers","config","editorConfig","lineNumbers","code","markdown","raw","newConfig","assign","clearOutputs","each","clearExecution","outputHidden","clearAllOutputs","hideCode","showCode","hideAllCode","showAllCode","hideOutput","showOutput","hideAllOutputs","renderSideBySide","renderingLayout","renderDefault","showAllOutputs","enableOutputScrolling","outputsScrolled","disableOutputScrolling","selectLastRunCell","latestTime","latestCellIdx","cellIndx","execution","JSONExt","undefined","timestamp","toString","startTime","Date","setMarkdownHeader","Math","min","max","collapseAll","expandAllHeadings","expandParent","nearestParentCell","childHeaderInfo","cellN","hInfo","findNearestParentHeader","findNextParentHeading","toggleCurrentHeadingCollapse","ElementExt","node","trust","translator","trans","nullTranslator","load","toArray","trusted","every","trustMessage","__","href","target","rel","showDialog","body","buttons","Dialog","label","then","title","result","button","accept","wasFocused","contains","document","activeElement","scrollIfNeeded","activate","deletedCells","Signal","remainingCellToRenderCount","catch","reason","console","error","scroll","rect","inputArea","getBoundingClientRect","scrollToPosition","bottom","lastIndex","selected","filter","all","_c","emit","success","isTerminating","session","path","pendingInput","hasNoKernel","sessionContextDialogs","CodeCell","recordTiming","reply","splice","isDisposed","status","payload","setNextInput","source","newCell","ArrayExt","handlePayload","message","startsWith","ran","runCell","results","lastCell","update","executionCount","setPrompt","cellJSON","data","setData","newHeader","Array","matches","exec","ToolbarItems","createSaveButton","panel","onClick","context","readOnly","save","createCheckpoint","addToolbarButtonClass","ReactWidget","UseSignal","signal","fileChanged","ToolbarButtonComponent","icon","saveIcon","tooltip","enabled","contentsModel","writable","createInsertButton","ToolbarButton","addIcon","createCutButton","cutIcon","createCopyButton","copyIcon","createPasteButton","pasteIcon","createRunButton","runIcon","createRestartRunAllButton","dialogs","fastForwardIcon","restart","restarted","createCellTypeItem","CellTypeSwitcher","getDefaultItems","sessionDialogs","name","widget","Toolbar","handleChange","event","_notebook","handleKeyDown","keyCode","_trans","addClass","activeCellChanged","connect","selectionChanged","render","HTMLSelect","className","onChange","onKeyDown","CellList","modelDB","factory","_mutex","_isDisposed","_changed","_factory","_cellOrder","createList","_cellMap","ObservableMap","changed","_onOrderChanged","nbmodel","onSharedModelChanged","onModelDBChanged","self","change","transact","deleteCellRange","oldIndex","oldValues","newValues","insertLocation","newIndex","insertCells","switchSharedModel","from","currpos","cellsChange","delta","nbcell","insertAll","delete","removeRange","retain","isEmpty","iter","arr","ArrayIterator","dispose","fromIndex","toIndex","pushAll","startIndex","endIndex","canRedo","canUndo","isUndoAble","clearUndo","clearUndoHistory","order","existingCell","createValue","isStandalone","freshCell","UNSHARED_KEYS","NotebookModel","options","_modelDBMutex","_readOnly","_contentChanged","_stateChanged","_nbformat","_nbformatMinor","ModelDB","disableDocumentWideUndoRedo","_isInitialized","isInitialized","defaultContentFactory","view","_cells","_onCellsChanged","createMap","has","languagePreference","_ensureMetadata","_onMetadataChanged","_deletedCells","dirty","_onStateChanged","contentChanged","stateChanged","newValue","oldValue","triggerStateChange","nbformat","nbformatMinor","defaultKernelName","spec","defaultKernelLanguage","info","JSON","stringify","fromString","parse","getMetadata","nbformat_minor","useId","origNbformat","orig_nbformat","msg","initialize","list","triggerContentChange","sender","changes","stateChange","metadataChange","entries","includes","updateMetadata","display_name","args","ContentFactory","codeCellContentFactory","CodeCellModel","UUID","MarkdownCellModel","RawCellModel","NotebookModelFactory","_disposed","_disableDocumentWideUndoRedo","contentType","fileFormat","createNew","preferredLanguage","CommandEditComponent","props","TextItem","modeNames","notebookMode","CommandEditStatus","VDomRenderer","Model","_modeNames","command","edit","VDomModel","arguments","_onChanged","oldMode","_notebookMode","_triggerChange","oldNotebook","disconnect","modelContentChanged","oldState","newState","RankedPanel","Widget","_items","layout","PanelLayout","addWidget","rank","rankItem","itemCmp","insertWidget","onChildRemoved","item","NotebookTools","_commonTools","_advancedTools","Collapse","_tracker","tracker","currentChanged","_onActiveNotebookPanelChanged","_onActiveCellChanged","_onSelectionChanged","currentWidget","activeNotebookPanel","addItem","tool","section","notebookTools","MessageLoop","ActiveNotebookPanelMessage","ActiveCellMessage","_prevActiveNotebookModel","_onActiveNotebookPanelMetadataChanged","activeNBModel","_toolChildren","_prevActiveCell","_onActiveCellMetadataChanged","SelectionMessage","ObservableJSON","chain","children","ConflatableMessage","Tool","processMessage","onActiveNotebookPanelChanged","onActiveCellChanged","onSelectionChanged","onActiveCellMetadataChanged","onActiveNotebookPanelMetadataChanged","ActiveCellTool","_model","CodeEditor","count","_cellModel","_onValueChanged","mimeTypeChanged","_onMimeTypeChanged","promptNode","cloneNode","prompt","editorFactory","split","mimeType","editorWidget","CodeEditorWrapper","setOption","MetadataEditorTool","JSONEditor","titleNode","createElement","textContent","NotebookMetadataEditorTool","_update","nb","CellMetadataEditorTool","KeySelector","createSelectorNode","_getValue","_default","_setValue","_changeGuard","default","_validCellTypes","validCellTypes","_getter","getter","_setter","setter","selectNode","getElementsByTagName","handleEvent","onValueChanged","onAfterAttach","addEventListener","onBeforeDetach","removeEventListener","disabled","cellType","indexOf","createSlideShowSelector","optionValueArray","create","slide_type","createNBConvertSelector","first","second","toLocaleUpperCase","optionNodes","option","h","VirtualDOM","Styling","NB_CELL_CLASS","EDIT_CLASS","COMMAND_CLASS","ACTIVE_CLASS","SELECTED_CLASS","OTHER_SELECTED_CLASS","DROP_TARGET_CLASS","DROP_SOURCE_CLASS","DRAG_IMAGE_CLASS","CELL_DRAG_CONTENT_CLASS","CELL_DRAG_PROMPT_CLASS","CELL_DRAG_MULTIPLE_BACK","SIDE_BY_SIDE_CLASS","window","requestIdleCallback","handler","now","setTimeout","didTimeout","timeRemaining","cancelIdleCallback","clearTimeout","StaticNotebook","_editorConfig","defaultEditorConfig","_notebookConfig","defaultNotebookConfig","_mimetype","_modelChanged","_modelContentChanged","_fullyRendered","_placeholderCellRendered","_renderedCellsCount","_renderingLayoutChanged","dataset","rendermime","NotebookPanelLayout","_mimetypeService","mimeTypeService","_idleCallBack","_toRenderMap","Map","_observer","IntersectionObserver","observer","o","isIntersecting","unobserve","ci","_renderPlaceholderCell","root","threshold","rootMargin","observedTopMargin","observedBottomMargin","fullyRendered","placeholderCellRendered","modelChanged","renderingLayoutChanged","isCollaborative","connected","collaborators","_onCollaboratorsChanged","_onModelChanged","onModelChanged","codeMimetype","_updateEditorConfig","_updateNotebookConfig","_renderingLayout","classList","add","onModelContentChanged","onMetadataChanged","_updateMimetype","onCellInserted","onCellMoved","onCellRemoved","_removeCell","_insertCell","insertType","_moveCell","requestAnimationFrame","_createCodeCell","_createMarkdownCell","_createRawCell","numberCellsToRenderDirectly","placeholder","_createPlaceholderCell","observe","_incrementRenderedCount","_scheduleCellRenderOnIdle","renderCellOnIdle","renderPlaceholderCells","_renderPlaceholderCells","bind","timeout","deadline","remainingTimeBeforeRescheduling","next","pl","removeWidgetAt","updateEditorOnShow","maxNumberOutputs","syncCollapse","syncEditable","syncScrolled","showEditorForReadOnlyMarkdown","toggleCollapsedSignal","innerHTML","parent","getMimeTypeByLanguage","setOptions","refresh","toggleClass","scrollPastEnd","showEditorForReadOnly","size","lineWrap","matchBrackets","autoClosingBrackets","sideBySideLeftMarginOverride","sideBySideRightMarginOverride","sideBySideOutputRatio","Cell","initializeState","RawCell","Notebook","processNotebookOptions","_activeCellIndex","_activeCell","_mode","_drag","_fragment","_dragData","_mouseMode","_activeCellChanged","_selectionChanged","_checkCacheOnNextResize","_lastClipboardInteraction","tabIndex","setAttribute","_ensureFocus","_trimSelections","selectedProperty","isSelected","head","anchor","getContiguousSelection","c","last","activeIndex","position","ar","top","height","abs","scrollTop","scrollToCell","setFragment","fragment","ready","eventPhase","Event","CAPTURING_PHASE","_evtContextMenuCapture","_evtMouseDownCapture","_evtMouseDown","currentTarget","_evtDocumentMouseup","_evtDocumentMousemove","_evtDblClick","_evtFocusIn","_evtFocusOut","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","onAfterShow","onResize","cache","_cellLayoutStateCache","width","parseInt","style","w","onBeforeHide","onActivateRequest","onUpdateRequest","removeClass","el","querySelector","CSS","escape","warn","scrollIntoView","localCollaborator","uuid","sessionId","selectionStyle","color","edgeRequested","_onEdgeRequest","location","prev","lastLine","lineCount","setCursorPosition","line","column","force","hasFocus","_findCell","n","parentElement","_findEventTargetAndCell","elementFromPoint","clientX","clientY","shiftKey","preventDefault","targetArea","hasSelection","getSelection","e","pressX","pressY","stopPropagation","dx","dy","_startDrag","mimeData","elements","getElementsByClassName","dropAction","proposedAction","toMove","nextParent","cellWidget","countString","dragImage","createDragImage","Drag","MimeData","supportedActions","action","relatedTarget","localName","toggle","AttachedProperty","promptNumber","cellContent","SEARCH_DOCUMENT_LOADED_CLASS","NotebookPanel","DocumentWidget","_autorestarting","toolbar","kernelChanged","_onKernelChanged","statusChanged","_onSessionStatusChanged","_onFullyRendered","saveState","_onSave","revealed","setConfig","kernelPreference","shutdownOnDispose","kernelShutdown","Printing","async","PageConfig","format","download","kernel","_updateLanguage","language_info","_updateSpec","language","createNotebook","IContentFactory","Token","INotebookWidgetFactory","INotebookTools","INotebookTracker","NotebookTracker","WidgetTracker","onCurrentChanged","NotebookTrustComponent","allCellsTrusted","trustedIcon","stylesheet","notTrustedIcon","NotebookTrustStatus","trustedCells","totalCells","activeCellTrusted","cellTrust","_trustedCells","_totalCells","_activeCellTrusted","_getAllState","total","_deriveCellTrustState","reduce","accum","current","NotebookWidgetFactory","ABCWidgetFactory","_sessionDialogs","createNewWidget","nbOptions","resolver","urlResolver","defaultToolbarFactory","ExecutionIndicatorComponent","kernelStatuses","translateKernelStatuses","showOnToolBar","displayOption","showProgress","tooltipClass","emptyDiv","kernelStatus","circleIconProps","alignSelf","time","totalTime","scheduledCellNumber","executedCellNumber","scheduledCell","percentage","displayClass","progressBar","ProgressCircle","progress","titleFactory","translatedStatus","reactElement","circle","popup","offlineBoltIcon","circleIcon","executionStatus","_n","ExecutionIndicator","interactiveItem","renderFlag","currentNotebook","executionState","_notebookExecutionProgress","WeakMap","_displayOption","_renderFlag","attachNotebook","_d","_currentNotebook","interval","Set","needReset","contextStatusChanged","ctx","kernelDisplayStatus","contextConnectionStatusChanged","connectionStatusChanged","disposed","handleKernelMsg","msgId","header","msg_id","msg_type","_cellScheduledCallback","KernelMessage","execution_state","parentId","parent_header","_cellExecutedCallback","_startTimer","anyMessage","kernelChangedSlot","_","kernelData","_resetTime","clearInterval","setInterval","_tick","updateRenderOption","getSettingValue","settings","configValues","composite","showOnStatusBar","createExecutionIndicatorItem","loadSettings","toolbarItem","updateSettings","newSettings"],"sourceRoot":""}
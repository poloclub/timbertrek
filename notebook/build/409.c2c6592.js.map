{"version":3,"file":"409.c2c6592.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/signaling/dist/index.es6.js"],"sourcesContent":["import { find, each, ArrayExt } from '@lumino/algorithm';\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A concrete implementation of `ISignal`.\n *\n * #### Example\n * ```typescript\n * import { ISignal, Signal } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get valueChanged: ISignal<this, number> {\n *     return this._valueChanged;\n *   }\n *\n *   get value(): number {\n *     return this._value;\n *   }\n *\n *   set value(value: number) {\n *     if (value === this._value) {\n *       return;\n *     }\n *     this._value = value;\n *     this._valueChanged.emit(value);\n *   }\n *\n *   private _value = 0;\n *   private _valueChanged = new Signal<this, number>(this);\n * }\n *\n * function logger(sender: SomeClass, value: number): void {\n *   console.log(sender.name, value);\n * }\n *\n * let m1 = new SomeClass('foo');\n * let m2 = new SomeClass('bar');\n *\n * m1.valueChanged.connect(logger);\n * m2.valueChanged.connect(logger);\n *\n * m1.value = 42;  // logs: foo 42\n * m2.value = 17;  // logs: bar 17\n * ```\n */\nvar Signal = /** @class */ (function () {\n    /**\n     * Construct a new signal.\n     *\n     * @param sender - The sender which owns the signal.\n     */\n    function Signal(sender) {\n        this.sender = sender;\n    }\n    /**\n     * Connect a slot to the signal.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    Signal.prototype.connect = function (slot, thisArg) {\n        return Private.connect(this, slot, thisArg);\n    };\n    /**\n     * Disconnect a slot from the signal.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    Signal.prototype.disconnect = function (slot, thisArg) {\n        return Private.disconnect(this, slot, thisArg);\n    };\n    /**\n     * Emit the signal and invoke the connected slots.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    Signal.prototype.emit = function (args) {\n        Private.emit(this, args);\n    };\n    return Signal;\n}());\n/**\n * The namespace for the `Signal` class statics.\n */\n(function (Signal) {\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectBetween(sender, receiver) {\n        Private.disconnectBetween(sender, receiver);\n    }\n    Signal.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        Private.disconnectSender(sender);\n    }\n    Signal.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectReceiver(receiver) {\n        Private.disconnectReceiver(receiver);\n    }\n    Signal.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectAll(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.disconnectAll = disconnectAll;\n    /**\n     * Clear all signal data associated with the given object.\n     *\n     * @param object - The object for which the data should be cleared.\n     *\n     * #### Notes\n     * This removes all signal connections and any other signal data\n     * associated with the object.\n     */\n    function clearData(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.clearData = clearData;\n    /**\n     * Get the signal exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return Private.exceptionHandler;\n    }\n    Signal.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the signal exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a slot throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        var old = Private.exceptionHandler;\n        Private.exceptionHandler = handler;\n        return old;\n    }\n    Signal.setExceptionHandler = setExceptionHandler;\n})(Signal || (Signal = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The signal exception handler function.\n     */\n    Private.exceptionHandler = function (err) {\n        console.error(err);\n    };\n    /**\n     * Connect a slot to a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    function connect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Ensure the sender's array of receivers is created.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers) {\n            receivers = [];\n            receiversForSender.set(signal.sender, receivers);\n        }\n        // Bail if a matching connection already exists.\n        if (findConnection(receivers, signal, slot, thisArg)) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        var receiver = thisArg || slot;\n        // Ensure the receiver's array of senders is created.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders) {\n            senders = [];\n            sendersForReceiver.set(receiver, senders);\n        }\n        // Create a new connection and add it to the end of each array.\n        var connection = { signal: signal, slot: slot, thisArg: thisArg };\n        receivers.push(connection);\n        senders.push(connection);\n        // Indicate a successful connection.\n        return true;\n    }\n    Private.connect = connect;\n    /**\n     * Disconnect a slot from a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    function disconnect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Lookup the list of receivers, and bail if none exist.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return false;\n        }\n        // Bail if no matching connection exits.\n        var connection = findConnection(receivers, signal, slot, thisArg);\n        if (!connection) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        var receiver = thisArg || slot;\n        // Lookup the array of senders, which is now known to exist.\n        var senders = sendersForReceiver.get(receiver);\n        // Clear the connection and schedule cleanup of the arrays.\n        connection.signal = null;\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n        // Indicate a successful disconnection.\n        return true;\n    }\n    Private.disconnect = disconnect;\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectBetween(sender, receiver) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // If there are no senders, there is nothing to do.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each connection between the sender and receiver.\n        each(senders, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Clear the connection if it matches the sender.\n            if (connection.signal.sender === sender) {\n                connection.signal = null;\n            }\n        });\n        // Schedule a cleanup of the senders and receivers.\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n    }\n    Private.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Clear each receiver connection.\n        each(receivers, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Choose the best object for the receiver.\n            var receiver = connection.thisArg || connection.slot;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of senders, which is now known to exist.\n            scheduleCleanup(sendersForReceiver.get(receiver));\n        });\n        // Schedule a cleanup of the receivers.\n        scheduleCleanup(receivers);\n    }\n    Private.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectReceiver(receiver) {\n        // If there are no senders, there is nothing to do.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each sender connection.\n        each(senders, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Lookup the sender for the connection.\n            var sender = connection.signal.sender;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of receivers, which is now known to exist.\n            scheduleCleanup(receiversForSender.get(sender));\n        });\n        // Schedule a cleanup of the list of senders.\n        scheduleCleanup(senders);\n    }\n    Private.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     */\n    function disconnectAll(object) {\n        // Remove all connections where the given object is the sender.\n        disconnectSender(object);\n        // Remove all connections where the given object is the receiver.\n        disconnectReceiver(object);\n    }\n    Private.disconnectAll = disconnectAll;\n    /**\n     * Emit a signal and invoke its connected slots.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    function emit(signal, args) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Invoke the slots for connections with a matching signal.\n        // Any connections added during emission are not invoked.\n        for (var i = 0, n = receivers.length; i < n; ++i) {\n            var connection = receivers[i];\n            if (connection.signal === signal) {\n                invokeSlot(connection, args);\n            }\n        }\n    }\n    Private.emit = emit;\n    /**\n     * A weak mapping of sender to array of receiver connections.\n     */\n    var receiversForSender = new WeakMap();\n    /**\n     * A weak mapping of receiver to array of sender connections.\n     */\n    var sendersForReceiver = new WeakMap();\n    /**\n     * A set of connection arrays which are pending cleanup.\n     */\n    var dirtySet = new Set();\n    /**\n     * A function to schedule an event loop callback.\n     */\n    var schedule = (function () {\n        var ok = typeof requestAnimationFrame === 'function';\n        // @ts-ignore\n        return ok ? requestAnimationFrame : setImmediate;\n    })();\n    /**\n     * Find a connection which matches the given parameters.\n     */\n    function findConnection(connections, signal, slot, thisArg) {\n        return find(connections, function (connection) {\n            return connection.signal === signal &&\n                connection.slot === slot &&\n                connection.thisArg === thisArg;\n        });\n    }\n    /**\n     * Invoke a slot with the given parameters.\n     *\n     * The connection is assumed to be valid.\n     *\n     * Exceptions in the slot will be caught and logged.\n     */\n    function invokeSlot(connection, args) {\n        var signal = connection.signal, slot = connection.slot, thisArg = connection.thisArg;\n        try {\n            slot.call(thisArg, signal.sender, args);\n        }\n        catch (err) {\n            Private.exceptionHandler(err);\n        }\n    }\n    /**\n     * Schedule a cleanup of a connection array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any connection with a\n     * `null` signal will be removed from the array.\n     */\n    function scheduleCleanup(array) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(array);\n    }\n    /**\n     * Cleanup the connection lists in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupConnections);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty connections in a connections array.\n     *\n     * This will remove any connection with a `null` signal.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupConnections(connections) {\n        ArrayExt.removeAllWhere(connections, isDeadConnection);\n    }\n    /**\n     * Test whether a connection is dead.\n     *\n     * A dead connection has a `null` signal.\n     */\n    function isDeadConnection(connection) {\n        return connection.signal === null;\n    }\n})(Private || (Private = {}));\n\nexport { Signal };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Private","Signal","sender","this","prototype","connect","slot","thisArg","disconnect","emit","args","disconnectBetween","receiver","disconnectSender","disconnectReceiver","disconnectAll","object","clearData","getExceptionHandler","exceptionHandler","setExceptionHandler","handler","old","receivers","receiversForSender","get","length","each","connection","signal","scheduleCleanup","sendersForReceiver","senders","err","console","error","undefined","set","findConnection","push","i","n","invokeSlot","WeakMap","dirtySet","Set","schedule","requestAnimationFrame","setImmediate","connections","find","call","array","size","cleanupDirtySet","add","forEach","cleanupConnections","clear","ArrayExt","isDeadConnection"],"sourceRoot":""}
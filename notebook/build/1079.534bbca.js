"use strict";(self.webpackChunk_JUPYTERLAB_CORE_OUTPUT=self.webpackChunk_JUPYTERLAB_CORE_OUTPUT||[]).push([[1079],{41079:(e,t,n)=>{n.r(t),n.d(t,{PyoliteKernel:()=>i});var s=n(10537),a=n(28861),r=n(74547),o=n(51470);class i extends a.BaseKernel{constructor(e){super(e),this._executeDelegate=new r.PromiseDelegate,this._ready=new r.PromiseDelegate;const t=new Blob([this.buildWorkerScript(e).join("\n")]);this._worker=new Worker(window.URL.createObjectURL(t)),this._worker.onmessage=e=>{this._processWorkerMessage(e.data)},this._ready.resolve()}buildWorkerScript(e){const{pyodideUrl:t}=e,n=t.slice(0,t.lastIndexOf("/")+1),a=s.URLExt.join(s.PageConfig.getBaseUrl(),"build/pypi"),r=[...e.pipliteUrls||[],s.URLExt.join(a,"all.json")],i=s.URLExt.join(a,"piplite-0.1.0b3-py3-none-any.whl");return[`importScripts("${e.pyodideUrl}");`,`var indexURL = "${n}";`,`var _pipliteWheelUrl = "${i}";`,`var _pipliteUrls = ${JSON.stringify(r)};`,`var _disablePyPIFallback = ${JSON.stringify(!!e.disablePyPIFallback)};`,o.toString()]}dispose(){this.isDisposed||(this._worker.terminate(),super.dispose())}get ready(){return this._ready.promise}_processWorkerMessage(e){var t,n,s,a,r,o,i;switch(e.type){case"stream":{const n=null!==(t=e.bundle)&&void 0!==t?t:{name:"stdout",text:""};this.stream(n,e.parentHeader);break}case"input_request":{const t=null!==(n=e.content)&&void 0!==n?n:{prompt:"",password:!1};this.inputRequest(t,e.parentHeader);break}case"reply":{const t=e.results;this._executeDelegate.resolve(t);break}case"display_data":{const t=null!==(s=e.bundle)&&void 0!==s?s:{data:{},metadata:{},transient:{}};this.displayData(t,e.parentHeader);break}case"update_display_data":{const t=null!==(a=e.bundle)&&void 0!==a?a:{data:{},metadata:{},transient:{}};this.updateDisplayData(t,e.parentHeader);break}case"clear_output":{const t=null!==(r=e.bundle)&&void 0!==r?r:{wait:!1};this.clearOutput(t,e.parentHeader);break}case"execute_result":{const t=null!==(o=e.bundle)&&void 0!==o?o:{execution_count:0,data:{},metadata:{}};this.publishExecuteResult(t,e.parentHeader);break}case"execute_error":{const t=null!==(i=e.bundle)&&void 0!==i?i:{ename:"",evalue:"",traceback:[]};this.publishExecuteError(t,e.parentHeader);break}case"comm_msg":case"comm_open":case"comm_close":this.handleComm(e.type,e.content,e.metadata,e.buffers,e.parentHeader);break;default:this._executeDelegate.resolve({data:{},metadata:{}})}}async kernelInfoRequest(){return{implementation:"pyodide",implementation_version:"0.1.0",language_info:{codemirror_mode:{name:"python",version:3},file_extension:".py",mimetype:"text/x-python",name:"python",nbconvert_exporter:"python",pygments_lexer:"ipython3",version:"3.8"},protocol_version:"5.3",status:"ok",banner:"Pyolite: A WebAssembly-powered Python kernel backed by Pyodide",help_links:[{text:"Python (WASM) Kernel",url:"https://pyodide.org"}]}}async executeRequest(e){const t=await this._sendRequestMessageToWorker("execute-request",e);return{execution_count:this.executionCount,...t}}async completeRequest(e){return await this._sendRequestMessageToWorker("complete-request",e)}async inspectRequest(e){return await this._sendRequestMessageToWorker("inspect-request",e)}async isCompleteRequest(e){return await this._sendRequestMessageToWorker("is-complete-request",e)}async commInfoRequest(e){return await this._sendRequestMessageToWorker("comm-info-request",e)}inputReply(e){this._worker.postMessage({type:"input-reply",data:e,parent:this.parent})}async commOpen(e){return await this._sendRequestMessageToWorker("comm-open",e)}async commMsg(e){return await this._sendRequestMessageToWorker("comm-msg",e)}async commClose(e){return await this._sendRequestMessageToWorker("comm-close",e)}async _sendRequestMessageToWorker(e,t){return this._executeDelegate=new r.PromiseDelegate,this._worker.postMessage({type:e,data:t,parent:this.parent}),await this._executeDelegate.promise}}},51470:e=>{e.exports="\"use strict\";\n/**\n * Store the kernel and interpreter instances.\n */\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet kernel;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet interpreter;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet pyodide;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet stdout_stream;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet stderr_stream;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet resolveInputReply;\n/**\n * Load pyodide and initialize the interpreter.\n *\n * The first package loaded, `piplite`, is a build-time configurable wrapper\n * around `micropip` that supports multiple warehouse API endpoints, as well\n * as a multipackage summary JSON format in `all.json`.\n */\nasync function loadPyodideAndPackages() {\n    // as of 0.17.0 indexURL must be provided\n    pyodide = await loadPyodide({ indexURL });\n    // this is the only use of `loadPackage`, allow `piplite` to handle the rest\n    await pyodide.loadPackage(['micropip']);\n    // get piplite early enough to impact pyolite dependencies\n    await pyodide.runPythonAsync(`\n    import micropip\n    await micropip.install('${_pipliteWheelUrl}', keep_going=True)\n    import piplite.piplite\n    piplite.piplite._PIPLITE_DISABLE_PYPI = ${_disablePyPIFallback ? 'True' : 'False'}\n    piplite.piplite._PIPLITE_URLS = ${JSON.stringify(_pipliteUrls)}\n  `);\n    // from this point forward, only use piplite\n    await pyodide.runPythonAsync(`\n    await piplite.install([\n      'matplotlib',\n      'traitlets',\n      'widgetsnbextension',\n      'nbformat',\n      'ipykernel',\n    ], keep_going=True)\n    await piplite.install([\n      'pyolite',\n    ], keep_going=True);\n    await piplite.install([\n      'ipython',\n    ], keep_going=True);\n    import pyolite\n  `);\n    // make copies of these so they don't get garbage collected\n    kernel = pyodide.globals.get('pyolite').kernel_instance.copy();\n    stdout_stream = pyodide.globals.get('pyolite').stdout_stream.copy();\n    stderr_stream = pyodide.globals.get('pyolite').stderr_stream.copy();\n    interpreter = kernel.interpreter.copy();\n    interpreter.send_comm = sendComm;\n}\n/**\n * Recursively convert a Map to a JavaScript object\n * @param The Map object to convert\n */\nfunction mapToObject(obj) {\n    const out = obj instanceof Array ? [] : {};\n    obj.forEach((value, key) => {\n        out[key] =\n            value instanceof Map || value instanceof Array ? mapToObject(value) : value;\n    });\n    return out;\n}\n/**\n * Format the response from the Pyodide evaluation.\n *\n * @param res The result object from the Pyodide evaluation\n */\nfunction formatResult(res) {\n    if (!pyodide.isPyProxy(res)) {\n        return res;\n    }\n    // TODO: this is a bit brittle\n    const m = res.toJs();\n    const results = mapToObject(m);\n    return results;\n}\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nconst pyodideReadyPromise = loadPyodideAndPackages();\n/**\n * Send a comm message to the front-end.\n *\n * @param type The type of the comm message.\n * @param content The content.\n * @param metadata The metadata.\n * @param ident The ident.\n * @param buffers The binary buffers.\n */\nasync function sendComm(type, content, metadata, ident, buffers) {\n    postMessage({\n        type: type,\n        content: formatResult(content),\n        metadata: formatResult(metadata),\n        ident: formatResult(ident),\n        buffers: formatResult(buffers),\n        parentHeader: formatResult(kernel._parent_header)['header'],\n    });\n}\nasync function getpass(prompt) {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await sendInputRequest(prompt, true);\n    const replyPromise = new Promise((resolve) => {\n        resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result['value'];\n}\nasync function input(prompt) {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await sendInputRequest(prompt, false);\n    const replyPromise = new Promise((resolve) => {\n        resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result['value'];\n}\n/**\n * Send a input request to the front-end.\n *\n * @param prompt the text to show at the prompt\n * @param password Is the request for a password?\n */\nasync function sendInputRequest(prompt, password) {\n    const content = {\n        prompt,\n        password,\n    };\n    postMessage({\n        type: 'input_request',\n        parentHeader: formatResult(kernel._parent_header)['header'],\n        content,\n    });\n}\n/**\n * Execute code with the interpreter.\n *\n * @param content The incoming message with the code to execute.\n */\nasync function execute(content) {\n    const publishExecutionResult = (prompt_count, data, metadata) => {\n        const bundle = {\n            execution_count: prompt_count,\n            data: formatResult(data),\n            metadata: formatResult(metadata),\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'execute_result',\n        });\n    };\n    const publishExecutionError = (ename, evalue, traceback) => {\n        const bundle = {\n            ename: ename,\n            evalue: evalue,\n            traceback: traceback,\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'execute_error',\n        });\n    };\n    const clearOutputCallback = (wait) => {\n        const bundle = {\n            wait: formatResult(wait),\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'clear_output',\n        });\n    };\n    const displayDataCallback = (data, metadata, transient) => {\n        const bundle = {\n            data: formatResult(data),\n            metadata: formatResult(metadata),\n            transient: formatResult(transient),\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'display_data',\n        });\n    };\n    const updateDisplayDataCallback = (data, metadata, transient) => {\n        const bundle = {\n            data: formatResult(data),\n            metadata: formatResult(metadata),\n            transient: formatResult(transient),\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'update_display_data',\n        });\n    };\n    const publishStreamCallback = (name, text) => {\n        const bundle = {\n            name: formatResult(name),\n            text: formatResult(text),\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'stream',\n        });\n    };\n    stdout_stream.publish_stream_callback = publishStreamCallback;\n    stderr_stream.publish_stream_callback = publishStreamCallback;\n    interpreter.display_pub.clear_output_callback = clearOutputCallback;\n    interpreter.display_pub.display_data_callback = displayDataCallback;\n    interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n    interpreter.displayhook.publish_execution_result = publishExecutionResult;\n    interpreter.input = input;\n    interpreter.getpass = getpass;\n    const res = await kernel.run(content.code);\n    const results = formatResult(res);\n    if (results['status'] === 'error') {\n        publishExecutionError(results['ename'], results['evalue'], results['traceback']);\n    }\n    return results;\n}\n/**\n * Complete the code submitted by a user.\n *\n * @param content The incoming message with the code to complete.\n */\nfunction complete(content) {\n    const res = kernel.complete(content.code, content.cursor_pos);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Inspect the code submitted by a user.\n *\n * @param content The incoming message with the code to inspect.\n */\nfunction inspect(content) {\n    const res = kernel.inspect(content.code, content.cursor_pos, content.detail_level);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Check code for completeness submitted by a user.\n *\n * @param content The incoming message with the code to check.\n */\nfunction isComplete(content) {\n    const res = kernel.is_complete(content.code);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commInfoRequest.\n *\n * @param content The incoming message with the comm target name.\n */\nfunction commInfo(content) {\n    const res = kernel.comm_info(content.target_name);\n    const results = formatResult(res);\n    return {\n        comms: results,\n        status: 'ok',\n    };\n}\n/**\n * Respond to the commOpen.\n *\n * @param content The incoming message with the comm open.\n */\nfunction commOpen(content) {\n    const res = kernel.comm_manager.comm_open(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commMsg.\n *\n * @param content The incoming message with the comm msg.\n */\nfunction commMsg(content) {\n    const res = kernel.comm_manager.comm_msg(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commClose.\n *\n * @param content The incoming message with the comm close.\n */\nfunction commClose(content) {\n    const res = kernel.comm_manager.comm_close(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Process a message sent to the worker.\n *\n * @param event The message event to process\n */\nself.onmessage = async (event) => {\n    await pyodideReadyPromise;\n    const data = event.data;\n    let results;\n    const messageType = data.type;\n    const messageContent = data.data;\n    kernel._parent_header = pyodide.toPy(data.parent);\n    switch (messageType) {\n        case 'execute-request':\n            results = await execute(messageContent);\n            break;\n        case 'input-reply':\n            resolveInputReply(messageContent);\n            return;\n        case 'inspect-request':\n            results = inspect(messageContent);\n            break;\n        case 'is-complete-request':\n            results = isComplete(messageContent);\n            break;\n        case 'complete-request':\n            results = complete(messageContent);\n            break;\n        case 'comm-info-request':\n            results = commInfo(messageContent);\n            break;\n        case 'comm-open':\n            results = commOpen(messageContent);\n            break;\n        case 'comm-msg':\n            results = commMsg(messageContent);\n            break;\n        case 'comm-close':\n            results = commClose(messageContent);\n            break;\n        default:\n            break;\n    }\n    const reply = {\n        parentHeader: data.parent['header'],\n        type: 'reply',\n        results,\n    };\n    postMessage(reply);\n};\n"}}]);
//# sourceMappingURL=1079.534bbca.js.map
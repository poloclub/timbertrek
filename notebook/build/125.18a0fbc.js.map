{"version":3,"file":"125.18a0fbc.js","mappings":"qMAIO,MAAMA,EAAY,IAAI,EAAAC,MAAM,kC,0BCE5B,MAAMC,EAMTC,YAAYC,GAERC,KAAKC,UAAY,GACjBD,KAAKE,SAAWH,EAAQI,OAC5B,CAMAC,UAAUC,GACN,MAAMC,EAAUN,KAAKC,UAAUM,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACD,MAAMG,MAAM,WAAWJ,eAE3B,OAAOC,CACX,CAIAF,aACI,OAAOJ,KAAKC,SAChB,CAUAG,YAAYL,GACR,MAAM,GAAEM,EAAE,KAAEK,EAAI,KAAEC,EAAI,OAAEC,GAAWb,EAC7Bc,EAAQb,KAAKC,UAAUa,WAAWN,GAAMA,EAAEH,KAAOA,IACjDC,EAAUN,KAAKC,UAAUY,GAC/B,IAAKP,EACD,MAAMG,MAAM,WAAWJ,eAE3B,MAAMU,EAAU,IACTT,EACHI,KAAMA,QAAmCA,EAAOJ,EAAQI,KACxDC,KAAMA,QAAmCA,EAAOL,EAAQK,MAE5D,GAAIC,EAEA,GAAIA,EAAOP,GAAI,CACX,MAAMC,EAAUN,KAAKC,UAAUM,MAAMD,IAAc,IAAIU,EAAI,OAAkC,QAAzBA,EAAKV,EAAQM,cAA2B,IAAPI,OAAgB,EAASA,EAAGX,OAASO,aAAuC,EAASA,EAAOP,GAAG,IAChMC,IACAS,EAAQH,OAASN,EAAQM,OAEjC,MACK,GAAIA,EAAOD,KAAM,CAClB,MAAMM,QAAkBjB,KAAKE,SAASgB,SAAS,CAC3Cb,GAAI,EAAAc,KAAA,QACJR,KAAMC,EAAOD,KACbS,SAAU,EAAAC,QAAA,QAAgBN,EAAQL,QAElCO,IACAF,EAAQH,OAASK,EAEzB,CAGJ,OADAjB,KAAKC,UAAUY,GAASE,EACjBA,CACX,CAOAX,eAAeL,GACX,IAAIiB,EAAIM,EAAIC,EACZ,MAAM,KAAEb,EAAI,KAAEC,GAASZ,EACjByB,EAAUxB,KAAKC,UAAUM,MAAMC,GAAMA,EAAEG,OAASA,IACtD,GAAIa,EACA,OAAOA,EAEX,MAAMC,EAA2F,QAA7EH,EAA+B,QAAzBN,EAAKjB,EAAQa,cAA2B,IAAPI,OAAgB,EAASA,EAAGL,YAAyB,IAAPW,EAAgBA,EAAK,GACxHjB,EAA2B,QAArBkB,EAAKxB,EAAQM,UAAuB,IAAPkB,EAAgBA,EAAK,EAAAJ,KAAA,QACxDP,QAAeZ,KAAKE,SAASgB,SAAS,CACxCb,KACAM,KAAMc,EACNL,SAAU,EAAAC,QAAA,QAAgBtB,EAAQW,QAEhCJ,EAAU,CACZD,KACAK,OACAC,KAAMA,QAAmCA,EAAOD,EAChDgB,KAAM,WACNd,OAAQ,CACJP,GAAIO,EAAOP,GACXM,KAAMC,EAAOD,OAIrB,OADAX,KAAKC,UAAU0B,KAAKrB,GACbA,CACX,CAMAF,eAAeC,GACX,IAAIW,EACJ,MAAMV,EAAUN,KAAKC,UAAUM,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACD,MAAMG,MAAM,WAAWJ,eAE3B,MAAMuB,EAAqC,QAAzBZ,EAAKV,EAAQM,cAA2B,IAAPI,OAAgB,EAASA,EAAGX,GAC3EuB,SACM5B,KAAKE,SAAS2B,SAASD,GAEjC,EAAAE,SAAA,cAAuB9B,KAAKC,UAAWK,EAC3C,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/sessions.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token('@jupyterlite/session:ISessions');\n","import { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions {\n    /**\n     * Construct a new Sessions.\n     *\n     * @param options The instantiation options for a Sessions.\n     */\n    constructor(options) {\n        // TODO: offload to a database\n        this._sessions = [];\n        this._kernels = options.kernels;\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async get(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async list() {\n        return this._sessions;\n    }\n    /**\n     * Path an existing session.\n     * This can be used to rename a session.\n     *\n     * - path updates session to track renamed paths\n     * - kernel.name starts a new kernel with a given kernelspec\n     *\n     * @param options The options to patch the session.\n     */\n    async patch(options) {\n        const { id, path, name, kernel } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path !== null && path !== void 0 ? path : session.path,\n            name: name !== null && name !== void 0 ? name : session.name,\n        };\n        if (kernel) {\n            // Kernel id takes precedence over name.\n            if (kernel.id) {\n                const session = this._sessions.find((session) => { var _a; return ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) === (kernel === null || kernel === void 0 ? void 0 : kernel.id); });\n                if (session) {\n                    patched.kernel = session.kernel;\n                }\n            }\n            else if (kernel.name) {\n                const newKernel = await this._kernels.startNew({\n                    id: UUID.uuid4(),\n                    name: kernel.name,\n                    location: PathExt.dirname(patched.path),\n                });\n                if (newKernel) {\n                    patched.kernel = newKernel;\n                }\n            }\n        }\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        var _a, _b, _c;\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n        const id = (_c = options.id) !== null && _c !== void 0 ? _c : UUID.uuid4();\n        const kernel = await this._kernels.startNew({\n            id,\n            name: kernelName,\n            location: PathExt.dirname(options.path),\n        });\n        const session = {\n            id,\n            path,\n            name: name !== null && name !== void 0 ? name : path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        var _a;\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;\n        if (kernelId) {\n            await this._kernels.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n}\n"],"names":["ISessions","Token","Sessions","constructor","options","this","_sessions","_kernels","kernels","async","id","session","find","s","Error","path","name","kernel","index","findIndex","patched","_a","newKernel","startNew","UUID","location","PathExt","_b","_c","running","kernelName","type","push","kernelId","shutdown","ArrayExt"],"sourceRoot":""}
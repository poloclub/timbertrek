{"version":3,"file":"2363.13186d7.js","mappings":"qMAIO,MAAMA,EAAY,IAAI,EAAAC,MAAM,kC,eCC5B,MAAMC,EAMTC,YAAYC,GAERC,KAAKC,UAAY,GACjBD,KAAKE,SAAWH,EAAQI,QAO5BC,UAAUC,GACN,MAAMC,EAAUN,KAAKC,UAAUM,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACD,MAAMG,MAAM,WAAWJ,eAE3B,OAAOC,EAKXF,aACI,OAAOJ,KAAKC,UAShBG,YAAYL,GACR,MAAM,GAAEM,EAAE,KAAEK,EAAI,KAAEC,GAASZ,EACrBa,EAAQZ,KAAKC,UAAUY,WAAWL,GAAMA,EAAEH,KAAOA,IACjDC,EAAUN,KAAKC,UAAUW,GAC/B,IAAKN,EACD,MAAMG,MAAM,WAAWJ,eAE3B,MAAMS,EAAU,IACTR,EACHI,KAAMA,MAAAA,EAAmCA,EAAOJ,EAAQI,KACxDC,KAAMA,MAAAA,EAAmCA,EAAOL,EAAQK,MAG5D,OADAX,KAAKC,UAAUW,GAASE,EACjBA,EAQXV,eAAeL,GACX,IAAIgB,EAAIC,EAAIC,EACZ,MAAM,KAAEP,EAAI,KAAEC,GAASZ,EACjBmB,EAAUlB,KAAKC,UAAUM,MAAMC,GAAMA,EAAEG,OAASA,IACtD,GAAIO,EACA,OAAOA,EAEX,MAAMC,EAA2F,QAA7EH,EAA+B,QAAzBD,EAAKhB,EAAQqB,cAA2B,IAAPL,OAAgB,EAASA,EAAGJ,YAAyB,IAAPK,EAAgBA,EAAK,GACxHX,EAA2B,QAArBY,EAAKlB,EAAQM,UAAuB,IAAPY,EAAgBA,EAAK,EAAAI,KAAA,QACxDD,QAAepB,KAAKE,SAASoB,SAAS,CAAEjB,GAAAA,EAAIM,KAAMQ,IAClDb,EAAU,CACZD,GAAAA,EACAK,KAAAA,EACAC,KAAMA,MAAAA,EAAmCA,EAAOD,EAChDa,KAAM,WACNH,OAAQ,CACJf,GAAIe,EAAOf,GACXM,KAAMS,EAAOT,OAIrB,OADAX,KAAKC,UAAUuB,KAAKlB,GACbA,EAOXF,eAAeC,GACX,IAAIU,EACJ,MAAMT,EAAUN,KAAKC,UAAUM,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACD,MAAMG,MAAM,WAAWJ,eAE3B,MAAMoB,EAAqC,QAAzBV,EAAKT,EAAQc,cAA2B,IAAPL,OAAgB,EAASA,EAAGV,GAC3EoB,SACMzB,KAAKE,SAASwB,SAASD,GAEjC,EAAAE,SAAA,cAAuB3B,KAAKC,UAAWK","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/sessions.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token('@jupyterlite/session:ISessions');\n","import { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions {\n    /**\n     * Construct a new Sessions.\n     *\n     * @param options The instantiation options for a Sessions.\n     */\n    constructor(options) {\n        // TODO: offload to a database\n        this._sessions = [];\n        this._kernels = options.kernels;\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async get(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async list() {\n        return this._sessions;\n    }\n    /**\n     * Path an existing session.\n     * This can be used to rename a session.\n     * TODO: read path and name\n     *\n     * @param options The options to patch the session.\n     */\n    async patch(options) {\n        const { id, path, name } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path !== null && path !== void 0 ? path : session.path,\n            name: name !== null && name !== void 0 ? name : session.name,\n        };\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        var _a, _b, _c;\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n        const id = (_c = options.id) !== null && _c !== void 0 ? _c : UUID.uuid4();\n        const kernel = await this._kernels.startNew({ id, name: kernelName });\n        const session = {\n            id,\n            path,\n            name: name !== null && name !== void 0 ? name : path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        var _a;\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;\n        if (kernelId) {\n            await this._kernels.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n}\n"],"names":["ISessions","Token","Sessions","constructor","options","this","_sessions","_kernels","kernels","async","id","session","find","s","Error","path","name","index","findIndex","patched","_a","_b","_c","running","kernelName","kernel","UUID","startNew","type","push","kernelId","shutdown","ArrayExt"],"sourceRoot":""}
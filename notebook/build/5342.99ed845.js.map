{"version":3,"file":"5342.99ed845.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/inspector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/kernelconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler {\n    /**\n     * Construct a new inspection handler for a widget.\n     */\n    constructor(options) {\n        this._cleared = new Signal(this);\n        this._disposed = new Signal(this);\n        this._editor = null;\n        this._inspected = new Signal(this);\n        this._isDisposed = false;\n        this._pending = 0;\n        this._standby = true;\n        this._lastInspectedReply = null;\n        this._connector = options.connector;\n        this._rendermime = options.rendermime;\n        this._debouncer = new Debouncer(this.onEditorChange.bind(this), 250);\n    }\n    /**\n     * A signal emitted when the inspector should clear all items.\n     */\n    get cleared() {\n        return this._cleared;\n    }\n    /**\n     * A signal emitted when the handler is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * A signal emitted when an inspector value is generated.\n     */\n    get inspected() {\n        return this._inspected;\n    }\n    /**\n     * The editor widget used by the inspection handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        // Remove all of our listeners.\n        Signal.disconnectReceiver(this);\n        const editor = (this._editor = newValue);\n        if (editor) {\n            // Clear the inspector in preparation for a new editor.\n            this._cleared.emit(void 0);\n            // Call onEditorChange to cover the case where the user changes\n            // the active cell\n            this.onEditorChange();\n            editor.model.selections.changed.connect(this._onChange, this);\n            editor.model.value.changed.connect(this._onChange, this);\n        }\n    }\n    /**\n     * Indicates whether the handler makes API inspection requests or stands by.\n     *\n     * #### Notes\n     * The use case for this attribute is to limit the API traffic when no\n     * inspector is visible.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(value) {\n        this._standby = value;\n    }\n    /**\n     * Get whether the inspection handler is disposed.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n        Signal.clearData(this);\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     *\n     * #### Notes\n     * Update the hints inspector based on a text change.\n     */\n    onEditorChange(customText) {\n        // If the handler is in standby mode, bail.\n        if (this._standby) {\n            return;\n        }\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const text = customText ? customText : editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const update = { content: null };\n        const pending = ++this._pending;\n        void this._connector\n            .fetch({ offset, text })\n            .then(reply => {\n            // If handler has been disposed or a newer request is pending, bail.\n            if (!reply || this.isDisposed || pending !== this._pending) {\n                this._lastInspectedReply = null;\n                this._inspected.emit(update);\n                return;\n            }\n            const { data } = reply;\n            // Do not update if there would be no change.\n            if (this._lastInspectedReply &&\n                JSONExt.deepEqual(this._lastInspectedReply, data)) {\n                return;\n            }\n            const mimeType = this._rendermime.preferredMimeType(data);\n            if (mimeType) {\n                const widget = this._rendermime.createRenderer(mimeType);\n                const model = new MimeModel({ data });\n                void widget.renderModel(model);\n                update.content = widget;\n            }\n            this._lastInspectedReply = reply.data;\n            this._inspected.emit(update);\n        })\n            .catch(reason => {\n            // Since almost all failures are benign, fail silently.\n            this._lastInspectedReply = null;\n            this._inspected.emit(update);\n        });\n    }\n    /**\n     * Handle changes to the editor state, debouncing.\n     */\n    _onChange() {\n        void this._debouncer.invoke();\n    }\n}\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Printing } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Panel, Widget } from '@lumino/widgets';\n/**\n * The class name added to inspector panels.\n */\nconst PANEL_CLASS = 'jp-Inspector';\n/**\n * The class name added to inspector content.\n */\nconst CONTENT_CLASS = 'jp-Inspector-content';\n/**\n * The class name added to default inspector content.\n */\nconst DEFAULT_CONTENT_CLASS = 'jp-Inspector-default-content';\n/**\n * A panel which contains a set of inspectors.\n */\nexport class InspectorPanel extends Panel {\n    /**\n     * Construct an inspector.\n     */\n    constructor(options = {}) {\n        super();\n        this._source = null;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        if (options.initialContent instanceof Widget) {\n            this._content = options.initialContent;\n        }\n        else if (typeof options.initialContent === 'string') {\n            this._content = InspectorPanel._generateContentWidget(`<p>${options.initialContent}</p>`);\n        }\n        else {\n            this._content = InspectorPanel._generateContentWidget('<p>' +\n                this._trans.__('Click on a function to see documentation.') +\n                '</p>');\n        }\n        this.addClass(PANEL_CLASS);\n        this.layout.addWidget(this._content);\n    }\n    /**\n     * Print in iframe\n     */\n    [Printing.symbol]() {\n        return () => Printing.printWidget(this);\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Disconnect old signal handler.\n        if (this._source) {\n            this._source.standby = true;\n            this._source.inspected.disconnect(this.onInspectorUpdate, this);\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        // Reject a source that is already disposed.\n        if (source && source.isDisposed) {\n            source = null;\n        }\n        // Update source.\n        this._source = source;\n        // Connect new signal handler.\n        if (this._source) {\n            this._source.standby = false;\n            this._source.inspected.connect(this.onInspectorUpdate, this);\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    /**\n     * Handle inspector update signals.\n     */\n    onInspectorUpdate(sender, args) {\n        const { content } = args;\n        // Update the content of the inspector widget.\n        if (!content || content === this._content) {\n            return;\n        }\n        this._content.dispose();\n        this._content = content;\n        content.addClass(CONTENT_CLASS);\n        this.layout.addWidget(content);\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n    /**\n     * Generate content widget from string\n     */\n    static _generateContentWidget(message) {\n        const widget = new Widget();\n        widget.node.innerHTML = message;\n        widget.addClass(CONTENT_CLASS);\n        widget.addClass(DEFAULT_CONTENT_CLASS);\n        return widget;\n    }\n}\n//# sourceMappingURL=inspector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * The default connector for making inspection requests from the Jupyter API.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for inspection requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._sessionContext = options.sessionContext;\n    }\n    /**\n     * Fetch inspection requests.\n     *\n     * @param request - The inspection request text and details.\n     */\n    fetch(request) {\n        var _a;\n        const kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return Promise.reject(new Error('Inspection fetch requires a kernel.'));\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset,\n            detail_level: 1\n        };\n        return kernel.requestInspect(contents).then(msg => {\n            const response = msg.content;\n            if (response.status !== 'ok' || !response.found) {\n                throw new Error('Inspection fetch failed to return successfully.');\n            }\n            return { data: response.data, metadata: response.metadata };\n        });\n    }\n}\n//# sourceMappingURL=kernelconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The inspector panel token.\n */\nexport const IInspector = new Token('@jupyterlab/inspector:IInspector');\n//# sourceMappingURL=tokens.js.map"],"names":["InspectionHandler","constructor","options","this","_cleared","Signal","_disposed","_editor","_inspected","_isDisposed","_pending","_standby","_lastInspectedReply","_connector","connector","_rendermime","rendermime","_debouncer","Debouncer","onEditorChange","bind","cleared","disposed","inspected","editor","newValue","emit","model","selections","changed","connect","_onChange","value","standby","isDisposed","dispose","customText","text","position","getCursorPosition","offset","Text","getOffsetAt","update","content","pending","fetch","then","reply","data","JSONExt","mimeType","preferredMimeType","widget","createRenderer","MimeModel","renderModel","catch","reason","invoke","CONTENT_CLASS","InspectorPanel","Panel","super","_source","translator","nullTranslator","_trans","load","initialContent","Widget","_content","_generateContentWidget","__","addClass","layout","addWidget","Printing","source","disconnect","onInspectorUpdate","onSourceDisposed","sender","args","static","message","node","innerHTML","KernelConnector","DataConnector","_sessionContext","sessionContext","request","_a","kernel","session","Promise","reject","Error","contents","code","cursor_pos","detail_level","requestInspect","msg","response","status","found","metadata","IInspector","Token"],"sourceRoot":""}
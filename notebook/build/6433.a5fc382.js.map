{"version":3,"file":"6433.a5fc382.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/services/lib/kernel/serialize.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/async-mutex/index.mjs","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernels.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernelspecs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/tokens.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serialize = exports.deserialize = void 0;\n/**\n * Deserialize and return the unpacked message.\n *\n * #### Notes\n * Handles JSON blob strings and binary messages.\n */\nfunction deserialize(data) {\n    let value;\n    if (typeof data === 'string') {\n        value = JSON.parse(data);\n    }\n    else {\n        value = deserializeBinary(data);\n    }\n    return value;\n}\nexports.deserialize = deserialize;\n/**\n * Serialize a kernel message for transport.\n *\n * #### Notes\n * If there is binary content, an `ArrayBuffer` is returned,\n * otherwise the message is converted to a JSON string.\n */\nfunction serialize(msg) {\n    var _a;\n    let value;\n    if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {\n        value = serializeBinary(msg);\n    }\n    else {\n        value = JSON.stringify(msg);\n    }\n    return value;\n}\nexports.serialize = serialize;\n/**\n * Deserialize a binary message to a Kernel Message.\n */\nfunction deserializeBinary(buf) {\n    const data = new DataView(buf);\n    // read the header: 1 + nbufs 32b integers\n    const nbufs = data.getUint32(0);\n    const offsets = [];\n    if (nbufs < 2) {\n        throw new Error('Invalid incoming Kernel Message');\n    }\n    for (let i = 1; i <= nbufs; i++) {\n        offsets.push(data.getUint32(i * 4));\n    }\n    const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));\n    const msg = JSON.parse(new TextDecoder('utf8').decode(jsonBytes));\n    // the remaining chunks are stored as DataViews in msg.buffers\n    msg.buffers = [];\n    for (let i = 1; i < nbufs; i++) {\n        const start = offsets[i];\n        const stop = offsets[i + 1] || buf.byteLength;\n        msg.buffers.push(new DataView(buf.slice(start, stop)));\n    }\n    return msg;\n}\n/**\n * Implement the binary serialization protocol.\n *\n * Serialize Kernel message to ArrayBuffer.\n */\nfunction serializeBinary(msg) {\n    const offsets = [];\n    const buffers = [];\n    const encoder = new TextEncoder();\n    let origBuffers = [];\n    if (msg.buffers !== undefined) {\n        origBuffers = msg.buffers;\n        delete msg['buffers'];\n    }\n    const jsonUtf8 = encoder.encode(JSON.stringify(msg));\n    buffers.push(jsonUtf8.buffer);\n    for (let i = 0; i < origBuffers.length; i++) {\n        // msg.buffers elements could be either views or ArrayBuffers\n        // buffers elements are ArrayBuffers\n        const b = origBuffers[i];\n        buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);\n    }\n    const nbufs = buffers.length;\n    offsets.push(4 * (nbufs + 1));\n    for (let i = 0; i + 1 < buffers.length; i++) {\n        offsets.push(offsets[offsets.length - 1] + buffers[i].byteLength);\n    }\n    const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);\n    // use DataView.setUint32 for network byte-order\n    const view = new DataView(msgBuf.buffer);\n    // write nbufs to first 4 bytes\n    view.setUint32(0, nbufs);\n    // write offsets to next 4 * nbufs bytes\n    for (let i = 0; i < offsets.length; i++) {\n        view.setUint32(4 * (i + 1), offsets[i]);\n    }\n    // write all the buffers at their respective offsets\n    for (let i = 0; i < buffers.length; i++) {\n        msgBuf.set(new Uint8Array(buffers[i]), offsets[i]);\n    }\n    return msgBuf.buffer;\n}\n//# sourceMappingURL=serialize.js.map","import { KernelMessage } from '@jupyterlab/services';\nimport { Signal } from '@lumino/signaling';\n/**\n * A base kernel class handling basic kernel messaging.\n */\nexport class BaseKernel {\n    /**\n     * Construct a new BaseKernel.\n     *\n     * @param options The instantiation options for a BaseKernel.\n     */\n    constructor(options) {\n        this._history = [];\n        this._executionCount = 0;\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._parentHeader = undefined;\n        this._parent = undefined;\n        const { id, name, sendMessage } = options;\n        this._id = id;\n        this._name = name;\n        this._sendMessage = sendMessage;\n    }\n    /**\n     * A promise that is fulfilled when the kernel is ready.\n     */\n    get ready() {\n        return Promise.resolve();\n    }\n    /**\n     * Return whether the kernel is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the kernel is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Get the kernel id\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the name of the kernel\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The current execution count\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    /**\n     * Get the last parent header\n     */\n    get parentHeader() {\n        return this._parentHeader;\n    }\n    /**\n     * Get the last parent message (mimic ipykernel's get_parent)\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Dispose the kernel.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n    }\n    /**\n     * Handle an incoming message from the client.\n     *\n     * @param msg The message to handle\n     */\n    async handleMessage(msg) {\n        this._busy(msg);\n        this._parent = msg;\n        const msgType = msg.header.msg_type;\n        switch (msgType) {\n            case 'kernel_info_request':\n                await this._kernelInfo(msg);\n                break;\n            case 'execute_request':\n                await this._execute(msg);\n                break;\n            case 'input_reply':\n                this.inputReply(msg.content);\n                break;\n            case 'inspect_request':\n                await this._inspect(msg);\n                break;\n            case 'is_complete_request':\n                await this._isCompleteRequest(msg);\n                break;\n            case 'complete_request':\n                await this._complete(msg);\n                break;\n            case 'history_request':\n                await this._historyRequest(msg);\n                break;\n            case 'comm_open':\n                await this.commOpen(msg);\n                break;\n            case 'comm_msg':\n                await this.commMsg(msg);\n                break;\n            case 'comm_close':\n                await this.commClose(msg);\n                break;\n            default:\n                break;\n        }\n        this._idle(msg);\n    }\n    /**\n     * Stream an event from the kernel\n     *\n     * @param parentHeader The parent header.\n     * @param content The stream content.\n     */\n    stream(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'stream',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The display_data content.\n     */\n    displayData(content, parentHeader = undefined) {\n        var _a, _b;\n        // Make sure metadata is always set\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        content.metadata = (_a = content.metadata) !== null && _a !== void 0 ? _a : {};\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'display_data',\n            // TODO: better handle this\n            session: (_b = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _b !== void 0 ? _b : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `input_request` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The input_request content.\n     */\n    inputRequest(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'stdin',\n            msgType: 'input_request',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_result` message.\n     *\n     * @param parentHeader The parent header.\n     * @param content The execute result content.\n     */\n    publishExecuteResult(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'execute_result',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `error` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The error content.\n     */\n    publishExecuteError(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'error',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `update_display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The update_display_data content.\n     */\n    updateDisplayData(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'update_display_data',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `clear_output` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The clear_output content.\n     */\n    clearOutput(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'clear_output',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `comm` message to the client.\n     *\n     * @param .\n     */\n    handleComm(type, content, metadata, buffers, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: type,\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n            metadata,\n            buffers,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an 'idle' status message.\n     *\n     * @param parent The parent message\n     */\n    _idle(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'idle',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a 'busy' status message.\n     *\n     * @param parent The parent message.\n     */\n    _busy(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'busy',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a kernel_info_request message\n     *\n     * @param parent The parent message.\n     */\n    async _kernelInfo(parent) {\n        const content = await this.kernelInfoRequest();\n        const message = KernelMessage.createMessage({\n            msgType: 'kernel_info_reply',\n            channel: 'shell',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a `history_request` message\n     *\n     * @param msg The parent message.\n     */\n    async _historyRequest(msg) {\n        const historyMsg = msg;\n        const message = KernelMessage.createMessage({\n            msgType: 'history_reply',\n            channel: 'shell',\n            parentHeader: historyMsg.header,\n            session: msg.header.session,\n            content: {\n                status: 'ok',\n                history: this._history,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_input` message.\n     *\n     * @param msg The parent message.\n     */\n    _executeInput(msg) {\n        const parent = msg;\n        const code = parent.content.code;\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_input',\n            parentHeader: parent.header,\n            channel: 'iopub',\n            session: msg.header.session,\n            content: {\n                code,\n                execution_count: this._executionCount,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an execute_request message.\n     *\n     * @param msg The parent message.\n     */\n    async _execute(msg) {\n        const executeMsg = msg;\n        const content = executeMsg.content;\n        if (content.store_history) {\n            this._executionCount++;\n        }\n        // TODO: handle differently\n        this._parentHeader = executeMsg.header;\n        this._executeInput(executeMsg);\n        if (content.store_history) {\n            this._history.push([0, 0, content.code]);\n        }\n        const reply = await this.executeRequest(executeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_reply',\n            channel: 'shell',\n            parentHeader: executeMsg.header,\n            session: msg.header.session,\n            content: reply,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _complete(msg) {\n        const completeMsg = msg;\n        const content = await this.completeRequest(completeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'complete_reply',\n            parentHeader: completeMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an inspect_request message\n     *\n     * @param msg The parent message.\n     */\n    async _inspect(msg) {\n        const inspectMsg = msg;\n        const content = await this.inspectRequest(inspectMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'inspect_reply',\n            parentHeader: inspectMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an is_complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _isCompleteRequest(msg) {\n        const isCompleteMsg = msg;\n        const content = await this.isCompleteRequest(isCompleteMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'is_complete_reply',\n            parentHeader: isCompleteMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import { ObservableMap } from '@jupyterlab/observables';\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\nimport { UUID } from '@lumino/coreutils';\nimport { Server as WebSocketServer } from 'mock-socket';\nimport { Mutex } from 'async-mutex';\nimport { PageConfig } from '@jupyterlab/coreutils';\n/**\n * A class to handle requests to /api/kernels\n */\nexport class Kernels {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        this._kernels = new ObservableMap();\n        this._clients = new ObservableMap();\n        this._kernelClients = new ObservableMap();\n        const { kernelspecs } = options;\n        this._kernelspecs = kernelspecs;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name } = options;\n        const factory = this._kernelspecs.factories.get(name);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            return { id, name };\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            var _a;\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.add(clientId);\n            const processMsg = async (msg) => {\n                await mutex.runExclusive(async () => {\n                    await kernel.handleMessage(msg);\n                });\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message);\n                }\n                else if (typeof message === 'string') {\n                    msg = deserialize(message);\n                }\n                else {\n                    return;\n                }\n                // TODO Find a better solution for this?\n                // input-reply is asynchronous, must not be processed like other messages\n                if (msg.header.msg_type === 'input_reply') {\n                    kernel.handleMessage(msg);\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                var _a;\n                this._clients.delete(clientId);\n                (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            // TODO: check whether this is called\n            // https://github.com/thoov/mock-socket/issues/298\n            // https://github.com/jupyterlab/jupyterlab/blob/6bc884a7a8ed73c615ce72ba097bdb790482b5bf/packages/services/src/kernel/default.ts#L1245\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id !== null && id !== void 0 ? id : UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = `${Kernels.WS_BASE_URL}api/kernels/${kernelId}/channels`;\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg);\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients === null || clients === void 0 ? void 0 : clients.forEach((id) => {\n                    var _a;\n                    (_a = this._clients.get(id)) === null || _a === void 0 ? void 0 : _a.send(message);\n                });\n                return;\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name,\n        });\n        await kernel.ready;\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl);\n        wsServer.on('connection', (socket) => {\n            var _a;\n            const url = new URL(socket.url);\n            const clientId = (_a = url.searchParams.get('session_id')) !== null && _a !== void 0 ? _a : '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach((clientId) => {\n                var _a;\n                const socket = this._clients.get(clientId);\n                if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name } = kernel;\n        kernel.dispose();\n        return this.startNew({ id, name });\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        var _a;\n        (_a = this._kernels.delete(id)) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (Kernels) {\n    /**\n     * The base url for the Kernels manager\n     */\n    Kernels.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(Kernels || (Kernels = {}));\n","/**\n * A class to handle requests to /api/kernelspecs\n */\nexport class KernelSpecs {\n    /**\n     * Construct a new KernelSpecs.\n     *\n     * @param options The instantiation options.\n     */\n    constructor(options) {\n        this._specs = new Map();\n        this._factories = new Map();\n        // no-op\n    }\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: 'python',\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n    }\n}\n","import { Token } from '@lumino/coreutils';\n/**\n * The token for the kernels service.\n */\nexport const IKernels = new Token('@jupyterlite/kernel:IKernels');\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token('@jupyterlite/kernel:IKernelSpecs');\n"],"names":["Object","defineProperty","exports","value","serialize","deserialize","data","JSON","parse","buf","DataView","nbufs","getUint32","offsets","Error","i","push","jsonBytes","Uint8Array","slice","msg","TextDecoder","decode","buffers","start","stop","byteLength","deserializeBinary","_a","length","encoder","TextEncoder","origBuffers","undefined","jsonUtf8","encode","stringify","buffer","b","ArrayBuffer","isView","msgBuf","view","setUint32","set","serializeBinary","BaseKernel","constructor","options","this","_history","_executionCount","_isDisposed","_disposed","Signal","_parentHeader","_parent","id","name","sendMessage","_id","_name","_sendMessage","ready","Promise","resolve","isDisposed","disposed","executionCount","parentHeader","parent","dispose","emit","async","_busy","header","msg_type","_kernelInfo","_execute","inputReply","content","_inspect","_isCompleteRequest","_complete","_historyRequest","commOpen","commMsg","commClose","_idle","stream","parentHeaderValue","message","KernelMessage","channel","msgType","session","displayData","_b","metadata","inputRequest","publishExecuteResult","publishExecuteError","updateDisplayData","clearOutput","handleComm","type","execution_state","kernelInfoRequest","historyMsg","status","history","_executeInput","code","execution_count","executeMsg","store_history","reply","executeRequest","completeMsg","completeRequest","inspectMsg","inspectRequest","isCompleteMsg","isCompleteRequest","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Semaphore","_maxConcurrency","_cancelError","_queue","_waiters","_value","acquire","locked","isLocked","ticketPromise","_dispatch","runExclusive","callback","release","waitForUnlock","_currentReleaser","releaser","cancel","forEach","ticket","nextTicket","shift","released","_resolveWaiters","waiter","Mutex","cancelError","_semaphore","Kernels","_kernels","ObservableMap","_clients","_kernelClients","kernelspecs","_kernelspecs","factory","factories","get","mutex","hook","kernelId","clientId","socket","kernel","add","on","handleMessage","processMsg","removeClient","delete","connect","onclose","UUID","kernelUrl","WS_BASE_URL","runningKernel","console","warn","send","clients","Set","wsServer","URL","url","searchParams","keys","readyState","WebSocket","CLOSED","close","startNew","PageConfig","replace","KernelSpecs","_specs","Map","_factories","specs","size","default","fromEntries","register","spec","create","IKernels","Token","IKernelSpecs"],"sourceRoot":""}
{"version":3,"file":"7386.fed2b49.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { createDefaultFactory, Toolbar } from '@jupyterlab/apputils';\nimport { ObservableList } from '@jupyterlab/observables';\nimport { each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/*\n * Text mime types\n */\nconst TEXT_MIME_TYPES = [\n    'text/plain',\n    'application/vnd.jupyter.stdout',\n    'application/vnd.jupyter.stderr'\n];\n/**\n * Widget cell toolbar classes\n */\nconst CELL_TOOLBAR_CLASS = 'jp-cell-toolbar';\nconst CELL_MENU_CLASS = 'jp-cell-menu';\n/**\n * Class for a cell whose contents overlap with the cell toolbar\n */\nconst TOOLBAR_OVERLAP_CLASS = 'jp-toolbar-overlap';\n/**\n * Watch a notebook so that a cell toolbar appears on the active cell\n */\nexport class CellToolbarTracker {\n    constructor(panel, toolbar) {\n        this._isDisposed = false;\n        this._panel = panel;\n        this._previousActiveCell = this._panel.content.activeCell;\n        this._toolbar = toolbar;\n        this._onToolbarChanged();\n        this._toolbar.changed.connect(this._onToolbarChanged, this);\n        // Only add the toolbar to the notebook's active cell (if any) once it has fully rendered and been revealed.\n        void panel.revealed.then(() => this._onActiveCellChanged(panel.content));\n        // Check whether the toolbar should be rendered upon a layout change\n        panel.content.renderingLayoutChanged.connect(this._onActiveCellChanged, this);\n        // Handle subsequent changes of active cell.\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n    }\n    _onActiveCellChanged(notebook) {\n        if (this._previousActiveCell) {\n            this._removeToolbar(this._previousActiveCell.model);\n        }\n        const activeCell = notebook.activeCell;\n        if (!activeCell) {\n            return;\n        }\n        this._addToolbar(activeCell.model);\n        this._previousActiveCell = activeCell;\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._toolbar.changed.disconnect(this._onToolbarChanged, this);\n        const cells = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.context.model.cells;\n        if (cells) {\n            each(cells.iter(), model => this._removeToolbar(model));\n        }\n        this._panel = null;\n        Signal.clearData(this);\n    }\n    _addToolbar(model) {\n        const cell = this._getCell(model);\n        if (cell) {\n            const toolbarWidget = new Toolbar();\n            toolbarWidget.addClass(CELL_MENU_CLASS);\n            toArray(this._toolbar).forEach(({ name, widget }) => {\n                toolbarWidget.addItem(name, widget);\n            });\n            toolbarWidget.addClass(CELL_TOOLBAR_CLASS);\n            cell.layout.insertWidget(0, toolbarWidget);\n            // For rendered markdown, watch for resize events.\n            cell.displayChanged.connect(this._resizeEventCallback, this);\n            // Watch for changes in the cell's contents.\n            cell.model.contentChanged.connect(this._changedEventCallback, this);\n        }\n    }\n    _getCell(model) {\n        var _a;\n        return (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.widgets.find(widget => widget.model === model);\n    }\n    _findToolbarWidgets(cell) {\n        const widgets = cell.layout.widgets;\n        // Search for header using the CSS class or use the first one if not found.\n        return widgets.filter(widget => widget.hasClass(CELL_TOOLBAR_CLASS)) || [];\n    }\n    _removeToolbar(model) {\n        const cell = this._getCell(model);\n        if (cell) {\n            this._findToolbarWidgets(cell).forEach(widget => widget.dispose());\n            // Attempt to remove the resize and changed event handlers.\n            cell.displayChanged.disconnect(this._resizeEventCallback, this);\n        }\n        model.contentChanged.disconnect(this._changedEventCallback, this);\n    }\n    /**\n     * Call back on settings changes\n     */\n    _onToolbarChanged() {\n        var _a;\n        // Reset toolbar when settings changes\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell) {\n            this._removeToolbar(activeCell.model);\n            this._addToolbar(activeCell.model);\n        }\n    }\n    _changedEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _resizeEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _updateCellForToolbarOverlap(activeCell) {\n        // Remove the \"toolbar overlap\" class from the cell, rendering the cell's toolbar\n        const activeCellElement = activeCell.node;\n        activeCellElement.classList.remove(TOOLBAR_OVERLAP_CLASS);\n        if (this._cellToolbarOverlapsContents(activeCell)) {\n            // Add the \"toolbar overlap\" class to the cell, completely concealing the toolbar,\n            // if the first line of the content overlaps with it at all\n            activeCellElement.classList.add(TOOLBAR_OVERLAP_CLASS);\n        }\n    }\n    _cellToolbarOverlapsContents(activeCell) {\n        var _a;\n        const cellType = activeCell.model.type;\n        // If the toolbar is too large for the current cell, hide it.\n        const cellLeft = this._cellEditorWidgetLeft(activeCell);\n        const cellRight = this._cellEditorWidgetRight(activeCell);\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        if (toolbarLeft === null) {\n            return false;\n        }\n        // The toolbar should not take up more than 50% of the cell.\n        if ((cellLeft + cellRight) / 2 > toolbarLeft) {\n            return true;\n        }\n        if (cellType === 'markdown' && activeCell.rendered) {\n            // Check for overlap in rendered markdown content\n            return this._markdownOverlapsToolbar(activeCell);\n        }\n        // Check for overlap in code content\n        if (((_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.renderingLayout) === 'default') {\n            return this._codeOverlapsToolbar(activeCell);\n        }\n        else {\n            return this._outputOverlapsToolbar(activeCell);\n        }\n    }\n    /**\n     * Check for overlap between rendered Markdown and the cell toolbar\n     *\n     * @param activeCell A rendered MarkdownCell\n     * @returns `true` if the first line of the output overlaps with the cell toolbar, `false` otherwise\n     */\n    _markdownOverlapsToolbar(activeCell) {\n        const markdownOutput = activeCell.inputArea; // Rendered markdown appears in the input area\n        // Get the rendered markdown as a widget.\n        const markdownOutputWidget = markdownOutput.renderedInput;\n        const markdownOutputElement = markdownOutputWidget.node;\n        const firstOutputElementChild = markdownOutputElement.firstElementChild;\n        if (firstOutputElementChild === null) {\n            return false;\n        }\n        // Temporarily set the element's max width so that the bounding client rectangle only encompasses the content.\n        const oldMaxWidth = firstOutputElementChild.style.maxWidth;\n        firstOutputElementChild.style.maxWidth = 'max-content';\n        const lineRight = firstOutputElementChild.getBoundingClientRect().right;\n        // Reinstate the old max width.\n        firstOutputElementChild.style.maxWidth = oldMaxWidth;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _outputOverlapsToolbar(activeCell) {\n        const outputArea = activeCell.outputArea.node;\n        if (outputArea) {\n            const outputs = outputArea.querySelectorAll('[data-mime-type]');\n            const toolbarRect = this._cellToolbarRect(activeCell);\n            if (toolbarRect) {\n                const { left: toolbarLeft, bottom: toolbarBottom } = toolbarRect;\n                return Array.from(outputs).some(output => {\n                    const node = output.firstElementChild;\n                    if (node) {\n                        const range = new Range();\n                        if (TEXT_MIME_TYPES.includes(output.getAttribute('data-mime-type') || '')) {\n                            // If the node is plain text, it's in a <pre>. To get the true bounding box of the\n                            // text, the node contents need to be selected.\n                            range.selectNodeContents(node);\n                        }\n                        else {\n                            range.selectNode(node);\n                        }\n                        const { right: nodeRight, top: nodeTop } = range.getBoundingClientRect();\n                        // Note: y-coordinate increases toward the bottom of page\n                        return nodeRight > toolbarLeft && nodeTop < toolbarBottom;\n                    }\n                    return false;\n                });\n            }\n        }\n        return false;\n    }\n    _codeOverlapsToolbar(activeCell) {\n        const editorWidget = activeCell.editorWidget;\n        const editor = activeCell.editor;\n        if (editor.lineCount < 1) {\n            return false; // Nothing in the editor\n        }\n        const codeMirrorLines = editorWidget.node.getElementsByClassName('CodeMirror-line');\n        if (codeMirrorLines.length < 1) {\n            return false; // No lines present\n        }\n        const lineRight = codeMirrorLines[0].children[0] // First span under first pre\n            .getBoundingClientRect().right;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _cellEditorWidgetLeft(activeCell) {\n        return activeCell.editorWidget.node.getBoundingClientRect().left;\n    }\n    _cellEditorWidgetRight(activeCell) {\n        return activeCell.editorWidget.node.getBoundingClientRect().right;\n    }\n    _cellToolbarRect(activeCell) {\n        const toolbarWidgets = this._findToolbarWidgets(activeCell);\n        if (toolbarWidgets.length < 1) {\n            return null;\n        }\n        const activeCellToolbar = toolbarWidgets[0].node;\n        return activeCellToolbar.getBoundingClientRect();\n    }\n    _cellToolbarLeft(activeCell) {\n        var _a;\n        return ((_a = this._cellToolbarRect(activeCell)) === null || _a === void 0 ? void 0 : _a.left) || null;\n    }\n}\nconst defaultToolbarItems = [\n    {\n        command: 'notebook:duplicate-below',\n        name: 'duplicate-cell'\n    },\n    {\n        command: 'notebook:move-cell-up',\n        name: 'move-cell-up'\n    },\n    {\n        command: 'notebook:move-cell-down',\n        name: 'move-cell-down'\n    },\n    {\n        command: 'notebook:insert-cell-above',\n        name: 'insert-cell-above'\n    },\n    {\n        command: 'notebook:insert-cell-below',\n        name: 'insert-cell-below'\n    },\n    {\n        command: 'notebook:delete-cell',\n        name: 'delete-cell'\n    }\n];\n/**\n * Widget extension that creates a CellToolbarTracker each time a notebook is\n * created.\n */\nexport class CellBarExtension {\n    constructor(commands, toolbarFactory) {\n        this._commands = commands;\n        this._toolbarFactory = toolbarFactory !== null && toolbarFactory !== void 0 ? toolbarFactory : this.defaultToolbarFactory;\n    }\n    get defaultToolbarFactory() {\n        const itemFactory = createDefaultFactory(this._commands);\n        return (widget) => new ObservableList({\n            values: defaultToolbarItems.map(item => {\n                return {\n                    name: item.name,\n                    widget: itemFactory(CellBarExtension.FACTORY_NAME, widget, item)\n                };\n            })\n        });\n    }\n    createNew(panel) {\n        return new CellToolbarTracker(panel, this._toolbarFactory(panel));\n    }\n}\nCellBarExtension.FACTORY_NAME = 'Cell';\n//# sourceMappingURL=celltoolbartracker.js.map"],"names":["TEXT_MIME_TYPES","CELL_TOOLBAR_CLASS","TOOLBAR_OVERLAP_CLASS","CellToolbarTracker","constructor","panel","toolbar","this","_isDisposed","_panel","_previousActiveCell","content","activeCell","_toolbar","_onToolbarChanged","changed","connect","revealed","then","_onActiveCellChanged","renderingLayoutChanged","activeCellChanged","notebook","_removeToolbar","model","_addToolbar","_updateCellForToolbarOverlap","isDisposed","dispose","_a","disconnect","cells","context","each","iter","Signal","cell","_getCell","toolbarWidget","Toolbar","addClass","toArray","forEach","name","widget","addItem","layout","insertWidget","displayChanged","_resizeEventCallback","contentChanged","_changedEventCallback","widgets","find","_findToolbarWidgets","filter","hasClass","activeCellElement","node","classList","remove","_cellToolbarOverlapsContents","add","cellType","type","cellLeft","_cellEditorWidgetLeft","cellRight","_cellEditorWidgetRight","toolbarLeft","_cellToolbarLeft","rendered","_markdownOverlapsToolbar","renderingLayout","_codeOverlapsToolbar","_outputOverlapsToolbar","firstOutputElementChild","inputArea","renderedInput","firstElementChild","oldMaxWidth","style","maxWidth","lineRight","getBoundingClientRect","right","outputArea","outputs","querySelectorAll","toolbarRect","_cellToolbarRect","left","bottom","toolbarBottom","Array","from","some","output","range","Range","includes","getAttribute","selectNodeContents","selectNode","nodeRight","top","nodeTop","editorWidget","editor","lineCount","codeMirrorLines","getElementsByClassName","length","children","toolbarWidgets","defaultToolbarItems","command","CellBarExtension","commands","toolbarFactory","_commands","_toolbarFactory","defaultToolbarFactory","itemFactory","createDefaultFactory","ObservableList","values","map","item","FACTORY_NAME","createNew"],"sourceRoot":""}
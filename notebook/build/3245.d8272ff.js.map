{"version":3,"file":"3245.d8272ff.js","mappings":"4OAOO,MAAMA,EAAuB,4BAIvBC,EAAY,IAAI,EAAAC,MAAM,mCCJ7BC,EAAeC,OAAOC,OAAO,CAAEC,SAAU,KAIxC,MAAMC,EAITC,YACI,MAAO,CACHC,QAAS,UACKC,KAAKC,gBACf,CAACD,KAAKE,eAAgBF,KAAKG,mBAGvC,CAIID,cACA,OAAO,EAAAE,WAAA,UAAqB,YAAc,aAC9C,CAIIC,qBACA,OAAO,EAAAC,OAAA,KAAY,EAAAF,WAAA,aAAyB,QAASd,EACzD,CAIIiB,uBACA,OAAO,EAAAH,WAAA,UAAqB,uBAChC,CAIAN,wBACI,IAAIU,EAASf,EACb,IAEIe,SADuBC,MAAMT,KAAKK,iBAChBK,MAItB,CAFA,MAAOC,GACHC,QAAQC,KAAK,iCAAkCb,KAAKE,QACxD,CACA,OAAOM,CACX,CAIAV,sBACI,MAAMC,EAAU,CAAC,EACjB,IAAIe,EACJ,IACIA,EAAYC,KAAKC,MAAM,EAAAZ,WAAA,UAAqB,wBAIhD,CAFA,MACI,OAAOL,CACX,CACA,MAAMkB,EAAW,GACjB,IAAK,MAAMC,KAAOJ,EACdG,EAASE,KAAKnB,KAAKoB,iBAAiBF,EAAKnB,IAE7C,UACUsB,QAAQC,IAAIL,EAItB,CAFA,MAAON,GACHC,QAAQC,KAAK,2BAA4BF,EAC7C,CACA,OAAOZ,CACX,CAIAD,uBAAuBoB,EAAKnB,GACxB,IACI,MAAMwB,EAAM,EAAAjB,OAAA,KAAYN,KAAKO,iBAAkBW,EAAIM,KAAM,SAAUlC,GAC7DmC,QAAiBhB,MAAMc,GAC7BxB,EAAQmB,EAAIM,YAAcC,EAASf,MAKvC,CAHA,MACIE,QAAQC,KAAK,iCAAkCK,GAC/CnB,EAAQmB,EAAIM,MAAQ/B,CACxB,CACJ,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/lib/licenses.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * The token for the licenses service.\n */\nexport const ILicenses = new Token('@jupyterlite/licenses:ILicenses');\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\nimport { THIRD_PARTY_LICENSES, } from './tokens';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class Licenses {\n    /**\n     * A GET handler for the licenses\n     */\n    async get() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n"],"names":["THIRD_PARTY_LICENSES","ILicenses","Token","EMPTY_BUNDLE","Object","freeze","packages","Licenses","async","bundles","this","_getFederated","appName","_getAppLicenses","PageConfig","appLicensesUrl","URLExt","labExtensionsUrl","bundle","fetch","json","err","console","warn","federated","JSON","parse","promises","ext","push","_getOneFederated","Promise","all","url","name","response"],"sourceRoot":""}
{"version":3,"file":"901.d1646e6.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/mimerenderers.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/status.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            downArea: null,\n            leftArea: null,\n            rightArea: null,\n            relativeSizes: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, down, left, right, relativeSizes } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            const mainArea = this._rehydrateMainArea(main);\n            // Rehydrate down area.\n            const downArea = this._rehydrateDownArea(down);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return {\n                fresh,\n                mainArea,\n                downArea,\n                leftArea,\n                rightArea,\n                relativeSizes: relativeSizes || null\n            };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    restore(tracker, options) {\n        const warning = 'restore() can only be called before `first` has resolved.';\n        if (this._firstDone) {\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            const warning = `A tracker namespaced ${namespace} was already restored.`;\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        const promise = tracker\n            .restore({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        })\n            .catch(error => {\n            console.error(error);\n        });\n        this._promises.push(promise);\n        return promise;\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(data) {\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        dehydrated.main = this._dehydrateMainArea(data.mainArea);\n        dehydrated.down = this._dehydrateDownArea(data.downArea);\n        dehydrated.left = this._dehydrateSideArea(data.leftArea);\n        dehydrated.right = this._dehydrateSideArea(data.rightArea);\n        dehydrated.relativeSizes = data.relativeSizes;\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Reydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a down area description into a serializable object.\n     */\n    _dehydrateDownArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = {\n            size: area.size\n        };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateDownArea(area) {\n        var _a;\n        if (!area) {\n            return { currentWidget: null, size: 0.0, widgets: null };\n        }\n        const internal = this._widgets;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            currentWidget: currentWidget,\n            size: (_a = area.size) !== null && _a !== void 0 ? _a : 0.0,\n            widgets: widgets\n        };\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = { collapsed: area.collapsed };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a;\n        if (!area) {\n            return { collapsed: true, currentWidget: null, widgets: null };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application:mimedocument',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = Object.assign(Object.assign({}, ft), { icon: LabIcon.resolve({ icon: ft.icon }) });\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\n/* tslint:disable */\n/**\n * The application status token.\n */\nexport const ILabStatus = new Token('@jupyterlab/application:ILabStatus');\n/**\n * The application status signals and flags class.\n */\nexport class LabStatus {\n    /**\n     * Construct a new  status object.\n     */\n    constructor(app) {\n        this._busyCount = 0;\n        this._dirtyCount = 0;\n        this._busySignal = new Signal(app);\n        this._dirtySignal = new Signal(app);\n    }\n    /**\n     * Returns a signal for when application changes its busy status.\n     */\n    get busySignal() {\n        return this._busySignal;\n    }\n    /**\n     * Returns a signal for when application changes its dirty status.\n     */\n    get dirtySignal() {\n        return this._dirtySignal;\n    }\n    /**\n     * Whether the application is busy.\n     */\n    get isBusy() {\n        return this._busyCount > 0;\n    }\n    /**\n     * Whether the application is dirty.\n     */\n    get isDirty() {\n        return this._dirtyCount > 0;\n    }\n    /**\n     * Set the application state to dirty.\n     *\n     * @returns A disposable used to clear the dirty state for the caller.\n     */\n    setDirty() {\n        const oldDirty = this.isDirty;\n        this._dirtyCount++;\n        if (this.isDirty !== oldDirty) {\n            this._dirtySignal.emit(this.isDirty);\n        }\n        return new DisposableDelegate(() => {\n            const oldDirty = this.isDirty;\n            this._dirtyCount = Math.max(0, this._dirtyCount - 1);\n            if (this.isDirty !== oldDirty) {\n                this._dirtySignal.emit(this.isDirty);\n            }\n        });\n    }\n    /**\n     * Set the application state to busy.\n     *\n     * @returns A disposable used to clear the busy state for the caller.\n     */\n    setBusy() {\n        const oldBusy = this.isBusy;\n        this._busyCount++;\n        if (this.isBusy !== oldBusy) {\n            this._busySignal.emit(this.isBusy);\n        }\n        return new DisposableDelegate(() => {\n            const oldBusy = this.isBusy;\n            this._busyCount--;\n            if (this.isBusy !== oldBusy) {\n                this._busySignal.emit(this.isBusy);\n            }\n        });\n    }\n}\n//# sourceMappingURL=status.js.map"],"names":["ILayoutRestorer","Token","KEY","LayoutRestorer","constructor","options","this","_firstDone","_promisesDone","_promises","_restored","PromiseDelegate","_trackers","Set","_widgets","Map","_connector","connector","_first","first","_registry","registry","then","Promise","all","clear","resolve","restored","promise","add","widget","name","Private","nameProperty","set","disposed","connect","_onWidgetDisposed","async","blank","fresh","mainArea","downArea","leftArea","rightArea","relativeSizes","layout","fetch","data","main","down","left","right","_rehydrateMainArea","_rehydrateDownArea","_rehydrateSideArea","error","restore","tracker","warning","console","warn","reject","namespace","has","args","command","when","widgetAdded","_","widgetName","widgetUpdated","JSONExt","concat","catch","push","save","dehydrated","_dehydrateMainArea","_dehydrateDownArea","_dehydrateSideArea","area","serializeMain","deserializeMain","size","currentWidget","current","get","widgets","map","filter","_a","internal","Array","isArray","collapsed","delete","serializeArea","type","currentIndex","orientation","sizes","children","deserializeArea","names","hydrated","length","child","AttachedProperty","create","owner","dock","IMimeDocumentTracker","createRendermimePlugins","extensions","plugins","WidgetTracker","forEach","mod","default","hasOwnProperty","item","createRendermimePlugin","id","optional","provides","autoStart","activate","app","restorer","path","context","factory","factoryNameProperty","requires","IRenderMimeRegistry","ITranslator","rendermime","translator","undefined","rank","addFactory","rendererFactory","documentWidgetFactoryOptions","docRegistry","fileTypes","ft","icon","Object","assign","LabIcon","addFileType","option","toolbarFactory","w","content","renderer","MimeDocumentFactory","renderTimeout","dataType","modelName","primaryFileType","getFileType","defaultFor","defaultRendered","addWidgetFactory","widgetCreated","sender","pathChanged","ILabStatus","LabStatus","_busyCount","_dirtyCount","_busySignal","Signal","_dirtySignal","busySignal","dirtySignal","isBusy","isDirty","setDirty","oldDirty","emit","DisposableDelegate","Math","max","setBusy","oldBusy"],"sourceRoot":""}
{"version":3,"file":"9939.f746d88.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module completer-extension\n */\nimport { Completer, CompleterModel, CompletionConnector, CompletionHandler, ContextConnector, ICompletionManager } from '@jupyterlab/completer';\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { find, toArray } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\n/**\n * The command IDs used by the completer plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.invoke = 'completer:invoke';\n    CommandIDs.invokeConsole = 'completer:invoke-console';\n    CommandIDs.invokeNotebook = 'completer:invoke-notebook';\n    CommandIDs.invokeFile = 'completer:invoke-file';\n    CommandIDs.select = 'completer:select';\n    CommandIDs.selectConsole = 'completer:select-console';\n    CommandIDs.selectNotebook = 'completer:select-notebook';\n    CommandIDs.selectFile = 'completer:select-file';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A plugin providing code completion for editors.\n */\nconst manager = {\n    id: '@jupyterlab/completer-extension:manager',\n    autoStart: true,\n    provides: ICompletionManager,\n    activate: (app) => {\n        const handlers = {};\n        app.commands.addCommand(CommandIDs.invoke, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.invoke();\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.select, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.completer.selectActive();\n                }\n            }\n        });\n        return {\n            register: (completable, renderer = Completer.defaultRenderer) => {\n                const { connector, editor, parent } = completable;\n                const model = new CompleterModel();\n                const completer = new Completer({ editor, model, renderer });\n                const handler = new CompletionHandler({\n                    completer,\n                    connector\n                });\n                const id = parent.id;\n                // Hide the widget when it first loads.\n                completer.hide();\n                // Associate the handler with the parent widget.\n                handlers[id] = handler;\n                // Set the handler's editor.\n                handler.editor = editor;\n                // Attach the completer widget.\n                Widget.attach(completer, document.body);\n                // Listen for parent disposal.\n                parent.disposed.connect(() => {\n                    delete handlers[id];\n                    model.dispose();\n                    completer.dispose();\n                    handler.dispose();\n                });\n                return handler;\n            }\n        };\n    }\n};\n/**\n * An extension that registers consoles for code completion.\n */\nconst consoles = {\n    id: '@jupyterlab/completer-extension:consoles',\n    requires: [ICompletionManager, IConsoleTracker],\n    autoStart: true,\n    activate: (app, manager, consoles) => {\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, widget) => {\n            var _a, _b;\n            const anchor = widget.console;\n            const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = anchor.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: widget });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = anchor.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            anchor.promptCellCreated.connect(updateConnector);\n            anchor.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectConsole,\n            keys: ['Enter'],\n            selector: `.jp-ConsolePanel .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers notebooks for code completion.\n */\nconst notebooks = {\n    id: '@jupyterlab/completer-extension:notebooks',\n    requires: [ICompletionManager, INotebookTracker],\n    autoStart: true,\n    activate: (app, manager, notebooks) => {\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, panel) => {\n            var _a, _b;\n            const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = panel.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: panel });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = panel.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            panel.content.activeCellChanged.connect(updateConnector);\n            panel.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add notebook completer command.\n        app.commands.addCommand(CommandIDs.invokeNotebook, {\n            execute: () => {\n                var _a;\n                const panel = notebooks.currentWidget;\n                if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                    return app.commands.execute(CommandIDs.invoke, { id: panel.id });\n                }\n            }\n        });\n        // Add notebook completer select command.\n        app.commands.addCommand(CommandIDs.selectNotebook, {\n            execute: () => {\n                const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for notebook completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectNotebook,\n            keys: ['Enter'],\n            selector: `.jp-Notebook .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers file editors for completion.\n */\nconst files = {\n    id: '@jupyterlab/completer-extension:files',\n    requires: [ICompletionManager, IEditorTracker],\n    autoStart: true,\n    activate: (app, manager, editorTracker) => {\n        // Keep a list of active ISessions so that we can\n        // clean them up when they are no longer needed.\n        const activeSessions = {};\n        // When a new file editor is created, make the completer for it.\n        editorTracker.widgetAdded.connect((sender, widget) => {\n            const sessions = app.serviceManager.sessions;\n            const editor = widget.content.editor;\n            const contextConnector = new ContextConnector({ editor });\n            // Initially create the handler with the contextConnector.\n            // If a kernel session is found matching this file editor,\n            // it will be replaced in onRunningChanged().\n            const handler = manager.register({\n                connector: contextConnector,\n                editor,\n                parent: widget\n            });\n            // When the list of running sessions changes,\n            // check to see if there are any kernels with a\n            // matching path for this file editor.\n            const onRunningChanged = (sender, models) => {\n                const oldSession = activeSessions[widget.id];\n                // Search for a matching path.\n                const model = find(models, m => m.path === widget.context.path);\n                if (model) {\n                    // If there is a matching path, but it is the same\n                    // session as we previously had, do nothing.\n                    if (oldSession && oldSession.id === model.id) {\n                        return;\n                    }\n                    // Otherwise, dispose of the old session and reset to\n                    // a new CompletionConnector.\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                    const session = sessions.connectTo({ model });\n                    handler.connector = new CompletionConnector({ session, editor });\n                    activeSessions[widget.id] = session;\n                }\n                else {\n                    // If we didn't find a match, make sure\n                    // the connector is the contextConnector and\n                    // dispose of any previous connection.\n                    handler.connector = contextConnector;\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                }\n            };\n            onRunningChanged(sessions, toArray(sessions.running()));\n            sessions.runningChanged.connect(onRunningChanged);\n            // When the widget is disposed, do some cleanup.\n            widget.disposed.connect(() => {\n                sessions.runningChanged.disconnect(onRunningChanged);\n                const session = activeSessions[widget.id];\n                if (session) {\n                    delete activeSessions[widget.id];\n                    session.dispose();\n                }\n            });\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectFile,\n            keys: ['Enter'],\n            selector: `.jp-FileEditor .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    consoles,\n    notebooks,\n    files\n];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"names":["CommandIDs","invoke","invokeConsole","invokeNotebook","invokeFile","select","selectConsole","selectNotebook","selectFile","manager","id","autoStart","provides","ICompletionManager","activate","app","handlers","commands","addCommand","execute","args","handler","completer","selectActive","register","completable","renderer","Completer","connector","editor","parent","model","CompleterModel","CompletionHandler","hide","Widget","document","body","disposed","connect","dispose","consoles","requires","IConsoleTracker","widgetAdded","sender","widget","_a","_b","anchor","console","promptCell","session","sessionContext","CompletionConnector","updateConnector","promptCellCreated","sessionChanged","currentWidget","addKeyBinding","command","keys","selector","notebooks","INotebookTracker","panel","content","activeCell","activeCellChanged","type","files","IEditorTracker","editorTracker","activeSessions","sessions","serviceManager","contextConnector","ContextConnector","onRunningChanged","models","oldSession","find","m","path","context","connectTo","toArray","running","runningChanged","disconnect"],"sourceRoot":""}